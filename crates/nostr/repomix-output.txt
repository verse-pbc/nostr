This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
examples/
  embedded/
    src/
      main.rs
    .gitignore
    Cargo.toml
    justfile
    memory.x
    README.md
    rust-toolchain.toml
  keys.rs
  metadata.rs
  nip05.rs
  nip06.rs
  nip09.rs
  nip11.rs
  nip13.rs
  nip15.rs
  nip19.rs
  nip57.rs
  vanity.rs
src/
  event/
    tag/
      error.rs
      kind.rs
      list.rs
      mod.rs
      standard.rs
    builder.rs
    id.rs
    kind.rs
    mod.rs
    partial.rs
    raw.rs
    unsigned.rs
  key/
    mod.rs
    public_key.rs
    secret_key.rs
    vanity.rs
  message/
    relay/
      mod.rs
      raw.rs
    client.rs
    mod.rs
  nips/
    nip44/
      mod.rs
      nip44.vectors.json
      v2.rs
    mod.rs
    nip01.rs
    nip04.rs
    nip05.rs
    nip06.rs
    nip07.rs
    nip10.rs
    nip11.rs
    nip13.rs
    nip15.rs
    nip17.rs
    nip19.rs
    nip21.rs
    nip26.rs
    nip34.rs
    nip39.rs
    nip46.rs
    nip47.rs
    nip48.rs
    nip49.rs
    nip51.rs
    nip53.rs
    nip56.rs
    nip57.rs
    nip58.rs
    nip59.rs
    nip65.rs
    nip73.rs
    nip90.rs
    nip94.rs
    nip98.rs
  types/
    time/
      mod.rs
      supplier.rs
    contact.rs
    filter.rs
    image.rs
    metadata.rs
    mod.rs
    url.rs
  util/
    hex.rs
    hkdf.rs
    mod.rs
  lib.rs
  prelude.rs
  signer.rs
Cargo.toml
README.md

================================================================
Files
================================================================

================
File: examples/embedded/src/main.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

#![feature(alloc_error_handler)]
#![feature(panic_info_message)]
#![no_std]
#![no_main]

extern crate alloc;
extern crate nostr;

use core::panic::PanicInfo;

use alloc_cortex_m::CortexMHeap;
use cortex_m_rt::entry;
use cortex_m_semihosting::{debug, hprintln};
use nostr::secp256k1::rand::{self, RngCore};
use nostr::secp256k1::Secp256k1;
use nostr::{FromBech32, Keys, ToBech32, SecretKey};
use nostr::nips::nip06::FromMnemonic;

// this is the allocator the application will use
#[global_allocator]
static ALLOCATOR: CortexMHeap = CortexMHeap::empty();

const HEAP_SIZE: usize = 1024 * 256; // 256 KB

struct FakeRng;

impl RngCore for FakeRng {
    fn next_u32(&mut self) -> u32 {
        57
    }

    fn next_u64(&mut self) -> u64 {
        57
    }

    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand::Error> {
        for i in dest {
            *i = 57;
        }
        Ok(())
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.try_fill_bytes(dest).unwrap();
    }
}

#[entry]
fn main() -> ! {
    hprintln!("heap size {}\n", HEAP_SIZE).unwrap();

    unsafe { ALLOCATOR.init(cortex_m_rt::heap_start() as usize, HEAP_SIZE) }

    let secp = Secp256k1::new();

    // Restore from bech32 secret key
    let secret_key =
        SecretKey::from_bech32("nsec1j4c6269y9w0q2er2xjw8sv2ehyrtfxq3jwgdlxj6qfn8z4gjsq5qfvfk99")
            .unwrap();
    let keys = Keys::new_with_ctx(&secp, secret_key);
    hprintln!("Restored keys from bech32:").unwrap();
    print_keys(&keys);

    // Restore from menmonic
    let mnemonic: &str = "equal dragon fabric refuse stable cherry smoke allow alley easy never medal attend together lumber movie what sad siege weather matrix buffalo state shoot";
    let keys = Keys::from_mnemonic_with_ctx(&secp, mnemonic, None, None, None, None).unwrap();
    hprintln!("\nRestore keys from mnemonic:").unwrap();
    print_keys(&keys);

    // Generate new random keys
    let keys = Keys::generate_with_ctx(&secp, &mut FakeRng);
    hprintln!("\nRandom keys (using FakeRng):").unwrap();
    print_keys(&keys);

    // exit QEMU
    // NOTE do not run this on hardware; it can corrupt OpenOCD state
    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}

fn print_keys(keys: &Keys) {
    hprintln!(
        "- Secret Key (hex): {}",
        keys.secret_key().to_secret_hex()
    )
    .unwrap();
    hprintln!("- Public Key (hex): {}", keys.public_key()).unwrap();
    hprintln!(
        "- Secret Key (bech32): {}",
        keys.secret_key().to_bech32().unwrap()
    )
    .unwrap();
    hprintln!(
        "- Public Key (bech32): {}",
        keys.public_key().to_bech32().unwrap()
    )
    .unwrap();
}

#[inline(never)]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    hprintln!("panic {:?}", info.message()).unwrap();
    debug::exit(debug::EXIT_FAILURE);
    loop {}
}

================
File: examples/embedded/.gitignore
================
Cargo.lock

================
File: examples/embedded/Cargo.toml
================
[package]
name = "embedded"
version = "0.1.0"
edition = "2021"

# Prevent this from interfering with workspaces
[workspace]
members = ["."]

[[bin]]
name = "embedded"
test = false
bench = false

[dependencies]
alloc-cortex-m = "0.4.1"
cortex-m = "0.6.0"
cortex-m-rt = "0.6.10"
cortex-m-semihosting = "0.3.3"
nostr = { path = "../../../nostr", default-features = false, features = ["alloc", "nip06"] }

[profile.release]
opt-level = "z"
codegen-units = 1 # better optimizations
lto = true # better optimizations
debug = true # symbols are nice and they don't increase the size on Flash

================
File: examples/embedded/justfile
================
RUSTFLAGS := "-C link-arg=-Tlink.x"
CARGO_TARGET_THUMBV7M_NONE_EABI_RUNNER := "qemu-system-arm -cpu cortex-m3 -machine mps2-an385 -nographic -semihosting-config enable=on,target=native -kernel"

default: build

init:
	sudo apt install -y gcc-arm-none-eabi qemu-system-arm gdb-multiarch

build:
	RUSTFLAGS="{{RUSTFLAGS}}" CARGO_TARGET_THUMBV7M_NONE_EABI_RUNNER="{{CARGO_TARGET_THUMBV7M_NONE_EABI_RUNNER}}" cargo build --release --target thumbv7m-none-eabi

run:
	RUSTFLAGS="{{RUSTFLAGS}}" CARGO_TARGET_THUMBV7M_NONE_EABI_RUNNER="{{CARGO_TARGET_THUMBV7M_NONE_EABI_RUNNER}}" cargo run --release --target thumbv7m-none-eabi

================
File: examples/embedded/memory.x
================
MEMORY
{
  FLASH : ORIGIN = 0x00000000, LENGTH = 512K
  RAM : ORIGIN = 0x20000000, LENGTH = 512K
}

================
File: examples/embedded/README.md
================
# Embedded

## Running

To run the embedded test, first prepare your environment:

```shell
make init
```

Then:

```shell
make run
```

Output should be something like:

```text
heap size 262144

Restored keys from bech32:
- Secret Key (hex): 9571a568a42b9e05646a349c783159b906b498119390df9a5a02667155128028
- Public Key (hex): aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4
- Secret Key (bech32): nsec1j4c6269y9w0q2er2xjw8sv2ehyrtfxq3jwgdlxj6qfn8z4gjsq5qfvfk99
- Public Key (bech32): npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy

Restore keys from mnemonic:
- Secret Key (hex): 06992419a8fe821dd8de03d4c300614e8feefb5ea936b76f89976dcace8aebee
- Public Key (hex): 648777b13344158549551f215ab2885d71af8861456eebea7102b1c729fc2de2
- Secret Key (bech32): nsec1q6vjgxdgl6ppmkx7q02vxqrpf687a7674ymtwmufjaku4n52a0hq9glmaf
- Public Key (bech32): npub1vjrh0vfngs2c2j24rus44v5gt4c6lzrpg4hwh6n3q2cuw20u9h3q4qf4pg

Random keys (using FakeRng):
- Secret Key (hex): 3939393939393939393939393939393939393939393939393939393939393939
- Public Key (hex): 1ff10be221c7b140505038042f5cc86530e9851a0e6c70ee16c18268768c2e02
- Secret Key (bech32): nsec18yunjwfe8yunjwfe8yunjwfe8yunjwfe8yunjwfe8yunjwfe8yusu2d2eh
- Public Key (bech32): npub1rlcshc3pc7c5q5zs8qzz7hxgv5cwnpg6pek8pmskcxpxsa5v9cpqqk7k0t
```

Note that this heap size is required because of the amount of stack used by libsecp256k1 when initializing a context.

================
File: examples/embedded/rust-toolchain.toml
================
[toolchain]
channel = "nightly"
profile = "minimal"
targets = ["thumbv7m-none-eabi"]

================
File: examples/keys.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

fn main() -> Result<()> {
    // Random keys
    let keys = Keys::generate();
    let public_key = keys.public_key();
    let secret_key = keys.secret_key();

    println!("Public key: {}", public_key);
    println!("Public key bech32: {}", public_key.to_bech32()?);
    println!("Secret key: {}", secret_key.to_secret_hex());
    println!("Secret key bech32: {}", secret_key.to_bech32()?);

    // Bech32 keys
    let secret_key =
        SecretKey::from_bech32("nsec1j4c6269y9w0q2er2xjw8sv2ehyrtfxq3jwgdlxj6qfn8z4gjsq5qfvfk99")?;
    let keys = Keys::new(secret_key);
    println!("Public key: {}", keys.public_key());

    Ok(())
}

================
File: examples/metadata.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

fn main() -> Result<()> {
    let metadata = Metadata::new()
        .name("username")
        .display_name("My Username")
        .about("Description")
        .picture(Url::parse("https://example.com/avatar.png")?)
        .banner(Url::parse("https://example.com/banner.png")?)
        .nip05("username@example.com")
        .lud16("pay@yukikishimoto.com");

    println!("{}", metadata.as_json());

    Ok(())
}

================
File: examples/nip05.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

#[tokio::main]
async fn main() -> Result<()> {
    let public_key =
        PublicKey::parse("b2d670de53b27691c0c3400225b65c35a26d06093bcc41f48ffc71e0907f9d4a")?;

    if nip05::verify(&public_key, "0xtr@oxtr.dev", None).await? {
        println!("NIP05 verified");
    } else {
        println!("NIP05 NOT verified");
    }

    let profile: Nip05Profile = nip05::profile("_@fiatjaf.com", None).await?;
    println!("Public key: {}", profile.public_key);
    println!("Relays: {:?}", profile.relays);
    println!("Relays (NIP46): {:?}", profile.nip46);

    Ok(())
}

================
File: examples/nip06.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::nips::nip06::FromMnemonic;
use nostr::nips::nip19::ToBech32;
use nostr::{Keys, Result};

const MNEMONIC_PHRASE: &str = "equal dragon fabric refuse stable cherry smoke allow alley easy never medal attend together lumber movie what sad siege weather matrix buffalo state shoot";

fn main() -> Result<()> {
    let keys = Keys::from_mnemonic(MNEMONIC_PHRASE, Some("mypassphrase"))?;
    println!("{}", keys.secret_key().to_bech32()?);

    Ok(())
}

================
File: examples/nip09.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

fn main() -> Result<()> {
    let keys = Keys::parse("nsec1ufnus6pju578ste3v90xd5m2decpuzpql2295m3sknqcjzyys9ls0qlc85")?;

    let event_id =
        EventId::from_hex("7469af3be8c8e06e1b50ef1caceba30392ddc0b6614507398b7d7daa4c218e96")?;

    let event: Event =
        EventBuilder::delete_with_reason(vec![event_id], "these posts were published by accident")
            .sign_with_keys(&keys)?;
    println!("{}", event.as_json());

    Ok(())
}

================
File: examples/nip11.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

#[tokio::main]
async fn main() -> Result<()> {
    let relay_url = Url::parse("wss://relay.damus.io")?;

    let info = RelayInformationDocument::get(relay_url, None).await?;

    println!("{:#?}", info);

    Ok(())
}

================
File: examples/nip13.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

fn main() -> Result<()> {
    let keys = Keys::parse("6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e")?;

    let difficulty = 20; // leading zero bits
    let msg_content = "This is a Nostr message with embedded proof-of-work";

    let event: Event = EventBuilder::text_note(msg_content)
        .pow(difficulty)
        .sign_with_keys(&keys)?;

    println!("{}", event.as_json());

    Ok(())
}

================
File: examples/nip15.rs
================
// Copyright (c) 2023 ProTom
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

fn main() -> Result<()> {
    let keys = Keys::parse("6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e")?;

    let shipping = ShippingMethod::new("123", 5.50).name("DHL");

    let stall = StallData::new("123", "my test stall", "USD")
        .description("this is a test stall")
        .shipping(vec![shipping.clone()]);

    let stall_event = EventBuilder::stall_data(stall).sign_with_keys(&keys)?;
    println!("{}", stall_event.as_json());

    let product = ProductData::new("1", "123", "my test product", "USD")
        .description("this is a test product")
        .price(5.50)
        .shipping(vec![shipping.get_shipping_cost()])
        .images(vec!["https://example.com/image.png".into()])
        .categories(vec!["test".into()]);

    let product_event = EventBuilder::product_data(product).sign_with_keys(&keys)?;
    println!("{}", product_event.as_json());

    Ok(())
}

================
File: examples/nip19.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

fn main() -> Result<()> {
    let pubkey =
        PublicKey::from_hex("3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d")?;
    let profile =
        Nip19Profile::new(pubkey, vec!["wss://r.x.com", "wss://djbas.sadkb.com"]).unwrap();
    println!("{}", profile.to_bech32()?);

    Ok(())
}

================
File: examples/nip57.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Distributed under the MIT software license

use nostr::prelude::*;

fn main() -> Result<()> {
    let keys = Keys::parse("6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e")?;

    let public_key =
        PublicKey::from_bech32("npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy")?;
    let relays = [Url::parse("wss://relay.damus.io").unwrap()];
    let data = ZapRequestData::new(public_key, relays).message("Zap!");

    let public_zap: Event = EventBuilder::public_zap_request(data.clone()).sign_with_keys(&keys)?;
    println!("Public zap request: {}", public_zap.as_json());

    let anon_zap: Event = nip57::anonymous_zap_request(data.clone())?;
    println!("Anonymous zap request: {}", anon_zap.as_json());

    let private_zap: Event = nip57::private_zap_request(data, &keys)?;
    println!("Private zap request: {}", private_zap.as_json());

    Ok(())
}

================
File: examples/vanity.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use nostr::prelude::*;

fn main() -> Result<()> {
    let num_cores = num_cpus::get();
    let keys = Keys::vanity(vec!["0000", "yuk", "yuk0"], true, num_cores)?;
    println!("Secret key: {}", keys.secret_key().to_bech32()?);
    println!("Public key: {}", keys.public_key().to_bech32()?);
    Ok(())
}

================
File: src/event/tag/error.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

use core::fmt;
use core::num::ParseIntError;

use crate::event::id;
use crate::hashes::hex::HexToArrayError;
use crate::nips::{nip01, nip10, nip26, nip39, nip53, nip65, nip98};
use crate::types::image;
use crate::types::url::{Error as RelayUrlError, ParseError};
use crate::{key, secp256k1};

/// Tag error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Keys
    Keys(key::Error),
    /// Impossible to find tag kind
    KindNotFound,
    /// Empty tag
    EmptyTag,
    /// Invalid Zap Request
    InvalidZapRequest,
    /// Impossible to parse integer
    ParseIntError(ParseIntError),
    /// Secp256k1
    Secp256k1(secp256k1::Error),
    /// Hex decoding error
    Hex(HexToArrayError),
    /// Relay Url parse error
    RelayUrl(RelayUrlError),
    /// Url parse error
    Url(ParseError),
    /// EventId error
    EventId(id::Error),
    /// NIP01 error
    NIP01(nip01::Error),
    /// NIP10 error
    NIP10(nip10::Error),
    /// NIP26 error
    NIP26(nip26::Error),
    /// NIP39 error
    NIP39(nip39::Error),
    /// NIP53 error
    NIP53(nip53::Error),
    /// NIP65 error
    NIP65(nip65::Error),
    /// NIP98 error
    NIP98(nip98::Error),
    /// Event Error
    Event(crate::event::Error),
    /// Image
    Image(image::Error),
    /// Unknown standardized tag
    UnknownStardardizedTag,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Keys(e) => write!(f, "{e}"),
            Self::ParseIntError(e) => write!(f, "{e}"),
            Self::Secp256k1(e) => write!(f, "{e}"),
            Self::Hex(e) => write!(f, "{e}"),
            Self::RelayUrl(e) => write!(f, "{e}"),
            Self::Url(e) => write!(f, "{e}"),
            Self::EventId(e) => write!(f, "{e}"),
            Self::NIP01(e) => write!(f, "{e}"),
            Self::NIP10(e) => write!(f, "{e}"),
            Self::NIP26(e) => write!(f, "{e}"),
            Self::NIP39(e) => write!(f, "{e}"),
            Self::NIP53(e) => write!(f, "{e}"),
            Self::NIP65(e) => write!(f, "{e}"),
            Self::NIP98(e) => write!(f, "{e}"),
            Self::Event(e) => write!(f, "{e}"),
            Self::Image(e) => write!(f, "{e}"),
            Self::UnknownStardardizedTag => write!(f, "Unknown standardized tag"),
            Self::KindNotFound => write!(f, "Impossible to find tag kind"),
            Self::EmptyTag => write!(f, "Empty tag"),
            Self::InvalidZapRequest => write!(f, "Invalid Zap request"),
        }
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Keys(e)
    }
}

impl From<ParseIntError> for Error {
    fn from(e: ParseIntError) -> Self {
        Self::ParseIntError(e)
    }
}

impl From<secp256k1::Error> for Error {
    fn from(e: secp256k1::Error) -> Self {
        Self::Secp256k1(e)
    }
}

impl From<HexToArrayError> for Error {
    fn from(e: HexToArrayError) -> Self {
        Self::Hex(e)
    }
}

impl From<RelayUrlError> for Error {
    fn from(e: RelayUrlError) -> Self {
        Self::RelayUrl(e)
    }
}

impl From<ParseError> for Error {
    fn from(e: ParseError) -> Self {
        Self::Url(e)
    }
}

impl From<id::Error> for Error {
    fn from(e: id::Error) -> Self {
        Self::EventId(e)
    }
}

impl From<nip01::Error> for Error {
    fn from(e: nip01::Error) -> Self {
        Self::NIP01(e)
    }
}

impl From<nip10::Error> for Error {
    fn from(e: nip10::Error) -> Self {
        Self::NIP10(e)
    }
}

impl From<nip26::Error> for Error {
    fn from(e: nip26::Error) -> Self {
        Self::NIP26(e)
    }
}

impl From<nip39::Error> for Error {
    fn from(e: nip39::Error) -> Self {
        Self::NIP39(e)
    }
}

impl From<nip53::Error> for Error {
    fn from(e: nip53::Error) -> Self {
        Self::NIP53(e)
    }
}

impl From<nip65::Error> for Error {
    fn from(e: nip65::Error) -> Self {
        Self::NIP65(e)
    }
}

impl From<nip98::Error> for Error {
    fn from(e: nip98::Error) -> Self {
        Self::NIP98(e)
    }
}

impl From<crate::event::Error> for Error {
    fn from(e: crate::event::Error) -> Self {
        Self::Event(e)
    }
}

impl From<image::Error> for Error {
    fn from(e: image::Error) -> Self {
        Self::Image(e)
    }
}

================
File: src/event/tag/kind.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Tag kind

use alloc::borrow::Cow;
use core::fmt;
use core::str::FromStr;

use crate::{Alphabet, SingleLetterTag};

/// Tag kind
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TagKind<'a> {
    /// AES 256 GCM
    Aes256Gcm,
    /// Human-readable plaintext summary of what that event is about
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/31.md>
    Alt,
    /// Amount
    Amount,
    /// Anonymous
    Anon,
    /// Blurhash
    Blurhash,
    /// Bolt11 invoice
    Bolt11,
    /// Challenge
    Challenge,
    /// Client
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/89.md>
    Client,
    /// Clone
    Clone,
    /// Commit
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/34.md>
    Commit,
    /// Content warning
    ContentWarning,
    /// Current participants
    CurrentParticipants,
    /// Delegation
    Delegation,
    /// Description
    Description,
    /// Size of file in pixels
    Dim,
    /// Emoji
    Emoji,
    /// Encrypted
    Encrypted,
    /// Ends
    Ends,
    /// Expiration
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/40.md>
    Expiration,
    /// Image
    Image,
    /// Lnurl
    Lnurl,
    /// Magnet
    Magnet,
    /// Maintainers
    Maintainers,
    /// HTTP Method Request
    Method,
    /// MLS Protocol Version
    MlsProtocolVersion,
    /// MLS Cipher Suite
    MlsCiphersuite,
    /// MLS Extensions
    MlsExtensions,
    /// Name
    Name,
    /// Nonce
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/13.md>
    Nonce,
    /// Payload
    Payload,
    /// Preimage
    Preimage,
    /// Protected event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/70.md>
    Protected,
    /// Proxy
    Proxy,
    /// PublishedAt
    PublishedAt,
    /// Recording
    Recording,
    /// Relay
    Relay,
    /// Relays
    Relays,
    /// Request
    Request,
    /// Size of file in bytes
    Size,
    /// Starts
    Starts,
    /// Status
    Status,
    /// Streaming
    Streaming,
    /// Subject
    Subject,
    /// Summary
    Summary,
    /// Title
    Title,
    /// Thumbnail
    Thumb,
    /// Total participants
    TotalParticipants,
    /// Url
    Url,
    /// Web
    Web,
    /// Word
    Word,
    /// Single letter
    SingleLetter(SingleLetterTag),
    /// Custom
    Custom(Cow<'a, str>),
}

impl<'a> TagKind<'a> {
    /// Construct `a` kind
    ///
    /// Shorthand for `TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::A))`.
    #[inline]
    pub fn a() -> Self {
        Self::SingleLetter(SingleLetterTag::lowercase(Alphabet::A))
    }

    /// Construct `d` kind
    ///
    /// Shorthand for `TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::D))`.
    #[inline]
    pub fn d() -> Self {
        Self::SingleLetter(SingleLetterTag::lowercase(Alphabet::D))
    }

    /// Construct `e` kind
    ///
    /// Shorthand for `TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::E))`.
    #[inline]
    pub fn e() -> Self {
        Self::SingleLetter(SingleLetterTag::lowercase(Alphabet::E))
    }

    /// Construct `h` kind
    ///
    /// Shorthand for `TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::H))`.
    #[inline]
    pub fn h() -> Self {
        Self::SingleLetter(SingleLetterTag::lowercase(Alphabet::H))
    }

    /// Construct `p` kind
    ///
    /// Shorthand for `TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::P))`.
    #[inline]
    pub fn p() -> Self {
        Self::SingleLetter(SingleLetterTag::lowercase(Alphabet::P))
    }

    /// Construct `t` kind
    ///
    /// Shorthand for `TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::T))`.
    #[inline]
    pub fn t() -> Self {
        Self::SingleLetter(SingleLetterTag::lowercase(Alphabet::T))
    }

    /// Construct `q` kind
    ///
    /// Shorthand for `TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::Q))`.
    #[inline]
    pub fn q() -> Self {
        Self::SingleLetter(SingleLetterTag::lowercase(Alphabet::Q))
    }

    /// Construct [`TagKind::Custom`]
    ///
    /// Shorthand for `TagKind::Custom(Cow::from(...))`.
    #[inline]
    pub fn custom<T>(kind: T) -> Self
    where
        T: Into<Cow<'a, str>>,
    {
        Self::Custom(kind.into())
    }

    /// Convert to `&str`
    pub fn as_str(&self) -> &str {
        match self {
            Self::Aes256Gcm => "aes-256-gcm",
            Self::Alt => "alt",
            Self::Amount => "amount",
            Self::Anon => "anon",
            Self::Blurhash => "blurhash",
            Self::Bolt11 => "bolt11",
            Self::Challenge => "challenge",
            Self::Client => "client",
            Self::Clone => "clone",
            Self::Commit => "commit",
            Self::ContentWarning => "content-warning",
            Self::CurrentParticipants => "current_participants",
            Self::Delegation => "delegation",
            Self::Description => "description",
            Self::Dim => "dim",
            Self::Emoji => "emoji",
            Self::Encrypted => "encrypted",
            Self::Ends => "ends",
            Self::Expiration => "expiration",
            Self::Image => "image",
            Self::Lnurl => "lnurl",
            Self::Magnet => "magnet",
            Self::Maintainers => "maintainers",
            Self::Method => "method",
            Self::MlsProtocolVersion => "mls_protocol_version",
            Self::MlsCiphersuite => "mls_ciphersuite",
            Self::MlsExtensions => "mls_extensions",
            Self::Name => "name",
            Self::Nonce => "nonce",
            Self::Payload => "payload",
            Self::Preimage => "preimage",
            Self::Protected => "-",
            Self::Proxy => "proxy",
            Self::PublishedAt => "published_at",
            Self::Recording => "recording",
            Self::Relay => "relay",
            Self::Relays => "relays",
            Self::Request => "request",
            Self::Size => "size",
            Self::Starts => "starts",
            Self::Status => "status",
            Self::Streaming => "streaming",
            Self::Subject => "subject",
            Self::Summary => "summary",
            Self::Title => "title",
            Self::Thumb => "thumb",
            Self::TotalParticipants => "total_participants",
            Self::Url => "url",
            Self::Web => "web",
            Self::Word => "word",
            Self::SingleLetter(s) => s.as_str(),
            Self::Custom(tag) => tag.as_ref(),
        }
    }
}

impl<'a> fmt::Display for TagKind<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl<'a> From<&'a str> for TagKind<'a> {
    fn from(kind: &'a str) -> Self {
        match kind {
            "-" => Self::Protected,
            "aes-256-gcm" => Self::Aes256Gcm,
            "alt" => Self::Alt,
            "amount" => Self::Amount,
            "anon" => Self::Anon,
            "blurhash" => Self::Blurhash,
            "bolt11" => Self::Bolt11,
            "challenge" => Self::Challenge,
            "client" => Self::Client,
            "clone" => Self::Clone,
            "commit" => Self::Commit,
            "content-warning" => Self::ContentWarning,
            "current_participants" => Self::CurrentParticipants,
            "delegation" => Self::Delegation,
            "description" => Self::Description,
            "dim" => Self::Dim,
            "emoji" => Self::Emoji,
            "encrypted" => Self::Encrypted,
            "ends" => Self::Ends,
            "expiration" => Self::Expiration,
            "image" => Self::Image,
            "lnurl" => Self::Lnurl,
            "magnet" => Self::Magnet,
            "maintainers" => Self::Maintainers,
            "method" => Self::Method,
            "mls_protocol_version" => Self::MlsProtocolVersion,
            "mls_ciphersuite" => Self::MlsCiphersuite,
            "mls_extensions" => Self::MlsExtensions,
            "name" => Self::Name,
            "nonce" => Self::Nonce,
            "payload" => Self::Payload,
            "preimage" => Self::Preimage,
            "proxy" => Self::Proxy,
            "published_at" => Self::PublishedAt,
            "recording" => Self::Recording,
            "relay" => Self::Relay,
            "relays" => Self::Relays,
            "request" => Self::Request,
            "size" => Self::Size,
            "starts" => Self::Starts,
            "status" => Self::Status,
            "streaming" => Self::Streaming,
            "subject" => Self::Subject,
            "summary" => Self::Summary,
            "title" => Self::Title,
            "thumb" => Self::Thumb,
            "total_participants" => Self::TotalParticipants,
            "url" => Self::Url,
            "web" => Self::Web,
            "word" => Self::Word,
            k => match SingleLetterTag::from_str(k) {
                Ok(s) => Self::SingleLetter(s),
                Err(..) => Self::Custom(Cow::Borrowed(k)),
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use alloc::string::{String, ToString};

    use super::*;

    #[test]
    fn test_custom_tag_kind_constructor() {
        let owned = TagKind::custom(String::from("owned"));
        match owned {
            TagKind::Custom(Cow::Owned(val)) => assert_eq!(val, "owned"),
            _ => panic!("Unexpected tag kind"),
        };

        let borrowed = TagKind::custom("borrowed");
        match borrowed {
            TagKind::Custom(Cow::Borrowed(val)) => assert_eq!(val, "borrowed"),
            _ => panic!("Unexpected tag kind"),
        };
    }

    #[test]
    fn test_from_to_tag_kind() {
        assert_eq!(TagKind::from("clone"), TagKind::Clone);
        assert_eq!(TagKind::Clone.to_string(), "clone");

        assert_eq!(TagKind::from("maintainers"), TagKind::Maintainers);
        assert_eq!(TagKind::Maintainers.to_string(), "maintainers");

        assert_eq!(TagKind::from("web"), TagKind::Web);
        assert_eq!(TagKind::Web.to_string(), "web");
    }
}

================
File: src/event/tag/list.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Tags (tag list)

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::string::{String, ToString};
use alloc::vec::{IntoIter, Vec};
use core::cmp::Ordering;
use core::fmt;
use core::hash::{Hash, Hasher};
use core::slice::Iter;
#[cfg(feature = "std")]
use std::sync::OnceLock;

use serde::ser::SerializeSeq;
use serde::{Deserialize, Deserializer, Serialize, Serializer};

use super::Tag;
use crate::nips::nip01::Coordinate;
use crate::{EventId, PublicKey, SingleLetterTag, TagKind, TagStandard, Timestamp};

/// Tags Indexes
pub type TagsIndexes = BTreeMap<SingleLetterTag, BTreeSet<String>>;

/// Tag list
#[derive(Clone)]
pub struct Tags {
    list: Vec<Tag>,
    #[cfg(feature = "std")]
    indexes: OnceLock<TagsIndexes>,
}

impl fmt::Debug for Tags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self.list)
    }
}

impl PartialEq for Tags {
    fn eq(&self, other: &Self) -> bool {
        self.list == other.list
    }
}

impl Eq for Tags {}

impl PartialOrd for Tags {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Tags {
    fn cmp(&self, other: &Self) -> Ordering {
        self.list.cmp(&other.list)
    }
}

impl Hash for Tags {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.list.hash(state);
    }
}

impl Tags {
    /// Construct new tag list.
    #[inline]
    pub fn new(list: Vec<Tag>) -> Self {
        Self {
            list,
            #[cfg(feature = "std")]
            indexes: OnceLock::new(),
        }
    }

    /// Get number of tags.
    #[inline]
    pub fn len(&self) -> usize {
        self.list.len()
    }

    /// Check if contains no tags.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.list.is_empty()
    }

    /// Get first tag
    #[inline]
    pub fn first(&self) -> Option<&Tag> {
        self.list.first()
    }

    /// Get last tag
    #[inline]
    pub fn last(&self) -> Option<&Tag> {
        self.list.last()
    }

    /// Get tag at index
    #[inline]
    pub fn get(&self, index: usize) -> Option<&Tag> {
        self.list.get(index)
    }

    /// Iterate tags
    #[inline]
    pub fn iter(&self) -> Iter<'_, Tag> {
        self.list.iter()
    }

    /// Get first tag that match [`TagKind`].
    #[inline]
    pub fn find(&self, kind: TagKind) -> Option<&Tag> {
        self.list.iter().find(|t| t.kind() == kind)
    }

    /// Get first tag that match [`TagKind`] and that is standardized.
    #[inline]
    pub fn find_standardized(&self, kind: TagKind) -> Option<&TagStandard> {
        self.find(kind).and_then(|t| t.as_standardized())
    }

    /// Get first tag that match [`TagKind`].
    #[inline]
    pub fn filter<'a>(&'a self, kind: TagKind<'a>) -> impl Iterator<Item = &'a Tag> {
        self.list.iter().filter(move |t| t.kind() == kind)
    }

    /// Get first tag that match [`TagKind`] and that is standardized.
    #[inline]
    pub fn filter_standardized<'a>(
        &'a self,
        kind: TagKind<'a>,
    ) -> impl Iterator<Item = &'a TagStandard> {
        self.filter(kind).filter_map(|t| t.as_standardized())
    }

    /// Get as slice of tags
    #[inline]
    pub fn as_slice(&self) -> &[Tag] {
        &self.list
    }

    /// Convert [`Tags`] into [`Vec<Tag>`].
    #[inline]
    pub fn to_vec(self) -> Vec<Tag> {
        self.list
    }

    /// Extract identifier (`d` tag), if exists.
    #[inline]
    pub fn identifier(&self) -> Option<&str> {
        let standardized: &TagStandard = self.find_standardized(TagKind::d())?;
        match standardized {
            TagStandard::Identifier(identifier) => Some(identifier),
            _ => None,
        }
    }

    /// Get [`Timestamp`] expiration, if set.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/40.md>
    pub fn expiration(&self) -> Option<&Timestamp> {
        let standardized: &TagStandard = self.find_standardized(TagKind::Expiration)?;
        match standardized {
            TagStandard::Expiration(timestamp) => Some(timestamp),
            _ => None,
        }
    }

    /// Extract public keys from `p` tags.
    ///
    /// This method extract only [`TagStandard::PublicKey`], [`TagStandard::PublicKeyReport`] and [`TagStandard::PublicKeyLiveEvent`] variants.
    #[inline]
    pub fn public_keys(&self) -> impl Iterator<Item = &PublicKey> {
        self.filter_standardized(TagKind::p())
            .filter_map(|t| match t {
                TagStandard::PublicKey { public_key, .. } => Some(public_key),
                TagStandard::PublicKeyReport(public_key, ..) => Some(public_key),
                TagStandard::PublicKeyLiveEvent { public_key, .. } => Some(public_key),
                _ => None,
            })
    }

    /// Extract event IDs from `e` tags.
    ///
    /// This method extract only [`TagStandard::Event`] and [`TagStandard::EventReport`] variants.
    #[inline]
    pub fn event_ids(&self) -> impl Iterator<Item = &EventId> {
        self.filter_standardized(TagKind::e())
            .filter_map(|t| match t {
                TagStandard::Event { event_id, .. } => Some(event_id),
                TagStandard::EventReport(event_id, ..) => Some(event_id),
                _ => None,
            })
    }

    /// Extract coordinates from `a` tags.
    ///
    /// This method extract only [`TagStandard::Coordinate`] variant.
    #[inline]
    pub fn coordinates(&self) -> impl Iterator<Item = &Coordinate> {
        self.filter_standardized(TagKind::a())
            .filter_map(|t| match t {
                TagStandard::Coordinate { coordinate, .. } => Some(coordinate),
                _ => None,
            })
    }

    /// Extract hashtags from `t` tags.
    ///
    /// This method extract only [`TagStandard::Hashtag`] variant.
    #[inline]
    pub fn hashtags(&self) -> impl Iterator<Item = &str> {
        self.filter_standardized(TagKind::t())
            .filter_map(|t| match t {
                TagStandard::Hashtag(hashtag) => Some(hashtag.as_ref()),
                _ => None,
            })
    }

    pub(crate) fn build_indexes(&self) -> TagsIndexes {
        let mut idx: TagsIndexes = TagsIndexes::new();
        for (single_letter_tag, content) in self
            .iter()
            .filter_map(|t| Some((t.single_letter_tag()?, t.content()?)))
        {
            idx.entry(single_letter_tag)
                .or_default()
                .insert(content.to_string());
        }
        idx
    }

    /// Get indexes
    #[inline]
    #[cfg(feature = "std")]
    pub fn indexes(&self) -> &TagsIndexes {
        self.indexes.get_or_init(|| self.build_indexes())
    }
}

impl AsRef<[Tag]> for Tags {
    fn as_ref(&self) -> &[Tag] {
        self.as_slice()
    }
}

impl IntoIterator for Tags {
    type Item = Tag;
    type IntoIter = IntoIter<Self::Item>;

    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.list.into_iter()
    }
}

impl Serialize for Tags {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.len()))?;
        for element in self.list.iter() {
            seq.serialize_element(&element)?;
        }
        seq.end()
    }
}

impl<'de> Deserialize<'de> for Tags {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        type Data = Vec<Tag>;
        let tags: Vec<Tag> = Data::deserialize(deserializer)?;
        Ok(Self::new(tags))
    }
}

#[cfg(test)]
mod tests {
    use crate::{Event, JsonUtil};

    #[test]
    fn test_extract_d_tag() {
        let json = r#"{"id":"3dfdbb371de782f51812dc4809ea1104d80e143cec1091a4be07f518ef09e3d7","pubkey":"b8aef32a5421205c1f89ad09e2d93873df68a8611b247f62af005655eadc0efb","created_at":1728728536,"kind":30000,"sig":"0395c41fd95d52b534eaa29c82cd9437130cf63e67117b1587914375fdfb878137287a1d15653161f91ea919afb06358784217409a9ff0323261f683b2936829","content":"older_param_replaceable","tags":[["d","1"]]}"#;
        let event = Event::from_json(json).unwrap();
        assert_eq!(event.tags.identifier(), Some("1"));
    }
}

================
File: src/event/tag/mod.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Tag

use alloc::string::{String, ToString};
use alloc::vec::Vec;
#[cfg(not(feature = "std"))]
use core::cell::OnceCell;
use core::cmp::Ordering;
use core::fmt;
use core::hash::{Hash, Hasher};
#[cfg(feature = "std")]
use std::sync::OnceLock as OnceCell;

use serde::de::Error as DeserializerError;
use serde::ser::SerializeSeq;
use serde::{Deserialize, Deserializer, Serialize, Serializer};

mod error;
pub mod kind;
pub mod list;
pub mod standard;

pub use self::error::Error;
pub use self::kind::TagKind;
pub use self::list::Tags;
pub use self::standard::TagStandard;
use super::id::EventId;
use crate::nips::nip01::Coordinate;
use crate::nips::nip10::Marker;
use crate::nips::nip56::Report;
use crate::nips::nip65::RelayMetadata;
use crate::types::Url;
use crate::{ImageDimensions, PublicKey, RelayUrl, SingleLetterTag, Timestamp};

/// Tag
#[derive(Clone)]
pub struct Tag {
    buf: Vec<String>,
    standardized: OnceCell<Option<TagStandard>>,
}

impl fmt::Debug for Tag {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("Tag").field(&self.buf).finish()
    }
}

impl PartialEq for Tag {
    fn eq(&self, other: &Self) -> bool {
        self.buf == other.buf
    }
}

impl Eq for Tag {}

impl PartialOrd for Tag {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Tag {
    fn cmp(&self, other: &Self) -> Ordering {
        self.buf.cmp(&other.buf)
    }
}

impl Hash for Tag {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.buf.hash(state);
    }
}

impl Tag {
    #[inline]
    fn new(buf: Vec<String>, standardized: Option<TagStandard>) -> Self {
        Self {
            buf,
            standardized: OnceCell::from(standardized),
        }
    }

    #[inline]
    fn new_with_empty_cell(buf: Vec<String>) -> Self {
        Self {
            buf,
            standardized: OnceCell::new(),
        }
    }

    /// Parse tag
    ///
    /// Return error if the tag is empty!
    pub fn parse<I, S>(tag: I) -> Result<Self, Error>
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        // Collect
        let tag: Vec<String> = tag.into_iter().map(|v| v.into()).collect();

        // Check if it's empty
        if tag.is_empty() {
            return Err(Error::EmptyTag);
        }

        // Construct without cell
        Ok(Self::new_with_empty_cell(tag))
    }

    /// Construct from standardized tag
    #[inline]
    pub fn from_standardized(standardized: TagStandard) -> Self {
        Self::new(standardized.clone().to_vec(), Some(standardized))
    }

    /// Construct from standardized tag without initialize cell (avoid a clone)
    #[inline]
    pub fn from_standardized_without_cell(standardized: TagStandard) -> Self {
        Self::new_with_empty_cell(standardized.to_vec())
    }

    /// Get tag kind
    #[inline]
    pub fn kind(&self) -> TagKind {
        // SAFETY: `buf` must not be empty, checked during parsing.
        let key: &str = &self.buf[0];
        TagKind::from(key)
    }

    /// Return the **first** tag value (index `1`), if exists.
    #[inline]
    pub fn content(&self) -> Option<&str> {
        self.buf.get(1).map(|s| s.as_str())
    }

    /// Get [SingleLetterTag]
    #[inline]
    pub fn single_letter_tag(&self) -> Option<SingleLetterTag> {
        match self.kind() {
            TagKind::SingleLetter(s) => Some(s),
            _ => None,
        }
    }

    /// Get reference of standardized tag
    #[inline]
    pub fn as_standardized(&self) -> Option<&TagStandard> {
        self.standardized
            .get_or_init(|| TagStandard::parse(self.as_slice()).ok())
            .as_ref()
    }

    /// Consume tag and get standardized tag
    pub fn to_standardized(self) -> Option<TagStandard> {
        match self.standardized.into_inner() {
            Some(inner) => inner,
            None => TagStandard::parse(&self.buf).ok(),
        }
    }

    /// Get as slice of strings
    #[inline]
    pub fn as_slice(&self) -> &[String] {
        &self.buf
    }

    /// Consume tag and return array of strings
    #[inline]
    pub fn to_vec(self) -> Vec<String> {
        self.buf
    }

    /// Compose `["e", "<event-id">]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn event(event_id: EventId) -> Self {
        Self::from_standardized_without_cell(TagStandard::event(event_id))
    }

    /// Compose `["p", "<public-key>"]` tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn public_key(public_key: PublicKey) -> Self {
        Self::from_standardized_without_cell(TagStandard::public_key(public_key))
    }

    /// Compose `["d", "<identifier>"]` tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn identifier<T>(identifier: T) -> Self
    where
        T: Into<String>,
    {
        Self::from_standardized_without_cell(TagStandard::Identifier(identifier.into()))
    }

    /// Compose `["a", "<coordinate>"]` tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn coordinate(coordinate: Coordinate) -> Self {
        Self::from_standardized_without_cell(TagStandard::Coordinate {
            coordinate,
            relay_url: None,
            uppercase: false,
        })
    }

    /// Compose `["nonce", "<nonce>", "<difficulty>"]` tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/13.md>
    #[inline]
    pub fn pow(nonce: u128, difficulty: u8) -> Self {
        Self::from_standardized_without_cell(TagStandard::POW { nonce, difficulty })
    }

    /// Compose `["expiration", "<timestamp>"]` tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/40.md>
    #[inline]
    pub fn expiration(timestamp: Timestamp) -> Self {
        Self::from_standardized_without_cell(TagStandard::Expiration(timestamp))
    }

    /// Compose `["e", "<event-id>", "<report>"]` tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/56.md>
    #[inline]
    pub fn event_report(event_id: EventId, report: Report) -> Self {
        Self::from_standardized_without_cell(TagStandard::EventReport(event_id, report))
    }

    /// Compose `["p", "<public-key>", "<report>"]` tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/56.md>
    #[inline]
    pub fn public_key_report(public_key: PublicKey, report: Report) -> Self {
        Self::from_standardized_without_cell(TagStandard::PublicKeyReport(public_key, report))
    }

    /// Compose `["r", "<relay-url>", "<metadata>"]` tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/65.md>
    #[inline]
    pub fn relay_metadata(relay_url: RelayUrl, metadata: Option<RelayMetadata>) -> Self {
        Self::from_standardized_without_cell(TagStandard::RelayMetadata {
            relay_url,
            metadata,
        })
    }

    /// Compose `["t", "<hashtag>"]` tag
    #[inline]
    pub fn hashtag<T>(hashtag: T) -> Self
    where
        T: Into<String>,
    {
        Self::from_standardized_without_cell(TagStandard::Hashtag(hashtag.into()))
    }

    /// Compose `["r", "<value>"]` tag
    #[inline]
    pub fn reference<T>(reference: T) -> Self
    where
        T: Into<String>,
    {
        Self::from_standardized_without_cell(TagStandard::Reference(reference.into()))
    }

    /// Compose `["title", "<title>"]` tag
    #[inline]
    pub fn title<T>(title: T) -> Self
    where
        T: Into<String>,
    {
        Self::from_standardized_without_cell(TagStandard::Title(title.into()))
    }

    /// Compose image tag
    #[inline]
    pub fn image(url: Url, dimensions: Option<ImageDimensions>) -> Self {
        Self::from_standardized_without_cell(TagStandard::Image(url, dimensions))
    }

    /// Compose `["description", "<description>"]` tag
    #[inline]
    pub fn description<T>(description: T) -> Self
    where
        T: Into<String>,
    {
        Self::from_standardized_without_cell(TagStandard::Description(description.into()))
    }

    /// Protected event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/70.md>
    #[inline]
    pub fn protected() -> Self {
        Self::from_standardized_without_cell(TagStandard::Protected)
    }

    /// A short human-readable plaintext summary of what that event is about
    ///
    /// JSON: `["alt", "<summary>"]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/31.md>
    #[inline]
    pub fn alt<T>(summary: T) -> Self
    where
        T: Into<String>,
    {
        Self::from_standardized_without_cell(TagStandard::Alt(summary.into()))
    }

    /// Compose custom tag
    ///
    /// JSON: `["<kind>", "<value-1>", "<value-2>", ...]`
    pub fn custom<I, S>(kind: TagKind, values: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        // Compose tag
        let mut buf: Vec<String> = Vec::with_capacity(1);
        buf.push(kind.to_string());
        buf.extend(values.into_iter().map(|v| v.into()));

        // NOT USE `Self::new`!
        Self::new_with_empty_cell(buf)
    }

    /// Check if is a standard event tag with `root` marker
    #[inline]
    pub fn is_root(&self) -> bool {
        matches!(
            self.as_standardized(),
            Some(TagStandard::Event {
                marker: Some(Marker::Root),
                ..
            })
        )
    }

    /// Check if is a standard event tag with `reply` marker
    #[inline]
    pub fn is_reply(&self) -> bool {
        matches!(
            self.as_standardized(),
            Some(TagStandard::Event {
                marker: Some(Marker::Reply),
                ..
            })
        )
    }

    /// Check if it's a protected event tag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/70.md>
    #[inline]
    pub fn is_protected(&self) -> bool {
        matches!(self.as_standardized(), Some(TagStandard::Protected))
    }
}

impl Serialize for Tag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.buf.len()))?;
        for element in self.buf.iter() {
            seq.serialize_element(&element)?;
        }
        seq.end()
    }
}

impl<'de> Deserialize<'de> for Tag {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        type Data = Vec<String>;
        let tag: Data = Data::deserialize(deserializer)?;
        Self::parse(tag).map_err(DeserializerError::custom)
    }
}

impl From<TagStandard> for Tag {
    #[inline(always)]
    fn from(standard: TagStandard) -> Self {
        Self::from_standardized_without_cell(standard)
    }
}

#[cfg(test)]
mod tests {
    use core::str::FromStr;

    use bitcoin::secp256k1::schnorr::Signature;

    use super::*;
    use crate::{Alphabet, Event, JsonUtil, Kind, Timestamp};

    #[test]
    fn test_parse_empty_tag() {
        assert_eq!(
            Tag::parse::<Vec<_>, String>(vec![]).unwrap_err(),
            Error::EmptyTag
        );
    }

    #[test]
    fn test_tag_match_standardized() {
        let tag: Tag = Tag::parse(["d", "bravery"]).unwrap();
        assert_eq!(
            tag.as_standardized(),
            Some(&TagStandard::Identifier(String::from("bravery")))
        );

        let tag: Tag = Tag::parse(["d", "test"]).unwrap();
        assert_eq!(
            tag.to_standardized(),
            Some(TagStandard::Identifier(String::from("test")))
        );
    }

    #[test]
    fn test_extract_tag_content() {
        let t: Tag = Tag::parse(["aaaaaa", "bbbbbb"]).unwrap();
        assert_eq!(t.content(), Some("bbbbbb"));

        // Test extract public key
        let t: Tag = Tag::parse([
            "custom-p",
            "f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785",
        ])
        .unwrap();
        assert_eq!(
            t.content(),
            Some("f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785")
        );

        // Test extract event ID
        let t: Tag = Tag::parse([
            "custom-e",
            "2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45",
        ])
        .unwrap();
        assert_eq!(
            t.content(),
            Some("2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45")
        );
    }

    #[test]
    fn test_deserialize_tag_from_event() {
        // Got this fresh off the wire
        let event: &str = r#"{"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","created_at":1640839235,"kind":4,"tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]],"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd"}"#;
        let event = Event::from_json(event).unwrap();
        let tag = event.tags.first().unwrap();

        assert_eq!(
            tag,
            &Tag::public_key(
                PublicKey::from_hex(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap()
            )
        );
    }

    #[test]
    fn test_serialize_tag_to_event() {
        let public_key =
            PublicKey::from_hex("68d81165918100b7da43fc28f7d1fc12554466e1115886b9e7bb326f65ec4272")
                .unwrap();
        let event = Event::new(
            EventId::from_hex("378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7")
                .unwrap(),
            PublicKey::from_hex("79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3").unwrap(),
            Timestamp::from(1671739153),
            Kind::EncryptedDirectMessage,
            [Tag::public_key(public_key)],
            "8y4MRYrb4ztvXO2NmsHvUA==?iv=MplZo7oSdPfH/vdMC8Hmwg==",
            Signature::from_str("fd0954de564cae9923c2d8ee9ab2bf35bc19757f8e328a978958a2fcc950eaba0754148a203adec29b7b64080d0cf5a32bebedd768ea6eb421a6b751bb4584a8").unwrap()
        );

        let event_json: &str = r#"{"id":"378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7","pubkey":"79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3","created_at":1671739153,"kind":4,"tags":[["p","68d81165918100b7da43fc28f7d1fc12554466e1115886b9e7bb326f65ec4272"]],"content":"8y4MRYrb4ztvXO2NmsHvUA==?iv=MplZo7oSdPfH/vdMC8Hmwg==","sig":"fd0954de564cae9923c2d8ee9ab2bf35bc19757f8e328a978958a2fcc950eaba0754148a203adec29b7b64080d0cf5a32bebedd768ea6eb421a6b751bb4584a8"}"#;

        assert_eq!(&event.as_json(), event_json);
    }

    #[test]
    fn test_tag_custom() {
        assert_eq!(
            vec!["r", "wss://atlas.nostr.land", ""],
            Tag::custom(
                TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::R)),
                ["wss://atlas.nostr.land", ""]
            )
            .to_vec()
        );

        assert_eq!(
            Tag::parse(["r", "wss://atlas.nostr.land", ""]).unwrap(),
            Tag::custom(
                TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::R)),
                ["wss://atlas.nostr.land", ""]
            )
        );

        assert_eq!(
            vec![
                "r",
                "3dbee968d1ddcdf07521e246e405e1fbb549080f1f4ef4e42526c4528f124220",
                ""
            ],
            Tag::custom(
                TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::R)),
                [
                    "3dbee968d1ddcdf07521e246e405e1fbb549080f1f4ef4e42526c4528f124220",
                    ""
                ]
            )
            .to_vec()
        );

        assert_eq!(
            Tag::parse([
                "r",
                "3dbee968d1ddcdf07521e246e405e1fbb549080f1f4ef4e42526c4528f124220",
                ""
            ])
            .unwrap(),
            Tag::custom(
                TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::R)),
                [
                    "3dbee968d1ddcdf07521e246e405e1fbb549080f1f4ef4e42526c4528f124220",
                    ""
                ]
            )
        );

        assert_eq!(
            vec!["client", "rust-nostr"],
            Tag::custom(TagKind::Client, ["rust-nostr"]).to_vec()
        );

        assert_eq!(
            Tag::parse(["client", "nostr-sdk"]).unwrap(),
            Tag::custom(TagKind::Client, ["nostr-sdk"])
        );
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    #[bench]
    pub fn get_tag_kind(bh: &mut Bencher) {
        let tag = Tag::identifier("id");
        bh.iter(|| {
            black_box(tag.kind());
        });
    }

    #[bench]
    pub fn parse_p_tag(bh: &mut Bencher) {
        let tag = &[
            "p",
            "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
        ];
        bh.iter(|| {
            black_box(Tag::parse(tag)).unwrap();
        });
    }

    #[bench]
    pub fn parse_p_standardized_tag(bh: &mut Bencher) {
        let tag = &[
            "p",
            "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
        ];
        bh.iter(|| {
            black_box(TagStandard::parse(tag)).unwrap();
        });
    }

    #[bench]
    pub fn parse_e_tag(bh: &mut Bencher) {
        let tag = &[
            "e",
            "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
            "wss://relay.damus.io",
        ];
        bh.iter(|| {
            black_box(Tag::parse(tag)).unwrap();
        });
    }

    #[bench]
    pub fn parse_e_standardized_tag(bh: &mut Bencher) {
        let tag = &[
            "e",
            "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
            "wss://relay.damus.io",
        ];
        bh.iter(|| {
            black_box(TagStandard::parse(tag)).unwrap();
        });
    }

    #[bench]
    pub fn parse_a_tag(bh: &mut Bencher) {
        let tag = &[
            "a",
            "30023:a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919:ipsum",
            "wss://relay.nostr.org",
        ];
        bh.iter(|| {
            black_box(Tag::parse(tag)).unwrap();
        });
    }

    #[bench]
    pub fn parse_a_standardized_tag(bh: &mut Bencher) {
        let tag = &[
            "a",
            "30023:a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919:ipsum",
            "wss://relay.nostr.org",
        ];
        bh.iter(|| {
            black_box(TagStandard::parse(tag)).unwrap();
        });
    }
}

================
File: src/event/tag/standard.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Standardized tags

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::str::FromStr;

use bitcoin::hashes::sha1::Hash as Sha1Hash;
use bitcoin::hashes::sha256::Hash as Sha256Hash;
use bitcoin::secp256k1::schnorr::Signature;

use super::{Error, TagKind};
use crate::event::id::EventId;
use crate::nips::nip01::Coordinate;
use crate::nips::nip10::Marker;
use crate::nips::nip26::Conditions;
use crate::nips::nip34::EUC;
use crate::nips::nip39::Identity;
use crate::nips::nip48::Protocol;
use crate::nips::nip53::{LiveEventMarker, LiveEventStatus};
use crate::nips::nip56::Report;
use crate::nips::nip65::RelayMetadata;
use crate::nips::nip73::ExternalContentId;
use crate::nips::nip90::DataVendingMachineStatus;
use crate::nips::nip98::HttpMethod;
use crate::types::{RelayUrl, Url};
use crate::{
    Alphabet, Event, ImageDimensions, JsonUtil, Kind, PublicKey, SingleLetterTag, Timestamp,
};

/// Standardized tag
#[allow(missing_docs)]
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TagStandard {
    /// Event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md> and <https://github.com/nostr-protocol/nips/blob/master/10.md>
    Event {
        event_id: EventId,
        relay_url: Option<RelayUrl>,
        marker: Option<Marker>,
        /// Should be the public key of the author of the referenced event
        public_key: Option<PublicKey>,
        /// Whether the tag is an uppercase or not
        uppercase: bool,
    },
    /// Quote
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/18.md>
    Quote {
        event_id: EventId,
        relay_url: Option<RelayUrl>,
        /// Should be the public key of the author of the referenced event
        public_key: Option<PublicKey>,
    },
    /// Report event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/56.md>
    EventReport(EventId, Report),
    /// Git clone ([`TagKind::Clone`] tag)
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/34.md>
    GitClone(Vec<Url>),
    /// Git commit
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/34.md>
    GitCommit(Sha1Hash),
    /// Git earliest unique commit ID
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/34.md>
    GitEarliestUniqueCommitId(String),
    /// Git repo maintainers
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/34.md>
    GitMaintainers(Vec<PublicKey>),
    /// Public Key
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    PublicKey {
        public_key: PublicKey,
        relay_url: Option<RelayUrl>,
        alias: Option<String>,
        /// Whether the tag is an uppercase or not
        uppercase: bool,
    },
    /// Report public key
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/56.md>
    PublicKeyReport(PublicKey, Report),
    PublicKeyLiveEvent {
        public_key: PublicKey,
        relay_url: Option<RelayUrl>,
        marker: LiveEventMarker,
        proof: Option<Signature>,
    },
    Reference(String),
    /// Relay Metadata
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/65.md>
    RelayMetadata {
        relay_url: RelayUrl,
        metadata: Option<RelayMetadata>,
    },
    Hashtag(String),
    Geohash(String),
    Identifier(String),
    /// External Content ID
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/73.md>
    ExternalContent {
        content: ExternalContentId,
        /// Optional URL hint to redirect people to a website if the client isn't opinionated about how to interpret the id.
        hint: Option<Url>,
        /// Whether the tag is an uppercase or not
        uppercase: bool,
    },
    /// External Identity
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/39.md>
    ExternalIdentity(Identity),
    Coordinate {
        coordinate: Coordinate,
        relay_url: Option<RelayUrl>,
        /// Whether the tag is an uppercase or not
        uppercase: bool,
    },
    Kind {
        kind: Kind,
        /// Whether the tag is an uppercase or not
        uppercase: bool,
    },
    Relay(RelayUrl),
    /// Proof of Work
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/13.md>
    POW {
        nonce: u128,
        difficulty: u8,
    },
    Delegation {
        delegator: PublicKey,
        conditions: Conditions,
        sig: Signature,
    },
    ContentWarning {
        reason: Option<String>,
    },
    Expiration(Timestamp),
    Subject(String),
    Challenge(String),
    Title(String),
    Image(Url, Option<ImageDimensions>),
    Thumb(Url, Option<ImageDimensions>),
    Summary(String),
    Description(String),
    Bolt11(String),
    Preimage(String),
    Relays(Vec<Url>),
    Amount {
        millisats: u64,
        bolt11: Option<String>,
    },
    Lnurl(String),
    Name(String),
    PublishedAt(Timestamp),
    Url(Url),
    MimeType(String),
    Aes256Gcm {
        key: String,
        iv: String,
    },
    Sha256(Sha256Hash),
    Size(usize),
    Dim(ImageDimensions),
    Magnet(String),
    Blurhash(String),
    Streaming(Url),
    Recording(Url),
    Starts(Timestamp),
    Ends(Timestamp),
    LiveEventStatus(LiveEventStatus),
    CurrentParticipants(u64),
    TotalParticipants(u64),
    AbsoluteURL(Url),
    Method(HttpMethod),
    Payload(Sha256Hash),
    Anon {
        msg: Option<String>,
    },
    Proxy {
        id: String,
        protocol: Protocol,
    },
    Emoji {
        /// Name given for the emoji, which MUST be comprised of only alphanumeric characters and underscores
        shortcode: String,
        /// URL to the corresponding image file of the emoji
        url: Url,
    },
    Encrypted,
    Request(Event),
    DataVendingMachineStatus {
        status: DataVendingMachineStatus,
        extra_info: Option<String>,
    },
    /// Label namespace
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/32.md>
    LabelNamespace(String),
    /// Label
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/32.md>
    Label(Vec<String>),
    /// Protected event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/70.md>
    Protected,
    /// A short human-readable plaintext summary of what that event is about
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/31.md>
    Alt(String),
    /// List of web URLs
    Web(Vec<Url>),
    Word(String),
}

impl TagStandard {
    /// Parse tag from slice of string
    #[inline]
    pub fn parse<S>(tag: &[S]) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let tag_kind: TagKind = match tag.first() {
            Some(kind) => TagKind::from(kind.as_ref()),
            None => return Err(Error::KindNotFound),
        };

        Self::internal_parse(tag_kind, tag)
    }

    fn internal_parse<S>(tag_kind: TagKind, tag: &[S]) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        match tag_kind {
            TagKind::SingleLetter(single_letter) => match single_letter {
                // Parse `a` tag
                SingleLetterTag {
                    character: Alphabet::A,
                    uppercase: false,
                } => {
                    return parse_a_tag(tag);
                }
                // Parse `e` tag
                SingleLetterTag {
                    character: Alphabet::E,
                    uppercase: false,
                } => {
                    return parse_e_tag(tag);
                }
                // Parse `i` tag
                SingleLetterTag {
                    character: Alphabet::I,
                    uppercase,
                } => {
                    return parse_i_tag(tag, uppercase);
                }
                // Parse `l` tag
                SingleLetterTag {
                    character: Alphabet::L,
                    uppercase: false,
                } => {
                    let labels = tag.iter().skip(1).map(|u| u.as_ref().to_string()).collect();
                    return Ok(Self::Label(labels));
                }
                // Parse `p` tag
                SingleLetterTag {
                    character: Alphabet::P,
                    uppercase,
                } => {
                    return parse_p_tag(tag, uppercase);
                }
                // Parse `r` tag
                SingleLetterTag {
                    character: Alphabet::R,
                    uppercase,
                } => {
                    return parse_r_tag(tag, uppercase);
                }
                // Parse `q` tag
                SingleLetterTag {
                    character: Alphabet::Q,
                    uppercase: false,
                } => {
                    return parse_q_tag(tag);
                }
                _ => (), // Covered later
            },
            TagKind::Anon => {
                return Ok(Self::Anon {
                    msg: extract_optional_string(tag, 1).map(|s| s.to_string()),
                })
            }
            TagKind::Clone => {
                let urls: Vec<Url> = extract_urls(tag)?;
                return Ok(Self::GitClone(urls));
            }
            TagKind::ContentWarning => {
                return Ok(Self::ContentWarning {
                    reason: extract_optional_string(tag, 1).map(|s| s.to_string()),
                })
            }
            TagKind::Delegation => return parse_delegation_tag(tag),
            TagKind::Encrypted => return Ok(Self::Encrypted),
            TagKind::Maintainers => {
                let public_keys: Vec<PublicKey> = extract_public_keys(tag)?;
                return Ok(Self::GitMaintainers(public_keys));
            }
            TagKind::Protected => return Ok(Self::Protected),
            TagKind::Relays => {
                let urls: Vec<Url> = extract_urls(tag)?;
                return Ok(Self::Relays(urls));
            }
            TagKind::Web => {
                let urls: Vec<Url> = extract_urls(tag)?;
                return Ok(Self::Web(urls));
            }
            _ => (), // Covered later
        };

        let tag_len: usize = tag.len();

        if tag_len == 2 {
            let tag_1: &str = tag[1].as_ref();

            return match tag_kind {
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::T,
                    uppercase: false,
                }) => Ok(Self::Hashtag(tag_1.to_string())),
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::G,
                    uppercase: false,
                }) => Ok(Self::Geohash(tag_1.to_string())),
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::D,
                    uppercase: false,
                }) => Ok(Self::Identifier(tag_1.to_string())),
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::M,
                    uppercase: false,
                }) => Ok(Self::MimeType(tag_1.to_string())),
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::X,
                    uppercase: false,
                }) => Ok(Self::Sha256(Sha256Hash::from_str(tag_1)?)),
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::U,
                    uppercase: false,
                }) => Ok(Self::AbsoluteURL(Url::parse(tag_1)?)),
                TagKind::Relay => Ok(Self::Relay(RelayUrl::parse(tag_1)?)),
                TagKind::Expiration => Ok(Self::Expiration(Timestamp::from_str(tag_1)?)),
                TagKind::Subject => Ok(Self::Subject(tag_1.to_string())),
                TagKind::Challenge => Ok(Self::Challenge(tag_1.to_string())),
                TagKind::Commit => Ok(Self::GitCommit(Sha1Hash::from_str(tag_1)?)),
                TagKind::Title => Ok(Self::Title(tag_1.to_string())),
                TagKind::Image => Ok(Self::Image(Url::parse(tag_1)?, None)),
                TagKind::Thumb => Ok(Self::Thumb(Url::parse(tag_1)?, None)),
                TagKind::Summary => Ok(Self::Summary(tag_1.to_string())),
                TagKind::PublishedAt => Ok(Self::PublishedAt(Timestamp::from_str(tag_1)?)),
                TagKind::Description => Ok(Self::Description(tag_1.to_string())),
                TagKind::Bolt11 => Ok(Self::Bolt11(tag_1.to_string())),
                TagKind::Preimage => Ok(Self::Preimage(tag_1.to_string())),
                TagKind::Amount => Ok(Self::Amount {
                    millisats: tag_1.parse()?,
                    bolt11: None,
                }),
                TagKind::Lnurl => Ok(Self::Lnurl(tag_1.to_string())),
                TagKind::Name => Ok(Self::Name(tag_1.to_string())),
                TagKind::Url => Ok(Self::Url(Url::parse(tag_1)?)),
                TagKind::Magnet => Ok(Self::Magnet(tag_1.to_string())),
                TagKind::Blurhash => Ok(Self::Blurhash(tag_1.to_string())),
                TagKind::Streaming => Ok(Self::Streaming(Url::parse(tag_1)?)),
                TagKind::Recording => Ok(Self::Recording(Url::parse(tag_1)?)),
                TagKind::Starts => Ok(Self::Starts(Timestamp::from_str(tag_1)?)),
                TagKind::Ends => Ok(Self::Ends(Timestamp::from_str(tag_1)?)),
                TagKind::Status => match DataVendingMachineStatus::from_str(tag_1) {
                    Ok(status) => Ok(Self::DataVendingMachineStatus {
                        status,
                        extra_info: None,
                    }),
                    Err(_) => Ok(Self::LiveEventStatus(LiveEventStatus::from(tag_1))), /* TODO: check if unknown status error? */
                },
                TagKind::CurrentParticipants => Ok(Self::CurrentParticipants(tag_1.parse()?)),
                TagKind::TotalParticipants => Ok(Self::TotalParticipants(tag_1.parse()?)),
                TagKind::Method => Ok(Self::Method(HttpMethod::from_str(tag_1)?)),
                TagKind::Payload => Ok(Self::Payload(Sha256Hash::from_str(tag_1)?)),
                TagKind::Request => Ok(Self::Request(Event::from_json(tag_1)?)),
                TagKind::Word => Ok(Self::Word(tag_1.to_string())),
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::L,
                    uppercase: true,
                }) => Ok(Self::LabelNamespace(tag_1.to_string())),
                TagKind::Alt => Ok(Self::Alt(tag_1.to_string())),
                TagKind::Dim => Ok(Self::Dim(ImageDimensions::from_str(tag_1)?)),
                _ => Err(Error::UnknownStardardizedTag),
            };
        }

        if tag_len == 3 {
            let tag_1: &str = tag[1].as_ref();
            let tag_2: &str = tag[2].as_ref();

            return match tag_kind {
                TagKind::Nonce => Ok(Self::POW {
                    nonce: tag_1.parse()?,
                    difficulty: tag_2.parse()?,
                }),
                TagKind::Image => Ok(Self::Image(
                    Url::parse(tag_1)?,
                    Some(ImageDimensions::from_str(tag_2)?),
                )),
                TagKind::Thumb => Ok(Self::Thumb(
                    Url::parse(tag_1)?,
                    Some(ImageDimensions::from_str(tag_2)?),
                )),
                TagKind::Aes256Gcm => Ok(Self::Aes256Gcm {
                    key: tag_1.to_string(),
                    iv: tag_2.to_string(),
                }),
                TagKind::Proxy => Ok(Self::Proxy {
                    id: tag_1.to_string(),
                    protocol: Protocol::from(tag_2),
                }),
                TagKind::Emoji => Ok(Self::Emoji {
                    shortcode: tag_1.to_string(),
                    url: Url::parse(tag_2)?,
                }),
                TagKind::Status => match DataVendingMachineStatus::from_str(tag_1) {
                    Ok(status) => Ok(Self::DataVendingMachineStatus {
                        status,
                        extra_info: Some(tag_2.to_string()),
                    }),
                    Err(_) => Err(Error::UnknownStardardizedTag),
                },
                _ => Err(Error::UnknownStardardizedTag),
            };
        }

        Err(Error::UnknownStardardizedTag)
    }

    /// Compose `TagStandard::Event` without `relay_url` and `marker`
    ///
    /// JSON: `["e", "event-id"]`
    #[inline]
    pub fn event(event_id: EventId) -> Self {
        Self::Event {
            event_id,
            relay_url: None,
            marker: None,
            public_key: None,
            uppercase: false,
        }
    }

    /// Compose `TagStandard::PublicKey` without `relay_url` and `alias`
    ///
    /// JSON: `["p", "<public-key>"]`
    #[inline]
    pub fn public_key(public_key: PublicKey) -> Self {
        Self::PublicKey {
            public_key,
            relay_url: None,
            alias: None,
            uppercase: false,
        }
    }

    /// Check if tag is an event `reply`
    #[inline]
    pub fn is_reply(&self) -> bool {
        matches!(
            self,
            Self::Event {
                marker: Some(Marker::Reply),
                ..
            }
        )
    }

    /// Get tag kind
    pub fn kind(&self) -> TagKind {
        match self {
            Self::Event { uppercase, .. } => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::E,
                uppercase: *uppercase,
            }),
            Self::Quote { .. } => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::Q,
                uppercase: false,
            }),
            Self::EventReport(..) => TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::E)),
            Self::GitClone(..) => TagKind::Clone,
            Self::GitCommit(..) => TagKind::Commit,
            Self::GitEarliestUniqueCommitId(..) => {
                TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::R))
            }
            Self::GitMaintainers(..) => TagKind::Maintainers,
            Self::PublicKey { uppercase, .. } => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::P,
                uppercase: *uppercase,
            }),
            Self::PublicKeyReport(..) | Self::PublicKeyLiveEvent { .. } => {
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::P,
                    uppercase: false,
                })
            }
            Self::Reference(..) | Self::RelayMetadata { .. } => {
                TagKind::SingleLetter(SingleLetterTag {
                    character: Alphabet::R,
                    uppercase: false,
                })
            }
            Self::Hashtag(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::T,
                uppercase: false,
            }),
            Self::Geohash(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::G,
                uppercase: false,
            }),
            Self::Identifier(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::D,
                uppercase: false,
            }),
            Self::ExternalContent { uppercase, .. } => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::I,
                uppercase: *uppercase,
            }),
            Self::ExternalIdentity(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::I,
                uppercase: false,
            }),
            Self::Coordinate { uppercase, .. } => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::A,
                uppercase: *uppercase,
            }),
            Self::Kind { uppercase, .. } => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::K,
                uppercase: *uppercase,
            }),
            Self::Relay(..) => TagKind::Relay,
            Self::POW { .. } => TagKind::Nonce,
            Self::Delegation { .. } => TagKind::Delegation,
            Self::ContentWarning { .. } => TagKind::ContentWarning,
            Self::Expiration(..) => TagKind::Expiration,
            Self::Subject(..) => TagKind::Subject,
            Self::Challenge(..) => TagKind::Challenge,
            Self::Title(..) => TagKind::Title,
            Self::Image(..) => TagKind::Image,
            Self::Thumb(..) => TagKind::Thumb,
            Self::Summary(..) => TagKind::Summary,
            Self::PublishedAt(..) => TagKind::PublishedAt,
            Self::Description(..) => TagKind::Description,
            Self::Bolt11(..) => TagKind::Bolt11,
            Self::Preimage(..) => TagKind::Preimage,
            Self::Relays(..) => TagKind::Relays,
            Self::Amount { .. } => TagKind::Amount,
            Self::Name(..) => TagKind::Name,
            Self::Lnurl(..) => TagKind::Lnurl,
            Self::Url(..) => TagKind::Url,
            Self::MimeType(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::M,
                uppercase: false,
            }),
            Self::Aes256Gcm { .. } => TagKind::Aes256Gcm,
            Self::Sha256(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::X,
                uppercase: false,
            }),
            Self::Size(..) => TagKind::Size,
            Self::Dim(..) => TagKind::Dim,
            Self::Magnet(..) => TagKind::Magnet,
            Self::Blurhash(..) => TagKind::Blurhash,
            Self::Streaming(..) => TagKind::Streaming,
            Self::Recording(..) => TagKind::Recording,
            Self::Starts(..) => TagKind::Starts,
            Self::Ends(..) => TagKind::Ends,
            Self::LiveEventStatus(..) | Self::DataVendingMachineStatus { .. } => TagKind::Status,
            Self::CurrentParticipants(..) => TagKind::CurrentParticipants,
            Self::TotalParticipants(..) => TagKind::TotalParticipants,
            Self::AbsoluteURL(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::U,
                uppercase: false,
            }),
            Self::Method(..) => TagKind::Method,
            Self::Payload(..) => TagKind::Payload,
            Self::Anon { .. } => TagKind::Anon,
            Self::Proxy { .. } => TagKind::Proxy,
            Self::Emoji { .. } => TagKind::Emoji,
            Self::Encrypted => TagKind::Encrypted,
            Self::Request(..) => TagKind::Request,
            Self::Word(..) => TagKind::Word,
            Self::LabelNamespace(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::L,
                uppercase: true,
            }),
            Self::Label(..) => TagKind::SingleLetter(SingleLetterTag {
                character: Alphabet::L,
                uppercase: false,
            }),
            Self::Protected => TagKind::Protected,
            Self::Alt(..) => TagKind::Alt,
            Self::Web(..) => TagKind::Web,
        }
    }

    /// Consume tag and return string vector
    #[inline]
    pub fn to_vec(self) -> Vec<String> {
        self.into()
    }
}

impl From<TagStandard> for Vec<String> {
    fn from(standard: TagStandard) -> Self {
        let tag_kind: String = standard.kind().to_string();
        let tag: Vec<String> = match standard {
            TagStandard::Event {
                event_id,
                relay_url,
                marker,
                public_key,
                ..
            } => {
                // ["e", <event-id>, <relay-url>, <marker>, <pubkey>]
                // <relay-url>, <marker> and <pubkey> are optional
                // <relay-url>, if empty, may be set to "" (if there are additional fields later)
                // <marker> is optional and if present is one of "reply", "root", or "mention" (so not an empty string)

                let mut tag: Vec<String> = vec![tag_kind, event_id.to_hex()];

                // Check if <relay-url> exists or if there are additional fields after
                match (relay_url, marker.is_some() || public_key.is_some()) {
                    (Some(relay_url), ..) => tag.push(relay_url.to_string()),
                    (None, true) => tag.push(String::new()),
                    (None, false) => {}
                }

                if let Some(marker) = marker {
                    tag.push(marker.to_string());
                }

                if let Some(public_key) = public_key {
                    tag.push(public_key.to_string());
                }

                tag
            }
            TagStandard::Quote {
                event_id,
                relay_url,
                public_key,
            } => {
                let mut tag = vec![tag_kind, event_id.to_hex()];
                if let Some(relay_url) = relay_url {
                    tag.push(relay_url.to_string());
                }
                if let Some(public_key) = public_key {
                    // If <relay-url> is `None`, push an empty string
                    tag.resize_with(3, String::new);
                    tag.push(public_key.to_hex());
                }
                tag
            }
            TagStandard::PublicKey {
                public_key,
                relay_url,
                alias,
                ..
            } => {
                let mut tag = vec![tag_kind, public_key.to_string()];
                if let Some(relay_url) = relay_url {
                    tag.push(relay_url.to_string());
                }
                if let Some(alias) = alias {
                    tag.resize_with(3, String::new);
                    tag.push(alias);
                }
                tag
            }
            TagStandard::EventReport(id, report) => {
                vec![tag_kind, id.to_hex(), report.to_string()]
            }
            TagStandard::GitClone(urls) => {
                let mut tag: Vec<String> = Vec::with_capacity(1 + urls.len());
                tag.push(tag_kind);
                tag.extend(urls.into_iter().map(|url| url.to_string()));
                tag
            }
            TagStandard::GitCommit(hash) => {
                vec![tag_kind, hash.to_string()]
            }
            TagStandard::GitEarliestUniqueCommitId(id) => {
                vec![tag_kind, id, EUC.to_string()]
            }
            TagStandard::GitMaintainers(public_keys) => {
                let mut tag: Vec<String> = Vec::with_capacity(1 + public_keys.len());
                tag.push(tag_kind);
                tag.extend(public_keys.into_iter().map(|val| val.to_string()));
                tag
            }
            TagStandard::PublicKeyReport(pk, report) => {
                vec![tag_kind, pk.to_string(), report.to_string()]
            }
            TagStandard::PublicKeyLiveEvent {
                public_key,
                relay_url,
                marker,
                proof,
            } => {
                let mut tag = vec![
                    tag_kind,
                    public_key.to_string(),
                    relay_url.map(|u| u.to_string()).unwrap_or_default(),
                    marker.to_string(),
                ];
                if let Some(proof) = proof {
                    tag.push(proof.to_string());
                }
                tag
            }
            TagStandard::Reference(r) => vec![tag_kind, r],
            TagStandard::RelayMetadata {
                relay_url,
                metadata,
            } => {
                let mut tag = vec![tag_kind, relay_url.to_string()];
                if let Some(metadata) = metadata {
                    tag.push(metadata.to_string());
                }
                tag
            }
            TagStandard::Hashtag(t) => vec![tag_kind, t],
            TagStandard::Geohash(g) => vec![tag_kind, g],
            TagStandard::Identifier(d) => vec![tag_kind, d],
            TagStandard::Coordinate {
                coordinate,
                relay_url,
                ..
            } => {
                let mut vec = vec![tag_kind, coordinate.to_string()];
                if let Some(relay) = relay_url {
                    vec.push(relay.to_string());
                }
                vec
            }
            TagStandard::ExternalContent { content, hint, .. } => {
                let mut tag = vec![tag_kind, content.to_string()];

                if let Some(hint) = hint {
                    tag.push(hint.to_string());
                }

                tag
            }
            TagStandard::ExternalIdentity(identity) => {
                vec![tag_kind, identity.tag_platform_identity(), identity.proof]
            }
            TagStandard::Kind { kind, .. } => vec![tag_kind, kind.to_string()],
            TagStandard::Relay(url) => vec![tag_kind, url.to_string()],
            TagStandard::POW { nonce, difficulty } => {
                vec![tag_kind, nonce.to_string(), difficulty.to_string()]
            }
            TagStandard::Delegation {
                delegator,
                conditions,
                sig,
            } => vec![
                tag_kind,
                delegator.to_string(),
                conditions.to_string(),
                sig.to_string(),
            ],
            TagStandard::ContentWarning { reason } => {
                let mut tag = vec![tag_kind];
                if let Some(reason) = reason {
                    tag.push(reason);
                }
                tag
            }
            TagStandard::Expiration(timestamp) => {
                vec![tag_kind, timestamp.to_string()]
            }
            TagStandard::Subject(sub) => vec![tag_kind, sub],
            TagStandard::Challenge(challenge) => vec![tag_kind, challenge],
            TagStandard::Title(title) => vec![tag_kind, title],
            TagStandard::Image(image, dimensions) => {
                let mut tag = vec![tag_kind, image.to_string()];
                if let Some(dim) = dimensions {
                    tag.push(dim.to_string());
                }
                tag
            }
            TagStandard::Thumb(thumb, dimensions) => {
                let mut tag = vec![tag_kind, thumb.to_string()];
                if let Some(dim) = dimensions {
                    tag.push(dim.to_string());
                }
                tag
            }
            TagStandard::Summary(summary) => vec![tag_kind, summary],
            TagStandard::PublishedAt(timestamp) => {
                vec![tag_kind, timestamp.to_string()]
            }
            TagStandard::Description(description) => {
                vec![tag_kind, description]
            }
            TagStandard::Bolt11(bolt11) => {
                vec![tag_kind, bolt11]
            }
            TagStandard::Preimage(preimage) => {
                vec![tag_kind, preimage]
            }
            TagStandard::Relays(relays) => vec![tag_kind]
                .into_iter()
                .chain(relays.iter().map(|relay| relay.to_string()))
                .collect::<Vec<_>>(),
            TagStandard::Amount { millisats, bolt11 } => {
                let mut tag = vec![tag_kind, millisats.to_string()];
                if let Some(bolt11) = bolt11 {
                    tag.push(bolt11);
                }
                tag
            }
            TagStandard::Name(name) => {
                vec![tag_kind, name]
            }
            TagStandard::Lnurl(lnurl) => {
                vec![tag_kind, lnurl]
            }
            TagStandard::Url(url) => vec![tag_kind, url.to_string()],
            TagStandard::MimeType(mime) => vec![tag_kind, mime],
            TagStandard::Aes256Gcm { key, iv } => vec![tag_kind, key, iv],
            TagStandard::Sha256(hash) => vec![tag_kind, hash.to_string()],
            TagStandard::Size(bytes) => vec![tag_kind, bytes.to_string()],
            TagStandard::Dim(dim) => vec![tag_kind, dim.to_string()],
            TagStandard::Magnet(uri) => vec![tag_kind, uri],
            TagStandard::Blurhash(data) => vec![tag_kind, data],
            TagStandard::Streaming(url) => vec![tag_kind, url.to_string()],
            TagStandard::Recording(url) => vec![tag_kind, url.to_string()],
            TagStandard::Starts(timestamp) => {
                vec![tag_kind, timestamp.to_string()]
            }
            TagStandard::Ends(timestamp) => {
                vec![tag_kind, timestamp.to_string()]
            }
            TagStandard::LiveEventStatus(s) => {
                vec![tag_kind, s.to_string()]
            }
            TagStandard::CurrentParticipants(num) => {
                vec![tag_kind, num.to_string()]
            }
            TagStandard::TotalParticipants(num) => {
                vec![tag_kind, num.to_string()]
            }
            TagStandard::AbsoluteURL(url) => {
                vec![tag_kind, url.to_string()]
            }
            TagStandard::Method(method) => {
                vec![tag_kind, method.to_string()]
            }
            TagStandard::Payload(p) => vec![tag_kind, p.to_string()],
            TagStandard::Anon { msg } => {
                let mut tag = vec![tag_kind];
                if let Some(msg) = msg {
                    tag.push(msg);
                }
                tag
            }
            TagStandard::Proxy { id, protocol } => {
                vec![tag_kind, id, protocol.to_string()]
            }
            TagStandard::Emoji { shortcode, url } => {
                vec![tag_kind, shortcode, url.to_string()]
            }
            TagStandard::Encrypted => vec![tag_kind],
            TagStandard::Request(event) => vec![tag_kind, event.as_json()],
            TagStandard::DataVendingMachineStatus { status, extra_info } => {
                let mut tag = vec![tag_kind, status.to_string()];
                if let Some(extra_info) = extra_info {
                    tag.push(extra_info);
                }
                tag
            }
            TagStandard::Word(word) => vec![tag_kind, word],
            TagStandard::LabelNamespace(n) => vec![tag_kind, n],
            TagStandard::Label(l) => {
                let mut tag: Vec<String> = Vec::with_capacity(1 + l.len());
                tag.push(tag_kind);
                tag.extend(l);
                tag
            }
            TagStandard::Protected => vec![tag_kind],
            TagStandard::Alt(summary) => vec![tag_kind, summary],
            TagStandard::Web(urls) => {
                let mut tag: Vec<String> = Vec::with_capacity(1 + urls.len());
                tag.push(tag_kind);
                tag.extend(urls.into_iter().map(|url| url.to_string()));
                tag
            }
        };

        // Tag can't be empty, require at least 1 value
        assert!(!tag.is_empty(), "Empty tag");

        tag
    }
}

fn parse_a_tag<S>(tag: &[S]) -> Result<TagStandard, Error>
where
    S: AsRef<str>,
{
    if tag.len() >= 2 {
        Ok(TagStandard::Coordinate {
            coordinate: Coordinate::from_str(tag[1].as_ref())?,
            relay_url: match tag.get(2).map(|u| u.as_ref()) {
                Some(url) if !url.is_empty() => Some(RelayUrl::parse(url)?),
                _ => None,
            },
            uppercase: false,
        })
    } else {
        Err(Error::UnknownStardardizedTag)
    }
}

fn parse_e_tag<S>(tag: &[S]) -> Result<TagStandard, Error>
where
    S: AsRef<str>,
{
    if tag.len() < 2 {
        return Err(Error::UnknownStardardizedTag);
    }

    let event_id: EventId = EventId::from_hex(tag[1].as_ref())?;

    let tag_2: Option<&str> = tag.get(2).map(|r| r.as_ref());
    let tag_3: Option<&str> = tag.get(3).map(|r| r.as_ref());
    let tag_4: Option<&str> = tag.get(4).map(|r| r.as_ref());

    // Check if it's a report
    if let Some(tag_2) = tag_2 {
        return match Report::from_str(tag_2) {
            Ok(report) => Ok(TagStandard::EventReport(event_id, report)),
            Err(_) => {
                // Check if 3rd arg is a marker or a public key
                let (marker, public_key) = match (tag_3, tag_4) {
                    (Some(marker), Some(public_key)) => {
                        let marker = if marker.is_empty() {
                            None
                        } else {
                            Some(Marker::from_str(marker)?)
                        };
                        let public_key = PublicKey::from_hex(public_key)?;
                        (marker, Some(public_key))
                    }
                    (Some(marker), None) => {
                        if marker.is_empty() {
                            (None, None)
                        } else {
                            match Marker::from_str(marker) {
                                Ok(marker) => (Some(marker), None),
                                Err(..) => {
                                    let public_key = PublicKey::from_hex(marker)?;
                                    (None, Some(public_key))
                                }
                            }
                        }
                    }
                    (None, Some(public_key)) => {
                        let public_key = PublicKey::from_hex(public_key)?;
                        (None, Some(public_key))
                    }
                    (None, None) => (None, None),
                };

                Ok(TagStandard::Event {
                    event_id,
                    relay_url: if !tag_2.is_empty() {
                        Some(RelayUrl::parse(tag_2)?)
                    } else {
                        None
                    },
                    marker,
                    public_key,
                    uppercase: false,
                })
            }
        };
    }

    Ok(TagStandard::event(event_id))
}

fn parse_i_tag<S>(tag: &[S], uppercase: bool) -> Result<TagStandard, Error>
where
    S: AsRef<str>,
{
    // External Content ID (NIP73) has min 2 values
    // External Identity (NI39) has min 3 values
    if tag.len() < 2 {
        return Err(Error::UnknownStardardizedTag);
    }

    let tag_1: &str = tag[1].as_ref();
    let tag_2: Option<&str> = tag.get(2).map(|t| t.as_ref());

    // Check if External Identity (NIP39)
    if !uppercase {
        if let Some(tag_2) = tag_2 {
            if let Ok(identity) = Identity::new(tag_1, tag_2) {
                return Ok(TagStandard::ExternalIdentity(identity));
            }
        }
    }

    // Check if External Content ID (NIP73)
    if let Ok(content) = ExternalContentId::from_str(tag_1) {
        return Ok(TagStandard::ExternalContent {
            content,
            hint: match tag_2 {
                Some(url) => Some(Url::parse(url)?),
                None => None,
            },
            uppercase,
        });
    }

    Err(Error::UnknownStardardizedTag)
}

fn parse_p_tag<S>(tag: &[S], uppercase: bool) -> Result<TagStandard, Error>
where
    S: AsRef<str>,
{
    if tag.len() >= 2 {
        let public_key: PublicKey = PublicKey::from_hex(tag[1].as_ref())?;

        if tag.len() >= 5 && !uppercase {
            let tag_2: &str = tag[2].as_ref();
            let tag_3: &str = tag[3].as_ref();
            let tag_4: &str = tag[4].as_ref();

            return Ok(TagStandard::PublicKeyLiveEvent {
                public_key,
                relay_url: if !tag_2.is_empty() {
                    Some(RelayUrl::parse(tag_2)?)
                } else {
                    None
                },
                marker: LiveEventMarker::from_str(tag_3)?,
                proof: Signature::from_str(tag_4).ok(),
            });
        }

        if tag.len() >= 4 && !uppercase {
            let tag_2: &str = tag[2].as_ref();
            let tag_3: &str = tag[3].as_ref();

            let relay_url: Option<RelayUrl> = if !tag_2.is_empty() {
                Some(RelayUrl::parse(tag_2)?)
            } else {
                None
            };

            return match LiveEventMarker::from_str(tag_3) {
                Ok(marker) => Ok(TagStandard::PublicKeyLiveEvent {
                    public_key,
                    relay_url,
                    marker,
                    proof: None,
                }),
                Err(_) => Ok(TagStandard::PublicKey {
                    public_key,
                    relay_url,
                    alias: (!tag_3.is_empty()).then_some(tag_3.to_string()),
                    uppercase,
                }),
            };
        }

        if tag.len() >= 3 && !uppercase {
            let tag_2: &str = tag[2].as_ref();

            return if tag_2.is_empty() {
                Ok(TagStandard::PublicKey {
                    public_key,
                    relay_url: None,
                    alias: None,
                    uppercase,
                })
            } else {
                match Report::from_str(tag_2) {
                    Ok(report) => Ok(TagStandard::PublicKeyReport(public_key, report)),
                    Err(_) => Ok(TagStandard::PublicKey {
                        public_key,
                        relay_url: Some(RelayUrl::parse(tag_2)?),
                        alias: None,
                        uppercase,
                    }),
                }
            };
        }

        Ok(TagStandard::PublicKey {
            public_key,
            relay_url: None,
            alias: None,
            uppercase,
        })
    } else {
        Err(Error::UnknownStardardizedTag)
    }
}

fn parse_r_tag<S>(tag: &[S], uppercase: bool) -> Result<TagStandard, Error>
where
    S: AsRef<str>,
{
    if tag.len() >= 3 && !uppercase {
        let tag_1: &str = tag[1].as_ref();
        let tag_2: &str = tag[2].as_ref();

        return if tag_1.starts_with("ws://") || tag_1.starts_with("wss://") {
            Ok(TagStandard::RelayMetadata {
                relay_url: RelayUrl::parse(tag_1)?,
                metadata: Some(RelayMetadata::from_str(tag_2)?),
            })
        } else if tag_2 == EUC {
            Ok(TagStandard::GitEarliestUniqueCommitId(tag_1.to_string()))
        } else {
            Err(Error::UnknownStardardizedTag)
        };
    }

    if tag.len() >= 2 && !uppercase {
        let tag_1: &str = tag[1].as_ref();

        return if tag_1.starts_with("ws://") || tag_1.starts_with("wss://") {
            Ok(TagStandard::RelayMetadata {
                relay_url: RelayUrl::parse(tag_1)?,
                metadata: None,
            })
        } else {
            Ok(TagStandard::Reference(tag_1.to_string()))
        };
    }

    Err(Error::UnknownStardardizedTag)
}

fn parse_q_tag<S>(tag: &[S]) -> Result<TagStandard, Error>
where
    S: AsRef<str>,
{
    if tag.len() < 2 {
        return Err(Error::UnknownStardardizedTag);
    }

    let event_id: EventId = EventId::from_hex(tag[1].as_ref())?;

    let tag_2: Option<&str> = tag.get(2).map(|r| r.as_ref());
    let tag_3: Option<&str> = tag.get(3).map(|r| r.as_ref());

    let relay_url: Option<RelayUrl> = match tag_2 {
        Some(url) if !url.is_empty() => Some(RelayUrl::parse(url)?),
        _ => None,
    };

    let public_key: Option<PublicKey> = match tag_3 {
        Some(public_key) => Some(PublicKey::from_hex(public_key)?),
        None => None,
    };

    Ok(TagStandard::Quote {
        event_id,
        relay_url,
        public_key,
    })
}

fn parse_delegation_tag<S>(tag: &[S]) -> Result<TagStandard, Error>
where
    S: AsRef<str>,
{
    if tag.len() == 4 {
        let tag_1: &str = tag[1].as_ref();
        let tag_2: &str = tag[2].as_ref();
        let tag_3: &str = tag[3].as_ref();

        Ok(TagStandard::Delegation {
            delegator: PublicKey::from_hex(tag_1)?,
            conditions: Conditions::from_str(tag_2)?,
            sig: Signature::from_str(tag_3)?,
        })
    } else {
        Err(Error::UnknownStardardizedTag)
    }
}

#[inline]
fn extract_optional_string<S>(tag: &[S], index: usize) -> Option<&str>
where
    S: AsRef<str>,
{
    match tag.get(index).map(|t| t.as_ref()) {
        Some(t) => (!t.is_empty()).then_some(t),
        None => None,
    }
}

fn extract_urls<S>(tag: &[S]) -> Result<Vec<Url>, Error>
where
    S: AsRef<str>,
{
    // Skip index 0 because is the tag kind
    let mut list: Vec<Url> = Vec::with_capacity(tag.len().saturating_sub(1));
    for url in tag.iter().skip(1) {
        list.push(Url::parse(url.as_ref())?);
    }
    Ok(list)
}

fn extract_public_keys<S>(tag: &[S]) -> Result<Vec<PublicKey>, Error>
where
    S: AsRef<str>,
{
    // Skip index 0 because is the tag kind
    let mut list: Vec<PublicKey> = Vec::with_capacity(tag.len().saturating_sub(1));
    for url in tag.iter().skip(1) {
        list.push(PublicKey::parse(url.as_ref())?);
    }
    Ok(list)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::nips::nip39::ExternalIdentity;

    #[test]
    fn test_tag_standard_is_reply() {
        let tag = TagStandard::Relay(RelayUrl::parse("wss://relay.damus.io").unwrap());
        assert!(!tag.is_reply());

        let tag = TagStandard::Event {
            event_id: EventId::from_hex(
                "2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45",
            )
            .unwrap(),
            relay_url: None,
            marker: Some(Marker::Reply),
            public_key: None,
            uppercase: false,
        };
        assert!(tag.is_reply());

        let tag = TagStandard::Event {
            event_id: EventId::from_hex(
                "2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45",
            )
            .unwrap(),
            relay_url: None,
            marker: Some(Marker::Root),
            public_key: None,
            uppercase: false,
        };
        assert!(!tag.is_reply());
    }

    #[test]
    fn test_tag_standard_serialization() {
        assert_eq!(vec!["-"], TagStandard::Protected.to_vec());

        assert_eq!(
            vec!["alt", "something"],
            TagStandard::Alt(String::from("something")).to_vec()
        );

        assert_eq!(
            vec!["content-warning"],
            TagStandard::ContentWarning { reason: None }.to_vec()
        );

        assert_eq!(
            vec![
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ],
            TagStandard::public_key(
                PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap()
            )
            .to_vec()
        );

        assert_eq!(
            vec![
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
            ],
            TagStandard::event(
                EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap()
            )
            .to_vec()
        );

        assert_eq!(
            vec![
                "q",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
            ],
            TagStandard::Quote {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                public_key: None,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "q",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "wss://relay.damus.io"
            ],
            TagStandard::Quote {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                public_key: None,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "q",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ],
            TagStandard::Quote {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                public_key: Some(
                    PublicKey::from_str(
                        "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                    )
                    .unwrap()
                ),
            }
            .to_vec()
        );

        assert_eq!(
            vec!["expiration", "1600000000"],
            TagStandard::Expiration(Timestamp::from(1600000000)).to_vec()
        );

        assert_eq!(
            vec!["content-warning", "reason"],
            TagStandard::ContentWarning {
                reason: Some(String::from("reason"))
            }
            .to_vec()
        );

        assert_eq!(
            vec!["subject", "textnote with subject"],
            TagStandard::Subject(String::from("textnote with subject")).to_vec()
        );

        assert_eq!(
            vec!["d", "test"],
            TagStandard::Identifier(String::from("test")).to_vec()
        );

        assert_eq!(
            vec![
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "wss://relay.damus.io"
            ],
            TagStandard::PublicKey {
                public_key: PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                alias: None,
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
            ],
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                marker: None,
                public_key: None,
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "wss://relay.damus.io"
            ],
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                marker: None,
                public_key: None,
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "spam"
            ],
            TagStandard::PublicKeyReport(
                PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                Report::Spam
            )
            .to_vec()
        );

        assert_eq!(
            vec![
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "nudity"
            ],
            TagStandard::EventReport(
                EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                Report::Nudity,
            )
            .to_vec()
        );

        assert_eq!(
            vec!["nonce", "1", "20"],
            TagStandard::POW {
                nonce: 1,
                difficulty: 20
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "a",
                "30023:a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919:ipsum"
            ],
            TagStandard::Coordinate {
                coordinate: Coordinate::new(
                    Kind::LongFormTextNote,
                    PublicKey::from_str(
                        "a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919"
                    )
                    .unwrap()
                )
                .identifier("ipsum"),
                relay_url: None,
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "a",
                "30023:a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919:ipsum",
                "wss://relay.nostr.org"
            ],
            TagStandard::Coordinate {
                coordinate: Coordinate::new(
                    Kind::LongFormTextNote,
                    PublicKey::from_str(
                        "a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919"
                    )
                    .unwrap()
                )
                .identifier("ipsum"),
                relay_url: Some(RelayUrl::parse("wss://relay.nostr.org").unwrap()),
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "wss://relay.damus.io",
                "Speaker",
            ],
            TagStandard::PublicKeyLiveEvent {
                public_key: PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                marker: LiveEventMarker::Speaker,
                proof: None
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "",
                "Participant",
            ],
            TagStandard::PublicKeyLiveEvent {
                public_key: PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                relay_url: None,
                marker: LiveEventMarker::Participant,
                proof: None
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "wss://relay.damus.io",
                "alias",
            ],
            TagStandard::PublicKey {
                public_key: PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                alias: Some(String::from("alias")),
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "",
                "reply"
            ],
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                marker: Some(Marker::Reply),
                public_key: None,
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "e",
                "0000000000000000000000000000000000000000000000000000000000000001",
                "",
                "root",
                "0000000000000000000000000000000000000000000000000000000000000001",
            ],
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "0000000000000000000000000000000000000000000000000000000000000001"
                )
                .unwrap(),
                relay_url: None,
                marker: Some(Marker::Root),
                public_key: Some(
                    PublicKey::parse(
                        "0000000000000000000000000000000000000000000000000000000000000001"
                    )
                    .unwrap()
                ),
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "e",
                "0000000000000000000000000000000000000000000000000000000000000001",
                "",
                "0000000000000000000000000000000000000000000000000000000000000001",
            ],
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "0000000000000000000000000000000000000000000000000000000000000001"
                )
                .unwrap(),
                relay_url: None,
                marker: None,
                public_key: Some(
                    PublicKey::parse(
                        "0000000000000000000000000000000000000000000000000000000000000001"
                    )
                    .unwrap()
                ),
                uppercase: false,
            }
            .to_vec()
        );

        assert_eq!(
            vec![
                "delegation",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "kind=1",
                "fd0954de564cae9923c2d8ee9ab2bf35bc19757f8e328a978958a2fcc950eaba0754148a203adec29b7b64080d0cf5a32bebedd768ea6eb421a6b751bb4584a8",
            ],
            TagStandard::Delegation {
                delegator: PublicKey::from_str(
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ).unwrap(), conditions: Conditions::from_str("kind=1").unwrap(), sig: Signature::from_str("fd0954de564cae9923c2d8ee9ab2bf35bc19757f8e328a978958a2fcc950eaba0754148a203adec29b7b64080d0cf5a32bebedd768ea6eb421a6b751bb4584a8").unwrap() }.to_vec()
        );

        assert_eq!(
            vec!["lnurl", "lnurl1dp68gurn8ghj7um5v93kketj9ehx2amn9uh8wetvdskkkmn0wahz7mrww4excup0dajx2mrv92x9xp"],
            TagStandard::Lnurl(String::from("lnurl1dp68gurn8ghj7um5v93kketj9ehx2amn9uh8wetvdskkkmn0wahz7mrww4excup0dajx2mrv92x9xp")).to_vec(),
        );

        assert_eq!(
            vec![
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "wss://relay.damus.io",
                "Host",
                "a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd"
            ],
            TagStandard::PublicKeyLiveEvent {
                public_key: PublicKey::from_hex(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                ).unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                marker: LiveEventMarker::Host,
                proof: Some(Signature::from_str("a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd").unwrap())
            }.to_vec()
        );

        assert_eq!(
            vec!["L", "#t"],
            TagStandard::LabelNamespace("#t".to_string()).to_vec()
        );

        assert_eq!(
            vec!["l", "IT-MI"],
            TagStandard::Label(vec!["IT-MI".to_string()]).to_vec()
        );

        assert_eq!(
            vec!["l", "IT-MI", "ISO-3166-2"],
            TagStandard::Label(vec!["IT-MI".to_string(), "ISO-3166-2".to_string()]).to_vec()
        );

        assert_eq!(
            vec!["r", "wss://atlas.nostr.land/"],
            TagStandard::RelayMetadata {
                relay_url: RelayUrl::parse("wss://atlas.nostr.land/").unwrap(),
                metadata: None
            }
            .to_vec()
        );

        assert_eq!(
            vec!["r", "wss://atlas.nostr.land/", "read"],
            TagStandard::RelayMetadata {
                relay_url: RelayUrl::parse("wss://atlas.nostr.land/").unwrap(),
                metadata: Some(RelayMetadata::Read)
            }
            .to_vec()
        );

        assert_eq!(
            vec!["r", "wss://atlas.nostr.land", "write"],
            TagStandard::RelayMetadata {
                relay_url: RelayUrl::parse("wss://atlas.nostr.land").unwrap(),
                metadata: Some(RelayMetadata::Write)
            }
            .to_vec()
        );

        assert_eq!(
            vec!["r", "5e664e5a7845cd1373c79f580ca4fe29ab5b34d2", "euc"],
            TagStandard::GitEarliestUniqueCommitId(String::from(
                "5e664e5a7845cd1373c79f580ca4fe29ab5b34d2"
            ))
            .to_vec()
        );

        assert_eq!(
            vec!["clone", "https://github.com/rust-nostr/nostr.git",],
            TagStandard::GitClone(vec![
                Url::parse("https://github.com/rust-nostr/nostr.git").unwrap()
            ])
            .to_vec()
        );

        assert_eq!(
            vec![
                "maintainers",
                "32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ],
            TagStandard::GitMaintainers(vec![
                PublicKey::from_hex(
                    "32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245"
                )
                .unwrap(),
                PublicKey::from_hex(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
            ])
            .to_vec()
        );

        assert_eq!(
            vec![
                "web",
                "https://rust-nostr.org/",
                "https://github.com/rust-nostr",
            ],
            TagStandard::Web(vec![
                Url::parse("https://rust-nostr.org").unwrap(),
                Url::parse("https://github.com/rust-nostr").unwrap(),
            ])
            .to_vec()
        );
    }

    #[test]
    fn test_tag_standard_parsing() {
        assert_eq!(TagStandard::parse(&["-"]).unwrap(), TagStandard::Protected);

        assert_eq!(
            TagStandard::parse(&["alt", "something"]).unwrap(),
            TagStandard::Alt(String::from("something"))
        );

        assert_eq!(
            TagStandard::parse(&["content-warning"]).unwrap(),
            TagStandard::ContentWarning { reason: None }
        );

        assert_eq!(
            TagStandard::parse(&[
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ])
            .unwrap(),
            TagStandard::public_key(
                PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap()
            )
        );

        assert_eq!(
            TagStandard::parse(&[
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
            ])
            .unwrap(),
            TagStandard::event(
                EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap()
            )
        );

        assert_eq!(
            TagStandard::parse(&[
                "q",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
            ])
            .unwrap(),
            TagStandard::Quote {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                public_key: None,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "q",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "wss://relay.damus.io"
            ])
            .unwrap(),
            TagStandard::Quote {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                public_key: None,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "q",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ])
            .unwrap(),
            TagStandard::Quote {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                public_key: Some(
                    PublicKey::from_hex(
                        "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                    )
                    .unwrap()
                ),
            }
        );

        assert_eq!(
            TagStandard::parse(&["expiration", "1600000000"]).unwrap(),
            TagStandard::Expiration(Timestamp::from(1600000000))
        );

        assert_eq!(
            TagStandard::parse(&["content-warning", "reason"]).unwrap(),
            TagStandard::ContentWarning {
                reason: Some(String::from("reason"))
            }
        );

        assert_eq!(
            TagStandard::parse(&["subject", "textnote with subject"]).unwrap(),
            TagStandard::Subject(String::from("textnote with subject"))
        );

        assert_eq!(
            TagStandard::parse(&["d", "test"]).unwrap(),
            TagStandard::Identifier(String::from("test"))
        );

        assert_eq!(
            TagStandard::parse(&["r", "https://example.com"]).unwrap(),
            TagStandard::Reference(String::from("https://example.com"))
        );

        assert_eq!(
            TagStandard::parse(&["i", "isbn:9780765382030"]).unwrap(),
            TagStandard::ExternalContent {
                content: ExternalContentId::Book(String::from("9780765382030")),
                hint: None,
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "i",
                "podcast:guid:c90e609a-df1e-596a-bd5e-57bcc8aad6cc",
                "https://podcastindex.org/podcast/c90e609a-df1e-596a-bd5e-57bcc8aad6cc"
            ])
            .unwrap(),
            TagStandard::ExternalContent {
                content: ExternalContentId::PodcastFeed(String::from(
                    "c90e609a-df1e-596a-bd5e-57bcc8aad6cc"
                )),
                hint: Some(
                    Url::parse(
                        "https://podcastindex.org/podcast/c90e609a-df1e-596a-bd5e-57bcc8aad6cc"
                    )
                    .unwrap()
                ),
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&["i", "github:12345678", "abcdefghijklmnop"]).unwrap(),
            TagStandard::ExternalIdentity(Identity {
                platform: ExternalIdentity::GitHub,
                ident: "12345678".to_string(),
                proof: "abcdefghijklmnop".to_string()
            })
        );

        assert_eq!(
            TagStandard::parse(&[
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "wss://relay.damus.io"
            ])
            .unwrap(),
            TagStandard::PublicKey {
                public_key: PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                alias: None,
                uppercase: false
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                ""
            ])
            .unwrap(),
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                marker: None,
                public_key: None,
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "wss://relay.damus.io"
            ])
            .unwrap(),
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io").unwrap()),
                marker: None,
                public_key: None,
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "impersonation"
            ])
            .unwrap(),
            TagStandard::PublicKeyReport(
                PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                Report::Impersonation
            )
        );

        assert_eq!(
            TagStandard::parse(&[
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "other"
            ])
            .unwrap(),
            TagStandard::PublicKeyReport(
                PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                Report::Other
            )
        );

        assert_eq!(
            TagStandard::parse(&[
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "profanity"
            ])
            .unwrap(),
            TagStandard::EventReport(
                EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                Report::Profanity
            )
        );

        assert_eq!(
            TagStandard::parse(&[
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "malware"
            ])
            .unwrap(),
            TagStandard::EventReport(
                EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                Report::Malware
            )
        );

        assert_eq!(
            TagStandard::parse(&["nonce", "1", "20"]).unwrap(),
            TagStandard::POW {
                nonce: 1,
                difficulty: 20
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "a",
                "30023:a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919:ipsum",
                "wss://relay.nostr.org"
            ])
            .unwrap(),
            TagStandard::Coordinate {
                coordinate: Coordinate::new(
                    Kind::LongFormTextNote,
                    PublicKey::from_str(
                        "a695f6b60119d9521934a691347d9f78e8770b56da16bb255ee286ddf9fda919"
                    )
                    .unwrap()
                )
                .identifier("ipsum"),
                relay_url: Some(RelayUrl::parse("wss://relay.nostr.org").unwrap()),
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&["r", "wss://atlas.nostr.land/"]).unwrap(),
            TagStandard::RelayMetadata {
                relay_url: RelayUrl::parse("wss://atlas.nostr.land/").unwrap(),
                metadata: None
            }
        );

        assert_eq!(
            TagStandard::parse(&["r", "wss://atlas.nostr.land", "read"]).unwrap(),
            TagStandard::RelayMetadata {
                relay_url: RelayUrl::parse("wss://atlas.nostr.land").unwrap(),
                metadata: Some(RelayMetadata::Read)
            }
        );

        assert_eq!(
            TagStandard::parse(&["r", "wss://atlas.nostr.land", "write"]).unwrap(),
            TagStandard::RelayMetadata {
                relay_url: RelayUrl::parse("wss://atlas.nostr.land").unwrap(),
                metadata: Some(RelayMetadata::Write)
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "p",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "wss://relay.damus.io/",
                "alias",
            ])
            .unwrap(),
            TagStandard::PublicKey {
                public_key: PublicKey::from_str(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
                relay_url: Some(RelayUrl::parse("wss://relay.damus.io/").unwrap()),
                alias: Some(String::from("alias")),
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "",
                "reply"
            ])
            .unwrap(),
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                marker: Some(Marker::Reply),
                public_key: None,
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "",
                "reply",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ])
            .unwrap(),
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                marker: Some(Marker::Reply),
                public_key: Some(
                    PublicKey::from_hex(
                        "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                    )
                    .unwrap()
                ),
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "e",
                "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
                "",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ])
            .unwrap(),
            TagStandard::Event {
                event_id: EventId::from_hex(
                    "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7"
                )
                .unwrap(),
                relay_url: None,
                marker: None,
                public_key: Some(
                    PublicKey::from_hex(
                        "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                    )
                    .unwrap()
                ),
                uppercase: false,
            }
        );

        assert_eq!(
            TagStandard::parse(&[
                "delegation",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d",
                "kind=1",
                "fd0954de564cae9923c2d8ee9ab2bf35bc19757f8e328a978958a2fcc950eaba0754148a203adec29b7b64080d0cf5a32bebedd768ea6eb421a6b751bb4584a8",
            ]).unwrap(),
            TagStandard::Delegation { delegator: PublicKey::from_str(
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ).unwrap(), conditions: Conditions::from_str("kind=1").unwrap(), sig: Signature::from_str("fd0954de564cae9923c2d8ee9ab2bf35bc19757f8e328a978958a2fcc950eaba0754148a203adec29b7b64080d0cf5a32bebedd768ea6eb421a6b751bb4584a8").unwrap() }
        );

        assert_eq!(
            TagStandard::parse(&[
                "relays",
                "wss://relay.damus.io/",
                "wss://nostr-relay.wlvs.space/",
                "wss://nostr.fmt.wiz.biz/"
            ])
            .unwrap(),
            TagStandard::Relays(vec![
                Url::parse("wss://relay.damus.io/").unwrap(),
                Url::parse("wss://nostr-relay.wlvs.space/").unwrap(),
                Url::parse("wss://nostr.fmt.wiz.biz").unwrap(),
            ])
        );

        assert_eq!(
            TagStandard::parse(&[
                "bolt11",
                "lnbc10u1p3unwfusp5t9r3yymhpfqculx78u027lxspgxcr2n2987mx2j55nnfs95nxnzqpp5jmrh92pfld78spqs78v9euf2385t83uvpwk9ldrlvf6ch7tpascqhp5zvkrmemgth3tufcvflmzjzfvjt023nazlhljz2n9hattj4f8jq8qxqyjw5qcqpjrzjqtc4fc44feggv7065fqe5m4ytjarg3repr5j9el35xhmtfexc42yczarjuqqfzqqqqqqqqlgqqqqqqgq9q9qxpqysgq079nkq507a5tw7xgttmj4u990j7wfggtrasah5gd4ywfr2pjcn29383tphp4t48gquelz9z78p4cq7ml3nrrphw5w6eckhjwmhezhnqpy6gyf0"]).unwrap(),
            TagStandard::Bolt11("lnbc10u1p3unwfusp5t9r3yymhpfqculx78u027lxspgxcr2n2987mx2j55nnfs95nxnzqpp5jmrh92pfld78spqs78v9euf2385t83uvpwk9ldrlvf6ch7tpascqhp5zvkrmemgth3tufcvflmzjzfvjt023nazlhljz2n9hattj4f8jq8qxqyjw5qcqpjrzjqtc4fc44feggv7065fqe5m4ytjarg3repr5j9el35xhmtfexc42yczarjuqqfzqqqqqqqqlgqqqqqqgq9q9qxpqysgq079nkq507a5tw7xgttmj4u990j7wfggtrasah5gd4ywfr2pjcn29383tphp4t48gquelz9z78p4cq7ml3nrrphw5w6eckhjwmhezhnqpy6gyf0".to_string())
        );

        assert_eq!(
            TagStandard::parse(&[
                "preimage",
                "5d006d2cf1e73c7148e7519a4c68adc81642ce0e25a432b2434c99f97344c15f"
            ])
            .unwrap(),
            TagStandard::Preimage(
                "5d006d2cf1e73c7148e7519a4c68adc81642ce0e25a432b2434c99f97344c15f".to_string()
            )
        );

        assert_eq!(
            TagStandard::parse(&[
                "description",
                "{\"pubkey\":\"32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245\",\"content\":\"\",\"id\":\"d9cc14d50fcb8c27539aacf776882942c1a11ea4472f8cdec1dea82fab66279d\",\"created_at\":1674164539,\"sig\":\"77127f636577e9029276be060332ea565deaf89ff215a494ccff16ae3f757065e2bc59b2e8c113dd407917a010b3abd36c8d7ad84c0e3ab7dab3a0b0caa9835d\",\"kind\":9734,\"tags\":[[\"e\",\"3624762a1274dd9636e0c552b53086d70bc88c165bc4dc0f9e836a1eaf86c3b8\"],[\"p\",\"32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245\"],[\"relays\",\"wss://relay.damus.io\",\"wss://nostr-relay.wlvs.space\",\"wss://nostr.fmt.wiz.biz\",\"wss://relay.nostr.bg\",\"wss://nostr.oxtr.dev\",\"wss://nostr.v0l.io\",\"wss://brb.io\",\"wss://nostr.bitcoiner.social\",\"ws://monad.jb55.com:8080\",\"wss://relay.snort.social\"]]}"
            ]).unwrap(),
            TagStandard::Description("{\"pubkey\":\"32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245\",\"content\":\"\",\"id\":\"d9cc14d50fcb8c27539aacf776882942c1a11ea4472f8cdec1dea82fab66279d\",\"created_at\":1674164539,\"sig\":\"77127f636577e9029276be060332ea565deaf89ff215a494ccff16ae3f757065e2bc59b2e8c113dd407917a010b3abd36c8d7ad84c0e3ab7dab3a0b0caa9835d\",\"kind\":9734,\"tags\":[[\"e\",\"3624762a1274dd9636e0c552b53086d70bc88c165bc4dc0f9e836a1eaf86c3b8\"],[\"p\",\"32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245\"],[\"relays\",\"wss://relay.damus.io\",\"wss://nostr-relay.wlvs.space\",\"wss://nostr.fmt.wiz.biz\",\"wss://relay.nostr.bg\",\"wss://nostr.oxtr.dev\",\"wss://nostr.v0l.io\",\"wss://brb.io\",\"wss://nostr.bitcoiner.social\",\"ws://monad.jb55.com:8080\",\"wss://relay.snort.social\"]]}".to_string())
        );

        assert_eq!(
            TagStandard::parse(&["amount", "10000"]).unwrap(),
            TagStandard::Amount {
                millisats: 10_000,
                bolt11: None
            }
        );

        assert_eq!(
            TagStandard::parse(&["L", "#t"]).unwrap(),
            TagStandard::LabelNamespace("#t".to_string())
        );

        assert_eq!(
            TagStandard::parse(&["l", "IT-MI"]).unwrap(),
            TagStandard::Label(vec!["IT-MI".to_string()])
        );

        assert_eq!(
            TagStandard::parse(&["l", "IT-MI", "ISO-3166-2"]).unwrap(),
            TagStandard::Label(vec!["IT-MI".to_string(), "ISO-3166-2".to_string()])
        );

        assert_eq!(
            TagStandard::parse(&["r", "5e664e5a7845cd1373c79f580ca4fe29ab5b34d2", "euc"]).unwrap(),
            TagStandard::GitEarliestUniqueCommitId(String::from(
                "5e664e5a7845cd1373c79f580ca4fe29ab5b34d2"
            ))
        );

        assert_eq!(
            TagStandard::parse(&["clone", "https://github.com/rust-nostr/nostr.git"]).unwrap(),
            TagStandard::GitClone(vec![
                Url::parse("https://github.com/rust-nostr/nostr.git").unwrap()
            ])
        );

        assert_eq!(
            TagStandard::parse(&[
                "maintainers",
                "32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245",
                "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
            ])
            .unwrap(),
            TagStandard::GitMaintainers(vec![
                PublicKey::from_hex(
                    "32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245"
                )
                .unwrap(),
                PublicKey::from_hex(
                    "13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"
                )
                .unwrap(),
            ])
        );

        assert_eq!(
            TagStandard::parse(&[
                "web",
                "https://rust-nostr.org/",
                "https://github.com/rust-nostr",
            ])
            .unwrap(),
            TagStandard::Web(vec![
                Url::parse("https://rust-nostr.org").unwrap(),
                Url::parse("https://github.com/rust-nostr").unwrap(),
            ])
        );
    }
}

================
File: src/event/builder.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Event builder

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;
use core::ops::Range;

#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::{CryptoRng, Rng};
use bitcoin::secp256k1::{Secp256k1, Signing, Verification};
use serde_json::{json, Value};

#[cfg(all(feature = "std", feature = "nip04", feature = "nip46"))]
use crate::nips::nip46::Message as NostrConnectMessage;
use crate::prelude::*;

/// Wrong kind error
#[derive(Debug)]
pub enum WrongKindError {
    /// Single kind
    Single(Kind),
    /// Range
    Range(Range<u16>),
}

impl fmt::Display for WrongKindError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Single(k) => write!(f, "{k}"),
            Self::Range(range) => write!(f, "'{} <= k <= {}'", range.start, range.end),
        }
    }
}

/// [`EventBuilder`] error
#[derive(Debug)]
pub enum Error {
    /// Signer error
    Signer(SignerError),
    /// Unsigned event error
    Unsigned(super::unsigned::Error),
    /// OpenTimestamps error
    #[cfg(feature = "nip03")]
    OpenTimestamps(nostr_ots::Error),
    /// NIP04 error
    #[cfg(feature = "nip04")]
    NIP04(nip04::Error),
    /// NIP44 error
    #[cfg(all(feature = "std", feature = "nip44"))]
    NIP44(nip44::Error),
    /// NIP58 error
    NIP58(nip58::Error),
    /// NIP59 error
    #[cfg(all(feature = "std", feature = "nip59"))]
    NIP59(nip59::Error),
    /// Wrong kind
    WrongKind {
        /// The received wrong kind
        received: Kind,
        /// The expected kind (single or range)
        expected: WrongKindError,
    },
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Signer(e) => write!(f, "{e}"),
            Self::Unsigned(e) => write!(f, "{e}"),
            #[cfg(feature = "nip03")]
            Self::OpenTimestamps(e) => write!(f, "{e}"),
            #[cfg(feature = "nip04")]
            Self::NIP04(e) => write!(f, "{e}"),
            #[cfg(all(feature = "std", feature = "nip44"))]
            Self::NIP44(e) => write!(f, "{e}"),
            Self::NIP58(e) => write!(f, "{e}"),
            #[cfg(all(feature = "std", feature = "nip59"))]
            Self::NIP59(e) => write!(f, "{e}"),
            Self::WrongKind { received, expected } => {
                write!(f, "Wrong kind: received={received}, expected={expected}")
            }
        }
    }
}

impl From<SignerError> for Error {
    fn from(e: SignerError) -> Self {
        Self::Signer(e)
    }
}

impl From<super::unsigned::Error> for Error {
    fn from(e: super::unsigned::Error) -> Self {
        Self::Unsigned(e)
    }
}

#[cfg(feature = "nip03")]
impl From<nostr_ots::Error> for Error {
    fn from(e: nostr_ots::Error) -> Self {
        Self::OpenTimestamps(e)
    }
}

#[cfg(feature = "nip04")]
impl From<nip04::Error> for Error {
    fn from(e: nip04::Error) -> Self {
        Self::NIP04(e)
    }
}

#[cfg(all(feature = "std", feature = "nip44"))]
impl From<nip44::Error> for Error {
    fn from(e: nip44::Error) -> Self {
        Self::NIP44(e)
    }
}

impl From<nip58::Error> for Error {
    fn from(e: nip58::Error) -> Self {
        Self::NIP58(e)
    }
}

#[cfg(all(feature = "std", feature = "nip59"))]
impl From<nip59::Error> for Error {
    fn from(e: nip59::Error) -> Self {
        Self::NIP59(e)
    }
}

/// Event builder
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct EventBuilder {
    kind: Kind,
    tags: Vec<Tag>,
    content: String,
    custom_created_at: Option<Timestamp>,
    /// POW difficulty
    pow: Option<u8>,
}

impl EventBuilder {
    /// New event builder
    #[inline]
    pub fn new<S>(kind: Kind, content: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            kind,
            tags: Vec::new(),
            content: content.into(),
            custom_created_at: None,
            pow: None,
        }
    }

    /// Add tags
    #[deprecated(since = "0.37.0", note = "Use `tags` instead")]
    pub fn add_tags<I>(mut self, tags: I) -> Self
    where
        I: IntoIterator<Item = Tag>,
    {
        self.tags.extend(tags);
        self
    }

    /// Add tag
    #[inline]
    pub fn tag(mut self, tag: Tag) -> Self {
        self.tags.push(tag);
        self
    }

    /// Add tags
    ///
    /// This method extend the current tags (if any).
    #[inline]
    pub fn tags<I>(mut self, tags: I) -> Self
    where
        I: IntoIterator<Item = Tag>,
    {
        self.tags.extend(tags);
        self
    }

    /// Set a custom `created_at` UNIX timestamp
    #[inline]
    pub fn custom_created_at(mut self, created_at: Timestamp) -> Self {
        self.custom_created_at = Some(created_at);
        self
    }

    /// Set POW difficulty
    ///
    /// Only values `> 0` are accepted!
    #[inline]
    pub fn pow(mut self, difficulty: u8) -> Self {
        if difficulty > 0 {
            self.pow = Some(difficulty);
        }
        self
    }

    /// Build unsigned event
    pub fn build_with_ctx<T>(self, supplier: &T, pubkey: PublicKey) -> UnsignedEvent
    where
        T: TimeSupplier,
    {
        // Check if should be POW
        match self.pow {
            Some(difficulty) if difficulty > 0 => {
                let mut nonce: u128 = 0;
                let mut tags: Vec<Tag> = self.tags;

                tags.reserve_exact(1);

                loop {
                    nonce += 1;

                    tags.push(Tag::pow(nonce, difficulty));

                    let created_at: Timestamp = self
                        .custom_created_at
                        .unwrap_or_else(|| Timestamp::now_with_supplier(supplier));
                    let id: EventId =
                        EventId::new(&pubkey, &created_at, &self.kind, &tags, &self.content);

                    if id.check_pow(difficulty) {
                        return UnsignedEvent {
                            id: Some(id),
                            pubkey,
                            created_at,
                            kind: self.kind,
                            tags: Tags::new(tags),
                            content: self.content,
                        };
                    }

                    tags.pop();
                }
            }
            // No POW difficulty set OR difficulty == 0
            _ => {
                let mut unsigned: UnsignedEvent = UnsignedEvent {
                    id: None,
                    pubkey,
                    created_at: self
                        .custom_created_at
                        .unwrap_or_else(|| Timestamp::now_with_supplier(supplier)),
                    kind: self.kind,
                    tags: Tags::new(self.tags),
                    content: self.content,
                };
                unsigned.ensure_id();
                unsigned
            }
        }
    }

    /// Build unsigned event
    #[inline]
    #[cfg(feature = "std")]
    pub fn build(self, pubkey: PublicKey) -> UnsignedEvent {
        self.build_with_ctx(&Instant::now(), pubkey)
    }

    /// Build, sign and return [`Event`]
    ///
    /// Shortcut for `builder.build(public_key).sign(signer)`.
    #[inline]
    #[cfg(feature = "std")]
    pub async fn sign<T>(self, signer: &T) -> Result<Event, Error>
    where
        T: NostrSigner,
    {
        let public_key: PublicKey = signer.get_public_key().await?;
        Ok(self.build(public_key).sign(signer).await?)
    }

    /// Build, sign and return [`Event`] using [`Keys`] signer
    #[inline]
    #[cfg(feature = "std")]
    pub fn sign_with_keys(self, keys: &Keys) -> Result<Event, Error> {
        self.sign_with_ctx(&SECP256K1, &mut OsRng, &Instant::now(), keys)
    }

    /// Build, sign and return [`Event`] using [`Keys`] signer
    pub fn sign_with_ctx<C, R, T>(
        self,
        secp: &Secp256k1<C>,
        rng: &mut R,
        supplier: &T,
        keys: &Keys,
    ) -> Result<Event, Error>
    where
        C: Signing + Verification,
        R: Rng + CryptoRng,
        T: TimeSupplier,
    {
        let pubkey: PublicKey = keys.public_key();
        Ok(self
            .build_with_ctx(supplier, pubkey)
            .sign_with_ctx(secp, rng, keys)?)
    }

    /// Profile metadata
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    ///
    /// # Example
    /// ```rust,no_run
    /// use nostr::prelude::*;
    ///
    /// let metadata = Metadata::new()
    ///     .name("username")
    ///     .display_name("My Username")
    ///     .about("Description")
    ///     .picture(Url::parse("https://example.com/avatar.png").unwrap())
    ///     .nip05("username@example.com")
    ///     .lud16("pay@yukikishimoto.com");
    ///
    /// let builder = EventBuilder::metadata(&metadata);
    /// ```
    #[inline]
    pub fn metadata(metadata: &Metadata) -> Self {
        Self::new(Kind::Metadata, metadata.as_json())
    }

    /// Relay list metadata
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/65.md>
    pub fn relay_list<I>(iter: I) -> Self
    where
        I: IntoIterator<Item = (RelayUrl, Option<RelayMetadata>)>,
    {
        let tags = iter
            .into_iter()
            .map(|(url, metadata)| Tag::relay_metadata(url, metadata));
        Self::new(Kind::RelayList, "").tags(tags)
    }

    /// Text note
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    ///
    /// # Example
    /// ```rust,no_run
    /// use nostr::EventBuilder;
    ///
    /// let builder = EventBuilder::text_note("My first text note from rust-nostr!");
    /// ```
    #[inline]
    pub fn text_note<S>(content: S) -> Self
    where
        S: Into<String>,
    {
        Self::new(Kind::TextNote, content)
    }

    /// Text note reply
    ///
    /// If no `root` is passed, the `rely_to` will be used for root `e` tag.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/10.md>
    pub fn text_note_reply<S>(
        content: S,
        reply_to: &Event,
        root: Option<&Event>,
        relay_url: Option<RelayUrl>,
    ) -> Self
    where
        S: Into<String>,
    {
        let mut tags: Vec<Tag> = Vec::new();

        // Add `e` and `p` tag of **root** event
        match root {
            Some(root) => {
                // ID and author
                tags.push(Tag::from_standardized_without_cell(TagStandard::Event {
                    event_id: root.id,
                    relay_url: relay_url.clone(),
                    marker: Some(Marker::Root),
                    public_key: Some(root.pubkey),
                    uppercase: false,
                }));
                tags.push(Tag::public_key(root.pubkey));

                // Add others `p` tags
                tags.extend(
                    root.tags
                        .iter()
                        .filter(|t| {
                            t.kind()
                                == TagKind::SingleLetter(SingleLetterTag {
                                    character: Alphabet::P,
                                    uppercase: false,
                                })
                        })
                        .cloned(),
                );
            }
            None => {
                // No root event is passed, use `reply_to` event ID for `root` marker
                tags.push(Tag::from_standardized_without_cell(TagStandard::Event {
                    event_id: reply_to.id,
                    relay_url: relay_url.clone(),
                    marker: Some(Marker::Root),
                    public_key: Some(reply_to.pubkey),
                    uppercase: false,
                }));
            }
        }

        // Add `e` and `p` tag of event author
        tags.push(Tag::from_standardized_without_cell(TagStandard::Event {
            event_id: reply_to.id,
            relay_url,
            marker: Some(Marker::Reply),
            public_key: Some(reply_to.pubkey),
            uppercase: false,
        }));
        tags.push(Tag::public_key(reply_to.pubkey));

        // Add others `p` tags of reply_to event
        tags.extend(
            reply_to
                .tags
                .iter()
                .filter(|t| {
                    t.kind()
                        == TagKind::SingleLetter(SingleLetterTag {
                            character: Alphabet::P,
                            uppercase: false,
                        })
                })
                .cloned(),
        );

        // Compose event
        Self::new(Kind::TextNote, content).tags(tags)
    }

    /// Comment
    ///
    /// If no `root` is passed, the `comment_to` will be used for root `e` tag.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/22.md>
    pub fn comment<S>(
        content: S,
        comment_to: &Event,
        root: Option<&Event>,
        relay_url: Option<RelayUrl>,
    ) -> Self
    where
        S: Into<String>,
    {
        // The added tags will be at least 4
        let mut tags: Vec<Tag> = Vec::with_capacity(4);

        // Add `A`, `E` and `K` tag of **root** event
        if let Some(root) = root {
            // If event has coordinate, add it to tags otherwise push the event ID
            match root.coordinate() {
                Some(coordinate) => {
                    tags.push(Tag::from_standardized_without_cell(
                        TagStandard::Coordinate {
                            coordinate,
                            relay_url: relay_url.clone(),
                            uppercase: true,
                        },
                    ));
                }
                None => {
                    // ID and author
                    tags.push(Tag::from_standardized_without_cell(TagStandard::Event {
                        event_id: root.id,
                        relay_url: relay_url.clone(),
                        marker: None,
                        public_key: Some(root.pubkey),
                        uppercase: true,
                    }));
                }
            }

            // Kind
            tags.push(Tag::from_standardized_without_cell(TagStandard::Kind {
                kind: root.kind,
                uppercase: true,
            }));

            // Add others `p` tags
            tags.extend(
                root.tags
                    .iter()
                    .filter(|t| {
                        t.kind()
                            == TagKind::SingleLetter(SingleLetterTag {
                                character: Alphabet::P,
                                uppercase: false,
                            })
                    })
                    .cloned(),
            );
        } else {
            match comment_to.coordinate() {
                Some(coordinate) => {
                    tags.push(Tag::from_standardized_without_cell(
                        TagStandard::Coordinate {
                            coordinate,
                            relay_url: relay_url.clone(),
                            uppercase: true,
                        },
                    ));
                }
                None => {
                    // ID and author
                    tags.push(Tag::from_standardized_without_cell(TagStandard::Event {
                        event_id: comment_to.id,
                        relay_url: relay_url.clone(),
                        marker: None,
                        public_key: Some(comment_to.pubkey),
                        uppercase: true,
                    }));
                }
            }

            // Kind
            tags.push(Tag::from_standardized_without_cell(TagStandard::Kind {
                kind: comment_to.kind,
                uppercase: true,
            }));
        }

        // Add `a` tag (if event has it)
        if let Some(coordinate) = comment_to.coordinate() {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::Coordinate {
                    coordinate,
                    relay_url: relay_url.clone(),
                    uppercase: false, // <--- Same as root event but lowercase
                },
            ));
        }

        // Add `e` tag of event author
        tags.push(Tag::from_standardized_without_cell(TagStandard::Event {
            event_id: comment_to.id,
            relay_url,
            marker: None,
            public_key: Some(comment_to.pubkey),
            uppercase: false,
        }));

        // Add `k` tag of event kind
        tags.push(Tag::from_standardized_without_cell(TagStandard::Kind {
            kind: comment_to.kind,
            uppercase: false,
        }));

        // Add others `p` tags of comment_to event
        // TODO: avoid `p` tag duplicates (are added also before from root event)
        tags.extend(
            comment_to
                .tags
                .iter()
                .filter(|t| {
                    t.kind()
                        == TagKind::SingleLetter(SingleLetterTag {
                            character: Alphabet::P,
                            uppercase: false,
                        })
                })
                .cloned(),
        );

        // Compose event
        Self::new(Kind::Comment, content).tags(tags)
    }

    /// Long-form text note (generally referred to as "articles" or "blog posts").
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/23.md>
    ///
    /// # Example
    /// ```rust,no_run
    /// use std::str::FromStr;
    ///
    /// use nostr::prelude::*;
    ///
    /// let event_id = EventId::from_hex("b3e392b11f5d4f28321cedd09303a748acfd0487aea5a7450b3481c60b6e4f87").unwrap();
    /// let content: &str = "Lorem [ipsum][4] dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nRead more at #[3].";
    /// let tags = &[
    ///     Tag::identifier("lorem-ipsum".to_string()),
    ///     Tag::from_standardized(TagStandard::Title("Lorem Ipsum".to_string())),
    ///     Tag::from_standardized(TagStandard::PublishedAt(Timestamp::from(1296962229))),
    ///     Tag::hashtag("placeholder".to_string()),
    ///     Tag::event(event_id),
    /// ];
    /// let builder = EventBuilder::long_form_text_note("My first text note from rust-nostr!");
    /// ```
    #[inline]
    pub fn long_form_text_note<S>(content: S) -> Self
    where
        S: Into<String>,
    {
        Self::new(Kind::LongFormTextNote, content)
    }

    /// Contact/Follow list
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/02.md>
    pub fn contact_list<I>(contacts: I) -> Self
    where
        I: IntoIterator<Item = Contact>,
    {
        let tags = contacts.into_iter().map(|contact| {
            Tag::from_standardized_without_cell(TagStandard::PublicKey {
                public_key: contact.public_key,
                relay_url: contact.relay_url,
                alias: contact.alias,
                uppercase: false,
            })
        });
        Self::new(Kind::ContactList, "").tags(tags)
    }

    /// OpenTimestamps Attestations for Events
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/03.md>
    #[cfg(feature = "nip03")]
    pub fn opentimestamps(event_id: EventId, relay_url: Option<RelayUrl>) -> Result<Self, Error> {
        let ots: String = nostr_ots::timestamp_event(&event_id.to_hex())?;
        Ok(
            Self::new(Kind::OpenTimestamps, ots).tags([Tag::from_standardized_without_cell(
                TagStandard::Event {
                    event_id,
                    relay_url,
                    marker: None,
                    public_key: None,
                    uppercase: false,
                },
            )]),
        )
    }

    /// Repost
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/18.md>
    pub fn repost(event: &Event, relay_url: Option<RelayUrl>) -> Self {
        if event.kind == Kind::TextNote {
            Self::new(Kind::Repost, event.as_json()).tags([
                Tag::from_standardized_without_cell(TagStandard::Event {
                    event_id: event.id,
                    relay_url,
                    marker: None,
                    // NOTE: not add public key since it's already included as `p` tag
                    public_key: None,
                    uppercase: false,
                }),
                Tag::public_key(event.pubkey),
            ])
        } else {
            Self::new(Kind::GenericRepost, event.as_json()).tags([
                Tag::from_standardized_without_cell(TagStandard::Event {
                    event_id: event.id,
                    relay_url,
                    marker: None,
                    // NOTE: not add public key since it's already included as `p` tag
                    public_key: None,
                    uppercase: false,
                }),
                Tag::public_key(event.pubkey),
                Tag::from_standardized_without_cell(TagStandard::Kind {
                    kind: event.kind,
                    uppercase: false,
                }),
            ])
        }
    }

    /// Event deletion
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/09.md>
    #[inline]
    pub fn delete<I, T>(ids: I) -> Self
    where
        I: IntoIterator<Item = T>,
        T: Into<EventIdOrCoordinate>,
    {
        Self::delete_with_reason(ids, "")
    }

    /// Event deletion with reason
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/09.md>
    pub fn delete_with_reason<I, T, S>(ids: I, reason: S) -> Self
    where
        I: IntoIterator<Item = T>,
        T: Into<EventIdOrCoordinate>,
        S: Into<String>,
    {
        let tags = ids.into_iter().map(|t| {
            let middle: EventIdOrCoordinate = t.into();
            middle.into()
        });
        Self::new(Kind::EventDeletion, reason.into()).tags(tags)
    }

    /// Add reaction (like/upvote, dislike/downvote or emoji) to an event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/25.md>
    #[inline]
    pub fn reaction<S>(event: &Event, reaction: S) -> Self
    where
        S: Into<String>,
    {
        Self::reaction_extended(event.id, event.pubkey, Some(event.kind), reaction)
    }

    /// Add reaction (like/upvote, dislike/downvote or emoji) to an event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/25.md>
    pub fn reaction_extended<S>(
        event_id: EventId,
        public_key: PublicKey,
        kind: Option<Kind>,
        reaction: S,
    ) -> Self
    where
        S: Into<String>,
    {
        let mut tags: Vec<Tag> = Vec::with_capacity(2 + usize::from(kind.is_some()));

        tags.push(Tag::event(event_id));
        tags.push(Tag::public_key(public_key));

        if let Some(kind) = kind {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Kind {
                kind,
                uppercase: false,
            }));
        }

        Self::new(Kind::Reaction, reaction).tags(tags)
    }

    /// Create new channel
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/28.md>
    #[inline]
    pub fn channel(metadata: &Metadata) -> Self {
        Self::new(Kind::ChannelCreation, metadata.as_json())
    }

    /// Channel metadata
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/28.md>
    #[inline]
    pub fn channel_metadata(
        channel_id: EventId,
        relay_url: Option<RelayUrl>,
        metadata: &Metadata,
    ) -> Self {
        Self::new(Kind::ChannelMetadata, metadata.as_json()).tags([
            Tag::from_standardized_without_cell(TagStandard::Event {
                event_id: channel_id,
                relay_url,
                marker: None,
                public_key: None,
                uppercase: false,
            }),
        ])
    }

    /// Channel message
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/28.md>
    #[inline]
    pub fn channel_msg<S>(channel_id: EventId, relay_url: RelayUrl, content: S) -> Self
    where
        S: Into<String>,
    {
        Self::new(Kind::ChannelMessage, content).tags([Tag::from_standardized_without_cell(
            TagStandard::Event {
                event_id: channel_id,
                relay_url: Some(relay_url),
                marker: Some(Marker::Root),
                public_key: None,
                uppercase: false,
            },
        )])
    }

    /// Hide message
    ///
    /// The `message_id` must be the [`EventId`] of the kind `42`.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/28.md>
    pub fn hide_channel_msg<S>(message_id: EventId, reason: Option<S>) -> Self
    where
        S: Into<String>,
    {
        let content: Value = json!({
            "reason": reason.map(|s| s.into()).unwrap_or_default(),
        });

        Self::new(Kind::ChannelHideMessage, content.to_string()).tag(Tag::event(message_id))
    }

    /// Mute channel user
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/28.md>
    pub fn mute_channel_user<S>(public_key: PublicKey, reason: Option<S>) -> Self
    where
        S: Into<String>,
    {
        let content: Value = json!({
            "reason": reason.map(|s| s.into()).unwrap_or_default(),
        });

        Self::new(Kind::ChannelMuteUser, content.to_string()).tag(Tag::public_key(public_key))
    }

    /// Authentication of clients to relays
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/42.md>
    #[inline]
    pub fn auth<S>(challenge: S, relay: RelayUrl) -> Self
    where
        S: Into<String>,
    {
        Self::new(Kind::Authentication, "").tags([
            Tag::from_standardized_without_cell(TagStandard::Challenge(challenge.into())),
            Tag::from_standardized_without_cell(TagStandard::Relay(relay)),
        ])
    }

    /// Nostr Connect / Nostr Remote Signing
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/46.md>
    #[inline]
    #[cfg(all(feature = "std", feature = "nip04", feature = "nip46"))]
    pub fn nostr_connect(
        sender_keys: &Keys,
        receiver_pubkey: PublicKey,
        msg: NostrConnectMessage,
    ) -> Result<Self, Error> {
        Ok(Self::new(
            Kind::NostrConnect,
            nip04::encrypt(sender_keys.secret_key(), &receiver_pubkey, msg.as_json())?,
        )
        .tag(Tag::public_key(receiver_pubkey)))
    }

    /// Live Event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/53.md>
    #[inline]
    pub fn live_event(live_event: LiveEvent) -> Self {
        let tags: Vec<Tag> = live_event.into();
        Self::new(Kind::LiveEvent, "").tags(tags)
    }

    /// Live Event Message
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/53.md>
    pub fn live_event_msg<S>(
        live_event_id: S,
        live_event_host: PublicKey,
        content: S,
        relay_url: Option<RelayUrl>,
    ) -> Self
    where
        S: Into<String>,
    {
        Self::new(Kind::LiveEventMessage, content).tag(Tag::from_standardized_without_cell(
            TagStandard::Coordinate {
                coordinate: Coordinate::new(Kind::LiveEvent, live_event_host)
                    .identifier(live_event_id),
                relay_url,
                uppercase: false,
            },
        ))
    }

    /// Reporting
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/56.md>
    #[inline]
    pub fn report<I, S>(tags: I, content: S) -> Self
    where
        I: IntoIterator<Item = Tag>,
        S: Into<String>,
    {
        Self::new(Kind::Reporting, content).tags(tags)
    }

    /// Create **public** zap request event
    ///
    /// **This event MUST NOT be broadcasted to relays**, instead must be sent to a recipient's LNURL pay callback url.
    ///
    /// To build a **private** or **anonymous** zap request, use:
    ///
    /// ```rust,no_run
    /// use nostr::prelude::*;
    ///
    /// # #[cfg(all(feature = "std", feature = "nip57"))]
    /// # fn main() {
    /// # let keys = Keys::generate();
    /// # let public_key = PublicKey::from_bech32(
    /// # "npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy",
    /// # ).unwrap();
    /// # let relays = [Url::parse("wss://relay.damus.io").unwrap()];
    /// let data = ZapRequestData::new(public_key, relays).message("Zap!");
    ///
    /// let anon_zap: Event = nip57::anonymous_zap_request(data.clone()).unwrap();
    /// println!("Anonymous zap request: {anon_zap:#?}");
    ///
    /// let private_zap: Event = nip57::private_zap_request(data, &keys).unwrap();
    /// println!("Private zap request: {private_zap:#?}");
    /// # }
    ///
    /// # #[cfg(not(all(feature = "std", feature = "nip57")))]
    /// # fn main() {}
    /// ```
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/57.md>
    #[cfg(feature = "nip57")]
    pub fn public_zap_request(data: ZapRequestData) -> Self {
        let message: String = data.message.clone();
        let tags: Vec<Tag> = data.into();
        Self::new(Kind::ZapRequest, message).tags(tags)
    }

    /// Zap Receipt
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/57.md>
    #[cfg(feature = "nip57")]
    pub fn zap_receipt<S1, S2>(bolt11: S1, preimage: Option<S2>, zap_request: &Event) -> Self
    where
        S1: Into<String>,
        S2: Into<String>,
    {
        let mut tags: Vec<Tag> = vec![
            Tag::from_standardized_without_cell(TagStandard::Bolt11(bolt11.into())),
            Tag::from_standardized_without_cell(TagStandard::Description(zap_request.as_json())),
        ];

        // add preimage tag if provided
        if let Some(pre_image_tag) = preimage {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Preimage(
                pre_image_tag.into(),
            )))
        }

        // add e tag
        if let Some(tag) = zap_request
            .tags
            .iter()
            .find(|t| {
                t.kind()
                    == TagKind::SingleLetter(SingleLetterTag {
                        character: Alphabet::E,
                        uppercase: false,
                    })
            })
            .cloned()
        {
            tags.push(tag);
        }

        // add a tag
        if let Some(tag) = zap_request
            .tags
            .iter()
            .find(|t| {
                t.kind()
                    == TagKind::SingleLetter(SingleLetterTag {
                        character: Alphabet::A,
                        uppercase: false,
                    })
            })
            .cloned()
        {
            tags.push(tag);
        }

        // add p tag
        if let Some(tag) = zap_request
            .tags
            .iter()
            .find(|t| {
                t.kind()
                    == TagKind::SingleLetter(SingleLetterTag {
                        character: Alphabet::P,
                        uppercase: false,
                    })
            })
            .cloned()
        {
            tags.push(tag);
        }

        // add P tag
        tags.push(Tag::from_standardized_without_cell(
            TagStandard::PublicKey {
                public_key: zap_request.pubkey,
                relay_url: None,
                alias: None,
                uppercase: true,
            },
        ));

        Self::new(Kind::ZapReceipt, "").tags(tags)
    }

    /// Badge definition
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/58.md>
    ///
    /// # Example
    /// ```rust,no_run
    /// use nostr::prelude::*;
    ///
    /// let badge_id = String::from("nostr-sdk-test-badge");
    /// let name = Some(String::from("rust-nostr test badge"));
    /// let description = Some(String::from("This is a test badge"));
    /// let image_url = Some(Url::parse("https://nostr.build/someimage/1337").unwrap());
    /// let image_size = Some(ImageDimensions::new(1024, 1024));
    /// let thumbs = vec![(
    ///     Url::parse("https://nostr.build/somethumbnail/1337").unwrap(),
    ///     Some(ImageDimensions::new(256, 256)),
    /// )];
    ///
    /// let event_builder =
    ///     EventBuilder::define_badge(badge_id, name, description, image_url, image_size, thumbs);
    /// ```
    pub fn define_badge<S>(
        badge_id: S,
        name: Option<S>,
        description: Option<S>,
        image: Option<Url>,
        image_dimensions: Option<ImageDimensions>,
        thumbnails: Vec<(Url, Option<ImageDimensions>)>,
    ) -> Self
    where
        S: Into<String>,
    {
        let mut tags: Vec<Tag> = Vec::new();

        // Set identifier tag
        tags.push(Tag::identifier(badge_id.into()));

        // Set name tag
        if let Some(name) = name {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Name(
                name.into(),
            )));
        }

        // Set description tag
        if let Some(description) = description {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::Description(description.into()),
            ));
        }

        // Set image tag
        if let Some(image) = image {
            let image_tag = if let Some(dimensions) = image_dimensions {
                Tag::from_standardized_without_cell(TagStandard::Image(image, Some(dimensions)))
            } else {
                Tag::from_standardized_without_cell(TagStandard::Image(image, None))
            };
            tags.push(image_tag);
        }

        // Set thumbnail tags
        for (thumb, dimensions) in thumbnails.into_iter() {
            let thumb_tag = if let Some(dimensions) = dimensions {
                Tag::from_standardized_without_cell(TagStandard::Thumb(thumb, Some(dimensions)))
            } else {
                Tag::from_standardized_without_cell(TagStandard::Thumb(thumb, None))
            };
            tags.push(thumb_tag);
        }

        Self::new(Kind::BadgeDefinition, "").tags(tags)
    }

    /// Badge award
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/58.md>
    pub fn award_badge<I>(badge_definition: &Event, awarded_public_keys: I) -> Result<Self, Error>
    where
        I: IntoIterator<Item = PublicKey>,
    {
        let badge_id = badge_definition
            .tags
            .iter()
            .find_map(|t| match t.as_standardized() {
                Some(TagStandard::Identifier(id)) => Some(id),
                _ => None,
            })
            .ok_or(Error::NIP58(nip58::Error::IdentifierTagNotFound))?;

        // At least 1 tag
        let mut tags = Vec::with_capacity(1);

        // Add identity tag
        tags.push(Tag::from_standardized_without_cell(
            TagStandard::Coordinate {
                coordinate: Coordinate::new(Kind::BadgeDefinition, badge_definition.pubkey)
                    .identifier(badge_id),
                relay_url: None,
                uppercase: false,
            },
        ));

        // Add awarded public keys
        tags.extend(awarded_public_keys.into_iter().map(Tag::public_key));

        // Build event
        Ok(Self::new(Kind::BadgeAward, "").tags(tags))
    }

    /// Profile badges
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/58.md>
    pub fn profile_badges(
        badge_definitions: Vec<Event>,
        badge_awards: Vec<Event>,
        pubkey_awarded: &PublicKey,
    ) -> Result<Self, Error> {
        if badge_definitions.len() != badge_awards.len() {
            return Err(Error::NIP58(nip58::Error::InvalidLength));
        }

        let badge_awards: Vec<Event> = nip58::filter_for_kind(badge_awards, &Kind::BadgeAward);
        if badge_awards.is_empty() {
            return Err(Error::NIP58(nip58::Error::InvalidKind));
        }

        for award in badge_awards.iter() {
            if !award.tags.iter().any(|t| match t.as_standardized() {
                Some(TagStandard::PublicKey { public_key, .. }) => public_key == pubkey_awarded,
                _ => false,
            }) {
                return Err(Error::NIP58(nip58::Error::BadgeAwardsLackAwardedPublicKey));
            }
        }

        let badge_definitions: Vec<Event> =
            nip58::filter_for_kind(badge_definitions, &Kind::BadgeDefinition);
        if badge_definitions.is_empty() {
            return Err(Error::NIP58(nip58::Error::InvalidKind));
        }

        // Add identifier `d` tag
        let id_tag: Tag = Tag::identifier("profile_badges");
        let mut tags: Vec<Tag> = vec![id_tag];

        let badge_definitions_identifiers = badge_definitions.iter().filter_map(|event| {
            let id: &str = event.tags.identifier()?;
            Some((event, id))
        });

        let badge_awards_identifiers = badge_awards.iter().filter_map(|event| {
            let (_, relay_url) =
                nip58::extract_awarded_public_key(event.tags.as_slice(), pubkey_awarded)?;
            let (id, a_tag) = event.tags.iter().find_map(|t| match t.as_standardized() {
                Some(TagStandard::Coordinate { coordinate, .. }) => {
                    Some((&coordinate.identifier, t))
                }
                _ => None,
            })?;
            Some((event, id, a_tag, relay_url))
        });

        // This collection has been filtered for the needed tags
        let users_badges = core::iter::zip(badge_definitions_identifiers, badge_awards_identifiers);

        for (badge_definition, badge_award) in users_badges {
            match (badge_definition, badge_award) {
                ((_, identifier), (_, badge_id, ..)) if badge_id != identifier => {
                    return Err(Error::NIP58(nip58::Error::MismatchedBadgeDefinitionOrAward));
                }
                ((_, identifier), (badge_award_event, badge_id, a_tag, relay_url))
                    if badge_id == identifier =>
                {
                    let badge_award_event_tag: Tag =
                        Tag::from_standardized_without_cell(TagStandard::Event {
                            event_id: badge_award_event.id,
                            relay_url: relay_url.clone(),
                            marker: None,
                            public_key: None,
                            uppercase: false,
                        });
                    tags.extend_from_slice(&[a_tag.clone(), badge_award_event_tag]);
                }
                _ => {}
            }
        }

        Ok(EventBuilder::new(Kind::ProfileBadges, "").tags(tags))
    }

    /// Data Vending Machine (DVM) - Job Request
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/90.md>
    pub fn job_request(kind: Kind) -> Result<Self, Error> {
        if !kind.is_job_request() {
            return Err(Error::WrongKind {
                received: kind,
                expected: WrongKindError::Range(NIP90_JOB_REQUEST_RANGE),
            });
        }

        Ok(Self::new(kind, ""))
    }

    /// Data Vending Machine (DVM) - Job Result
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/90.md>
    pub fn job_result<S>(
        job_request: Event,
        payload: S,
        millisats: u64,
        bolt11: Option<String>,
    ) -> Result<Self, Error>
    where
        S: Into<String>,
    {
        let kind: Kind = job_request.kind + 1000;

        // Check if Job Result kind
        if !kind.is_job_result() {
            return Err(Error::WrongKind {
                received: kind,
                expected: WrongKindError::Range(NIP90_JOB_RESULT_RANGE),
            });
        }

        let mut tags: Vec<Tag> = job_request
            .tags
            .iter()
            .filter_map(|t| {
                if t.kind()
                    == TagKind::SingleLetter(SingleLetterTag {
                        character: Alphabet::I,
                        uppercase: false,
                    })
                {
                    Some(t.clone())
                } else {
                    None
                }
            })
            .collect();

        tags.extend_from_slice(&[
            Tag::event(job_request.id),
            Tag::public_key(job_request.pubkey),
            Tag::from_standardized_without_cell(TagStandard::Request(job_request)),
            Tag::from_standardized_without_cell(TagStandard::Amount { millisats, bolt11 }),
        ]);

        Ok(Self::new(kind, payload).tags(tags))
    }

    /// Data Vending Machine (DVM) - Job Feedback
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/90.md>
    pub fn job_feedback(data: JobFeedbackData) -> Self {
        let mut tags: Vec<Tag> = Vec::with_capacity(3);

        tags.push(Tag::event(data.job_request_id));
        tags.push(Tag::public_key(data.customer_public_key));
        tags.push(Tag::from_standardized_without_cell(
            TagStandard::DataVendingMachineStatus {
                status: data.status,
                extra_info: data.extra_info,
            },
        ));

        if let Some(millisats) = data.amount_msat {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Amount {
                millisats,
                bolt11: data.bolt11,
            }));
        }

        Self::new(Kind::JobFeedback, data.payload.unwrap_or_default()).tags(tags)
    }

    /// File metadata
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/94.md>
    #[inline]
    pub fn file_metadata<S>(description: S, metadata: FileMetadata) -> Self
    where
        S: Into<String>,
    {
        let tags: Vec<Tag> = metadata.into();
        Self::new(Kind::FileMetadata, description.into()).tags(tags)
    }

    /// HTTP Auth
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/98.md>
    #[inline]
    pub fn http_auth(data: HttpData) -> Self {
        let tags: Vec<Tag> = data.into();
        Self::new(Kind::HttpAuth, "").tags(tags)
    }

    /// Set stall data
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/15.md>
    #[inline]
    pub fn stall_data(data: StallData) -> Self {
        let content: String = data.as_json();
        let tags: Vec<Tag> = data.into();
        Self::new(Kind::SetStall, content).tags(tags)
    }

    /// Set product data
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/15.md>
    #[inline]
    pub fn product_data(data: ProductData) -> Self {
        let content: String = data.as_json();
        let tags: Vec<Tag> = data.into();
        Self::new(Kind::SetProduct, content).tags(tags)
    }

    /// Seal
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/59.md>
    #[inline]
    #[cfg(all(feature = "std", feature = "nip59"))]
    pub async fn seal<T>(
        signer: &T,
        receiver_pubkey: &PublicKey,
        rumor: EventBuilder,
    ) -> Result<Self, Error>
    where
        T: NostrSigner,
    {
        Ok(nip59::make_seal(signer, receiver_pubkey, rumor).await?)
    }

    /// Gift Wrap from seal
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/59.md>
    #[cfg(all(feature = "std", feature = "nip59"))]
    pub fn gift_wrap_from_seal<I>(
        receiver: &PublicKey,
        seal: &Event,
        extra_tags: I,
    ) -> Result<Event, Error>
    where
        I: IntoIterator<Item = Tag>,
    {
        if seal.kind != Kind::Seal {
            return Err(Error::WrongKind {
                received: seal.kind,
                expected: WrongKindError::Single(Kind::Seal),
            });
        }

        let keys: Keys = Keys::generate();
        let content: String = nip44::encrypt(
            keys.secret_key(),
            receiver,
            seal.as_json(),
            nip44::Version::default(),
        )?;

        // Collect extra tags
        let mut tags: Vec<Tag> = extra_tags.into_iter().collect();

        // Push received public key
        tags.push(Tag::public_key(*receiver));

        Self::new(Kind::GiftWrap, content)
            .tags(tags)
            .custom_created_at(Timestamp::tweaked(nip59::RANGE_RANDOM_TIMESTAMP_TWEAK))
            .sign_with_keys(&keys)
    }

    /// Gift Wrap
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/59.md>
    #[inline]
    #[cfg(all(feature = "std", feature = "nip59"))]
    pub async fn gift_wrap<T, I>(
        signer: &T,
        receiver: &PublicKey,
        rumor: EventBuilder,
        extra_tags: I,
    ) -> Result<Event, Error>
    where
        T: NostrSigner,
        I: IntoIterator<Item = Tag>,
    {
        let seal: Event = Self::seal(signer, receiver, rumor)
            .await?
            .sign(signer)
            .await?;
        Self::gift_wrap_from_seal(receiver, &seal, extra_tags)
    }

    /// Private Direct message rumor
    ///
    /// You probably are looking for [`EventBuilder::private_msg`] method.
    ///
    /// <div class="warning">
    /// This constructor compose ONLY the rumor for the private direct message!
    /// NOT USE THIS IF YOU DON'T KNOW WHAT YOU ARE DOING!
    /// </div>
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/17.md>
    #[inline]
    #[cfg(feature = "nip59")]
    pub fn private_msg_rumor<S>(receiver: PublicKey, message: S) -> Self
    where
        S: Into<String>,
    {
        Self::new(Kind::PrivateDirectMessage, message).tags([Tag::public_key(receiver)])
    }

    /// Private Direct message
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/17.md>
    #[inline]
    #[cfg(all(feature = "std", feature = "nip59"))]
    pub async fn private_msg<T, S, I>(
        signer: &T,
        receiver: PublicKey,
        message: S,
        rumor_extra_tags: I,
    ) -> Result<Event, Error>
    where
        T: NostrSigner,
        S: Into<String>,
        I: IntoIterator<Item = Tag>,
    {
        let rumor: Self = Self::private_msg_rumor(receiver, message).tags(rumor_extra_tags);
        Self::gift_wrap(signer, &receiver, rumor, []).await
    }

    /// Mute list
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn mute_list(list: MuteList) -> Self {
        let tags: Vec<Tag> = list.into();
        Self::new(Kind::MuteList, "").tags(tags)
    }

    /// Pinned notes
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn pinned_notes<I>(ids: I) -> Self
    where
        I: IntoIterator<Item = EventId>,
    {
        Self::new(Kind::PinList, "").tags(ids.into_iter().map(Tag::event))
    }

    /// Bookmarks
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn bookmarks(list: Bookmarks) -> Self {
        let tags: Vec<Tag> = list.into();
        Self::new(Kind::Bookmarks, "").tags(tags)
    }

    /// Communities
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn communities<I>(communities: I) -> Self
    where
        I: IntoIterator<Item = Coordinate>,
    {
        Self::new(Kind::Communities, "").tags(communities.into_iter().map(Tag::from))
    }

    /// Public chats
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn public_chats<I>(chat: I) -> Self
    where
        I: IntoIterator<Item = EventId>,
    {
        Self::new(Kind::PublicChats, "").tags(chat.into_iter().map(Tag::event))
    }

    /// Blocked relays
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn blocked_relays<I>(relay: I) -> Self
    where
        I: IntoIterator<Item = RelayUrl>,
    {
        Self::new(Kind::BlockedRelays, "").tags(
            relay
                .into_iter()
                .map(|r| Tag::from_standardized_without_cell(TagStandard::Relay(r))),
        )
    }

    /// Search relays
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn search_relays<I>(relay: I) -> Self
    where
        I: IntoIterator<Item = RelayUrl>,
    {
        Self::new(Kind::SearchRelays, "").tags(
            relay
                .into_iter()
                .map(|r| Tag::from_standardized_without_cell(TagStandard::Relay(r))),
        )
    }

    /// Interests
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn interests(list: Interests) -> Self {
        let tags: Vec<Tag> = list.into();
        Self::new(Kind::Interests, "").tags(tags)
    }

    /// Emojis
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    #[inline]
    pub fn emojis(list: Emojis) -> Self {
        let tags: Vec<Tag> = list.into();
        Self::new(Kind::Emojis, "").tags(tags)
    }

    /// Follow set
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    pub fn follow_set<ID, I>(identifier: ID, public_keys: I) -> Self
    where
        ID: Into<String>,
        I: IntoIterator<Item = PublicKey>,
    {
        let tags: Vec<Tag> = vec![Tag::identifier(identifier)];
        Self::new(Kind::FollowSet, "").tags(
            tags.into_iter()
                .chain(public_keys.into_iter().map(Tag::public_key)),
        )
    }

    /// Relay set
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    pub fn relay_set<ID, I>(identifier: ID, relays: I) -> Self
    where
        ID: Into<String>,
        I: IntoIterator<Item = RelayUrl>,
    {
        let tags: Vec<Tag> = vec![Tag::identifier(identifier)];
        Self::new(Kind::RelaySet, "").tags(
            tags.into_iter().chain(
                relays
                    .into_iter()
                    .map(|r| Tag::from_standardized_without_cell(TagStandard::Relay(r))),
            ),
        )
    }

    /// Bookmark set
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    pub fn bookmarks_set<ID>(identifier: ID, list: Bookmarks) -> Self
    where
        ID: Into<String>,
    {
        let mut tags: Vec<Tag> = list.into();
        tags.push(Tag::identifier(identifier));
        Self::new(Kind::BookmarkSet, "").tags(tags)
    }

    /// Article Curation set
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    pub fn articles_curation_set<ID>(identifier: ID, list: ArticlesCuration) -> Self
    where
        ID: Into<String>,
    {
        let mut tags: Vec<Tag> = list.into();
        tags.push(Tag::identifier(identifier));
        Self::new(Kind::ArticlesCurationSet, "").tags(tags)
    }

    /// Videos Curation set
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    pub fn videos_curation_set<ID, I>(identifier: ID, video: I) -> Self
    where
        ID: Into<String>,
        I: IntoIterator<Item = Coordinate>,
    {
        let tags: Vec<Tag> = vec![Tag::identifier(identifier)];
        Self::new(Kind::VideosCurationSet, "").tags(
            tags.into_iter()
                .chain(video.into_iter().map(Tag::coordinate)),
        )
    }

    /// Interest set
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    pub fn interest_set<ID, I, S>(identifier: ID, hashtags: I) -> Self
    where
        ID: Into<String>,
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        let tags: Vec<Tag> = vec![Tag::identifier(identifier)];
        Self::new(Kind::InterestSet, "").tags(
            tags.into_iter()
                .chain(hashtags.into_iter().map(Tag::hashtag)),
        )
    }

    /// Emoji set
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/51.md>
    pub fn emoji_set<ID, I>(identifier: ID, emojis: I) -> Self
    where
        ID: Into<String>,
        I: IntoIterator<Item = (String, Url)>,
    {
        let tags: Vec<Tag> = vec![Tag::identifier(identifier)];
        Self::new(Kind::EmojiSet, "").tags(tags.into_iter().chain(emojis.into_iter().map(
            |(s, url)| {
                Tag::from_standardized_without_cell(TagStandard::Emoji { shortcode: s, url })
            },
        )))
    }

    /// Label
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/32.md>
    pub fn label<S, I>(namespace: S, labels: I) -> Self
    where
        S: Into<String>,
        I: IntoIterator<Item = String>,
    {
        let namespace: String = namespace.into();
        let labels: Vec<String> = labels.into_iter().chain([namespace.clone()]).collect();
        Self::new(Kind::Label, "").tags([
            Tag::from_standardized_without_cell(TagStandard::LabelNamespace(namespace)),
            Tag::from_standardized_without_cell(TagStandard::Label(labels)),
        ])
    }

    /// Git Repository Announcement
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/34.md>
    #[inline]
    pub fn git_repository_announcement(announcement: GitRepositoryAnnouncement) -> Self {
        announcement.to_event_builder()
    }

    /// Git Issue
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/34.md>
    #[inline]
    pub fn git_issue(issue: GitIssue) -> Self {
        issue.to_event_builder()
    }

    /// Git Patch
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/34.md>
    #[inline]
    pub fn git_patch(patch: GitPatch) -> Self {
        patch.to_event_builder()
    }
}

#[cfg(test)]
mod tests {
    #[cfg(feature = "std")]
    use core::str::FromStr;

    use super::*;
    #[cfg(feature = "std")]
    use crate::SecretKey;

    #[test]
    #[cfg(feature = "std")]
    fn round_trip() {
        let keys = Keys::new(
            SecretKey::from_str("6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e")
                .unwrap(),
        );

        let event = EventBuilder::text_note("hello")
            .sign_with_keys(&keys)
            .unwrap();

        let serialized = event.as_json();
        let deserialized = Event::from_json(serialized).unwrap();

        assert_eq!(event, deserialized);
    }

    #[test]
    #[cfg(feature = "nip57")]
    fn test_zap_event_builder() {
        let bolt11 = "lnbc10u1p3unwfusp5t9r3yymhpfqculx78u027lxspgxcr2n2987mx2j55nnfs95nxnzqpp5jmrh92pfld78spqs78v9euf2385t83uvpwk9ldrlvf6ch7tpascqhp5zvkrmemgth3tufcvflmzjzfvjt023nazlhljz2n9hattj4f8jq8qxqyjw5qcqpjrzjqtc4fc44feggv7065fqe5m4ytjarg3repr5j9el35xhmtfexc42yczarjuqqfzqqqqqqqqlgqqqqqqgq9q9qxpqysgq079nkq507a5tw7xgttmj4u990j7wfggtrasah5gd4ywfr2pjcn29383tphp4t48gquelz9z78p4cq7ml3nrrphw5w6eckhjwmhezhnqpy6gyf0";
        let preimage = Some("5d006d2cf1e73c7148e7519a4c68adc81642ce0e25a432b2434c99f97344c15f");
        let zap_request_json = String::from("{\"pubkey\":\"32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245\",\"content\":\"\",\"id\":\"d9cc14d50fcb8c27539aacf776882942c1a11ea4472f8cdec1dea82fab66279d\",\"created_at\":1674164539,\"sig\":\"77127f636577e9029276be060332ea565deaf89ff215a494ccff16ae3f757065e2bc59b2e8c113dd407917a010b3abd36c8d7ad84c0e3ab7dab3a0b0caa9835d\",\"kind\":9734,\"tags\":[[\"e\",\"3624762a1274dd9636e0c552b53086d70bc88c165bc4dc0f9e836a1eaf86c3b8\"],[\"p\",\"32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245\"],[\"relays\",\"wss://relay.damus.io\",\"wss://nostr-relay.wlvs.space\",\"wss://nostr.fmt.wiz.biz\",\"wss://relay.nostr.bg\",\"wss://nostr.oxtr.dev\",\"wss://nostr.v0l.io\",\"wss://brb.io\",\"wss://nostr.bitcoiner.social\",\"ws://monad.jb55.com:8080\",\"wss://relay.snort.social\"]]}");
        let zap_request_event: Event = Event::from_json(zap_request_json).unwrap();
        let event_builder = EventBuilder::zap_receipt(bolt11, preimage, &zap_request_event);

        assert_eq!(6, event_builder.tags.len());

        let has_preimage_tag = event_builder
            .tags
            .clone()
            .iter()
            .any(|t| t.kind() == TagKind::Preimage);

        assert!(has_preimage_tag);
    }

    #[test]
    #[cfg(feature = "nip57")]
    fn test_zap_event_builder_without_preimage() {
        let bolt11 = "lnbc10u1p3unwfusp5t9r3yymhpfqculx78u027lxspgxcr2n2987mx2j55nnfs95nxnzqpp5jmrh92pfld78spqs78v9euf2385t83uvpwk9ldrlvf6ch7tpascqhp5zvkrmemgth3tufcvflmzjzfvjt023nazlhljz2n9hattj4f8jq8qxqyjw5qcqpjrzjqtc4fc44feggv7065fqe5m4ytjarg3repr5j9el35xhmtfexc42yczarjuqqfzqqqqqqqqlgqqqqqqgq9q9qxpqysgq079nkq507a5tw7xgttmj4u990j7wfggtrasah5gd4ywfr2pjcn29383tphp4t48gquelz9z78p4cq7ml3nrrphw5w6eckhjwmhezhnqpy6gyf0";
        let preimage: Option<&str> = None;
        let zap_request_json = String::from("{\"pubkey\":\"32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245\",\"content\":\"\",\"id\":\"d9cc14d50fcb8c27539aacf776882942c1a11ea4472f8cdec1dea82fab66279d\",\"created_at\":1674164539,\"sig\":\"77127f636577e9029276be060332ea565deaf89ff215a494ccff16ae3f757065e2bc59b2e8c113dd407917a010b3abd36c8d7ad84c0e3ab7dab3a0b0caa9835d\",\"kind\":9734,\"tags\":[[\"e\",\"3624762a1274dd9636e0c552b53086d70bc88c165bc4dc0f9e836a1eaf86c3b8\"],[\"p\",\"32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245\"],[\"relays\",\"wss://relay.damus.io\",\"wss://nostr-relay.wlvs.space\",\"wss://nostr.fmt.wiz.biz\",\"wss://relay.nostr.bg\",\"wss://nostr.oxtr.dev\",\"wss://nostr.v0l.io\",\"wss://brb.io\",\"wss://nostr.bitcoiner.social\",\"ws://monad.jb55.com:8080\",\"wss://relay.snort.social\"]]}");
        let zap_request_event = Event::from_json(zap_request_json).unwrap();
        let event_builder = EventBuilder::zap_receipt(bolt11, preimage, &zap_request_event);

        assert_eq!(5, event_builder.tags.len());
        let has_preimage_tag = event_builder
            .tags
            .clone()
            .iter()
            .any(|t| t.kind() == TagKind::Preimage);

        assert!(!has_preimage_tag);
    }

    #[test]
    fn test_badge_definition_event_builder_badge_id_only() {
        let badge_id = String::from("bravery");
        let event_builder =
            EventBuilder::define_badge(badge_id, None, None, None, None, Vec::new());

        let has_id =
            event_builder.tags.clone().iter().any(|t| {
                t.kind() == TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::D))
            });
        assert!(has_id);

        assert_eq!(Kind::BadgeDefinition, event_builder.kind);
    }

    #[test]
    fn test_badge_definition_event_builder_full() {
        let badge_id = String::from("bravery");
        let name = Some(String::from("Bravery"));
        let description = Some(String::from("Brave pubkey"));
        let image_url = Some(Url::parse("https://nostr.build/someimage/1337").unwrap());
        let image_size = Some(ImageDimensions::new(1024, 1024));
        let thumbs = vec![(
            Url::parse("https://nostr.build/somethumbnail/1337").unwrap(),
            Some(ImageDimensions::new(256, 256)),
        )];

        let event_builder =
            EventBuilder::define_badge(badge_id, name, description, image_url, image_size, thumbs);

        let has_id =
            event_builder.tags.clone().iter().any(|t| {
                t.kind() == TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::D))
            });
        assert!(has_id);

        assert_eq!(Kind::BadgeDefinition, event_builder.kind);
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_badge_award_event_builder() {
        let keys = Keys::generate();
        let pub_key = keys.public_key();

        // Set up badge definition
        let badge_definition_event_json = format!(
            r#"{{
                "id": "4d16822726cefcb45768988c6451b6de5a20b504b8df85efe0808caf346e167c",
                "pubkey": "{}",
                "created_at": 1677921759,
                "kind": 30009,
                "tags": [
                  ["d", "bravery"],
                  ["name", "Bravery"],
                  ["description", "A brave soul"]
                ],
                "content": "",
                "sig": "cf154350a615f0355d165b52c7ecccce563d9a935801181e9016d077f38d31a1dc992a757ef8d652a416885f33d836cf408c79f5d983d6f1f03c966ace946d59"
              }}"#,
            pub_key
        );
        let badge_definition_event: Event =
            serde_json::from_str(&badge_definition_event_json).unwrap();

        // Set up goal event
        let example_event_json = format!(
            r#"{{
            "content": "",
            "id": "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
            "kind": 8,
            "pubkey": "{}",
            "sig": "fd0954de564cae9923c2d8ee9ab2bf35bc19757f8e328a978958a2fcc950eaba0754148a203adec29b7b64080d0cf5a32bebedd768ea6eb421a6b751bb4584a8",
            "created_at": 1671739153,
            "tags": [
                ["a", "30009:{}:bravery"],
                ["p", "32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245"],
                ["p", "232a4ba3df82ccc252a35abee7d87d1af8fc3cc749e4002c3691434da692b1df"]
            ]
            }}"#,
            pub_key, pub_key
        );
        let example_event: Event = serde_json::from_str(&example_event_json).unwrap();

        // Create new event with the event builder
        let awarded_pubkeys = vec![
            PublicKey::from_str("32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245")
                .unwrap(),
            PublicKey::from_str("232a4ba3df82ccc252a35abee7d87d1af8fc3cc749e4002c3691434da692b1df")
                .unwrap(),
        ];
        let event_builder: Event =
            EventBuilder::award_badge(&badge_definition_event, awarded_pubkeys)
                .unwrap()
                .sign_with_keys(&keys)
                .unwrap();

        assert_eq!(event_builder.kind, Kind::BadgeAward);
        assert_eq!(event_builder.content, "");
        assert_eq!(event_builder.tags, example_event.tags);
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_profile_badges() {
        // The pubkey used for profile badges event
        let keys = Keys::generate();
        let pub_key = keys.public_key();

        // Create badge 1
        let badge_one_keys = Keys::generate();
        let badge_one_pubkey = badge_one_keys.public_key();

        let awarded_pubkeys = vec![
            pub_key,
            PublicKey::from_str("232a4ba3df82ccc252a35abee7d87d1af8fc3cc749e4002c3691434da692b1df")
                .unwrap(),
        ];
        let bravery_badge_event =
            EventBuilder::define_badge("bravery", None, None, None, None, Vec::new())
                .sign_with_keys(&badge_one_keys)
                .unwrap();
        let bravery_badge_award =
            EventBuilder::award_badge(&bravery_badge_event, awarded_pubkeys.clone())
                .unwrap()
                .sign_with_keys(&badge_one_keys)
                .unwrap();

        // Badge 2
        let badge_two_keys = Keys::generate();
        let badge_two_pubkey = badge_two_keys.public_key();

        let honor_badge_event =
            EventBuilder::define_badge("honor", None, None, None, None, Vec::new())
                .sign_with_keys(&badge_two_keys)
                .unwrap();
        let honor_badge_award =
            EventBuilder::award_badge(&honor_badge_event, awarded_pubkeys.clone())
                .unwrap()
                .sign_with_keys(&badge_two_keys)
                .unwrap();

        let example_event_json = format!(
            r#"{{
            "content":"",
            "id": "378f145897eea948952674269945e88612420db35791784abf0616b4fed56ef7",
            "kind": 30008,
            "pubkey": "{pub_key}",
            "sig":"fd0954de564cae9923c2d8ee9ab2bf35bc19757f8e328a978958a2fcc950eaba0754148a203adec29b7b64080d0cf5a32bebedd768ea6eb421a6b751bb4584a8",
            "created_at":1671739153,
            "tags":[
                ["d", "profile_badges"],
                ["a", "30009:{badge_one_pubkey}:bravery"],
                ["e", "{}"],
                ["a", "30009:{badge_two_pubkey}:honor"],
                ["e", "{}"]
            ]
            }}"#,
            bravery_badge_award.id, honor_badge_award.id,
        );
        let example_event: Event = serde_json::from_str(&example_event_json).unwrap();

        let badge_definitions = vec![bravery_badge_event, honor_badge_event];
        let badge_awards = vec![bravery_badge_award, honor_badge_award];
        let profile_badges =
            EventBuilder::profile_badges(badge_definitions, badge_awards, &pub_key)
                .unwrap()
                .sign_with_keys(&keys)
                .unwrap();

        assert_eq!(profile_badges.kind, Kind::ProfileBadges);
        assert_eq!(profile_badges.tags, example_event.tags);
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    #[bench]
    pub fn builder_to_event(bh: &mut Bencher) {
        let keys = Keys::generate();
        bh.iter(|| {
            black_box(EventBuilder::text_note("hello", []).sign_with_keys(&keys)).unwrap();
        });
    }
}

================
File: src/event/id.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Event Id

use alloc::string::{String, ToString};
use core::fmt;
use core::str::FromStr;

use bitcoin::hashes::sha256::Hash as Sha256Hash;
use bitcoin::hashes::Hash;
use serde::{Deserialize, Deserializer, Serialize};
use serde_json::{json, Value};

use super::{Kind, Tag};
use crate::nips::nip13;
use crate::nips::nip19::FromBech32;
use crate::nips::nip21::NostrURI;
use crate::util::hex;
use crate::{PublicKey, Timestamp};

/// [`EventId`] error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Hex decode error
    Hex(hex::Error),
    /// Invalid event ID
    InvalidEventId,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Hex(e) => write!(f, "Hex: {e}"),
            Self::InvalidEventId => write!(f, "Invalid event ID"),
        }
    }
}

impl From<hex::Error> for Error {
    fn from(e: hex::Error) -> Self {
        Self::Hex(e)
    }
}

/// Event ID
///
/// 32-bytes lowercase hex-encoded sha256 of the serialized event data
///
/// <https://github.com/nostr-protocol/nips/blob/master/01.md>
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EventId([u8; 32]);

impl fmt::Debug for EventId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "EventId({})", self.to_hex())
    }
}

impl EventId {
    /// Event ID len
    pub const LEN: usize = 32;

    /// Generate [`EventId`]
    pub fn new(
        public_key: &PublicKey,
        created_at: &Timestamp,
        kind: &Kind,
        tags: &[Tag],
        content: &str,
    ) -> Self {
        let json: Value = json!([0, public_key, created_at, kind, tags, content]);
        let event_str: String = json.to_string();
        let hash: Sha256Hash = Sha256Hash::hash(event_str.as_bytes());
        Self::from_byte_array(hash.to_byte_array())
    }

    /// Construct event ID from 32-byte array
    #[inline]
    pub const fn from_byte_array(bytes: [u8; Self::LEN]) -> Self {
        Self(bytes)
    }

    /// All zeros
    #[inline]
    pub const fn all_zeros() -> Self {
        Self::from_byte_array([0u8; Self::LEN])
    }

    /// Try to parse [EventId] from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    pub fn parse<S>(id: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let id: &str = id.as_ref();

        // Try from hex
        if let Ok(id) = Self::from_hex(id) {
            return Ok(id);
        }

        // Try from bech32
        if let Ok(id) = Self::from_bech32(id) {
            return Ok(id);
        }

        // Try from NIP21 URI
        if let Ok(id) = Self::from_nostr_uri(id) {
            return Ok(id);
        }

        Err(Error::InvalidEventId)
    }

    /// Parse from hex string
    #[inline]
    pub fn from_hex<S>(hex: S) -> Result<Self, Error>
    where
        S: AsRef<[u8]>,
    {
        let mut bytes: [u8; Self::LEN] = [0u8; Self::LEN];
        hex::decode_to_slice(hex, &mut bytes)?;
        Ok(Self::from_byte_array(bytes))
    }

    /// Parse from bytes
    #[inline]
    pub fn from_slice(slice: &[u8]) -> Result<Self, Error> {
        // Check len
        if slice.len() != Self::LEN {
            return Err(Error::InvalidEventId);
        }

        // Copy bytes
        let mut bytes: [u8; Self::LEN] = [0u8; Self::LEN];
        bytes.copy_from_slice(slice);

        // Construct
        Ok(Self::from_byte_array(bytes))
    }

    /// Get as bytes
    #[inline]
    pub fn as_bytes(&self) -> &[u8; Self::LEN] {
        &self.0
    }

    /// Consume and get bytes
    #[inline]
    pub fn to_bytes(self) -> [u8; Self::LEN] {
        self.0
    }

    /// Get as hex string
    #[inline]
    pub fn to_hex(&self) -> String {
        hex::encode(self.as_bytes())
    }

    /// Check POW
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/13.md>
    #[inline]
    pub fn check_pow(&self, difficulty: u8) -> bool {
        nip13::get_leading_zero_bits(self.as_bytes()) >= difficulty
    }
}

impl FromStr for EventId {
    type Err = Error;

    /// Try to parse [EventId] from `hex` or `bech32`
    #[inline]
    fn from_str(id: &str) -> Result<Self, Self::Err> {
        Self::parse(id)
    }
}

impl AsRef<[u8]> for EventId {
    fn as_ref(&self) -> &[u8] {
        self.as_bytes()
    }
}

impl AsRef<[u8; EventId::LEN]> for EventId {
    fn as_ref(&self) -> &[u8; EventId::LEN] {
        self.as_bytes()
    }
}

impl fmt::LowerHex for EventId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_hex())
    }
}

impl fmt::Display for EventId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::LowerHex::fmt(self, f)
    }
}

// Required to keep clean the methods of `Filter` struct
impl From<EventId> for String {
    fn from(event_id: EventId) -> Self {
        event_id.to_hex()
    }
}

impl From<EventId> for Tag {
    fn from(event_id: EventId) -> Self {
        Tag::event(event_id)
    }
}

impl Serialize for EventId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_hex())
    }
}

impl<'de> Deserialize<'de> for EventId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let id: String = String::deserialize(deserializer)?;
        Self::parse(id).map_err(serde::de::Error::custom)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_check_pow() {
        let id =
            EventId::from_hex("2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45")
                .unwrap();
        assert!(!id.check_pow(16));

        // POW 20
        let id =
            EventId::from_hex("00000340cb60be5829fbf2712a285f12cf89e5db951c5303b731651f0d71ac1b")
                .unwrap();
        assert!(id.check_pow(16));
        assert!(id.check_pow(20));
        assert!(!id.check_pow(25));
    }
}

#[cfg(bench)]
mod benches {
    use super::*;
    use crate::test::{black_box, Bencher};

    const ID: &str = "2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45";

    #[bench]
    pub fn parse_event_id_from_hex(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(EventId::from_hex(ID)).unwrap();
        });
    }
}

================
File: src/event/kind.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Kind

use core::cmp::Ordering;
use core::fmt;
use core::hash::{Hash, Hasher};
use core::num::ParseIntError;
use core::ops::{Add, Range};
use core::str::FromStr;

use serde::de::{Deserialize, Deserializer, Error, Visitor};
use serde::ser::{Serialize, Serializer};

/// NIP90 - Job request range
pub const NIP90_JOB_REQUEST_RANGE: Range<u16> = 5_000..6_000;
/// NIP90 - Job result range
pub const NIP90_JOB_RESULT_RANGE: Range<u16> = 6_000..7_000;
/// Regular range
pub const REGULAR_RANGE: Range<u16> = 1_000..10_000;
/// Replaceable range
pub const REPLACEABLE_RANGE: Range<u16> = 10_000..20_000;
/// Ephemeral range
pub const EPHEMERAL_RANGE: Range<u16> = 20_000..30_000;
/// Parameterized replaceable range
pub const PARAMETERIZED_REPLACEABLE_RANGE: Range<u16> = 30_000..40_000;

macro_rules! kind_variants {
    ($($name:ident => $value:expr, $doc:expr),* $(,)?) => {
        /// Event kind
        ///
        /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
        #[derive(Debug, Clone, Copy)]
        pub enum Kind {
            $(
                #[doc = $doc]
                $name,
            )*
            /// Represents a job request event (NIP90).
            JobRequest(u16),
            /// Represents a job result event (NIP90).
            JobResult(u16),
            /// Represents a regular event.
            Regular(u16),
            /// Represents a replaceable event.
            Replaceable(u16),
            /// Represents an ephemeral event.
            Ephemeral(u16),
            /// Represents a parameterized replaceable event.
            ParameterizedReplaceable(u16),
            /// Represents a custom event.
            Custom(u16),
        }

        impl From<u16> for Kind {
            fn from(u: u16) -> Self {
                match u {
                    $(
                        $value => Self::$name,
                    )*
                    x if (NIP90_JOB_REQUEST_RANGE).contains(&x) => Self::JobRequest(x),
                    x if (NIP90_JOB_RESULT_RANGE).contains(&x) => Self::JobResult(x),
                    x if (REGULAR_RANGE).contains(&x) => Self::Regular(x),
                    x if (REPLACEABLE_RANGE).contains(&x) => Self::Replaceable(x),
                    x if (EPHEMERAL_RANGE).contains(&x) => Self::Ephemeral(x),
                    x if (PARAMETERIZED_REPLACEABLE_RANGE).contains(&x) => Self::ParameterizedReplaceable(x),
                    x => Self::Custom(x),
                }
            }
        }

        impl From<Kind> for u16 {
            fn from(e: Kind) -> u16 {
                match e {
                    $(
                        Kind::$name => $value,
                    )*
                    Kind::JobRequest(u) => u,
                    Kind::JobResult(u) => u,
                    Kind::Regular(u) => u,
                    Kind::Replaceable(u) => u,
                    Kind::Ephemeral(u) => u,
                    Kind::ParameterizedReplaceable(u) => u,
                    Kind::Custom(u) => u,
                }
            }
        }
    };
}

kind_variants! {
    Metadata => 0, "Metadata (NIP01 and NIP05)",
    TextNote => 1, "Short Text Note (NIP01)",
    RecommendRelay => 2, "Recommend Relay (NIP01 - deprecated)",
    ContactList => 3, "Contacts (NIP02)",
    OpenTimestamps => 1040, "OpenTimestamps Attestations (NIP03)",
    EncryptedDirectMessage => 4, "Encrypted Direct Messages (NIP04)",
    EventDeletion => 5, "Event Deletion (NIP09)",
    Repost => 6, "Repost (NIP18)",
    GenericRepost => 16, "Generic Repost (NIP18)",
    Comment => 1111, "Comment (NIP22)",
    Reaction => 7, "Reaction (NIP25)",
    BadgeAward => 8, "Badge Award (NIP58)",
    ChannelCreation => 40, "Channel Creation (NIP28)",
    ChannelMetadata => 41, "Channel Metadata (NIP28)",
    ChannelMessage => 42, "Channel Message (NIP28)",
    ChannelHideMessage => 43, "Channel Hide Message (NIP28)",
    ChannelMuteUser => 44, "Channel Mute User (NIP28)",
    PublicChatReserved45 => 45, "Public Chat Reserved (NIP28)",
    PublicChatReserved46 => 46, "Public Chat Reserved (NIP28)",
    PublicChatReserved47 => 47, "Public Chat Reserved (NIP28)",
    PublicChatReserved48 => 48, "Public Chat Reserved (NIP28)",
    PublicChatReserved49 => 49, "Public Chat Reserved (NIP28)",
    MlsKeyPackage => 443, "MLS Key Package (NIP104)",
    MlsWelcome => 444, "MLS Welcome (NIP104)",
    MlsGroupMessage => 445, "MLS Group Message (NIP104)",
    GitPatch => 1617, "Git Patch (NIP34)",
    GitIssue => 1621, "Git Issue (NIP34)",
    GitReply => 1622, "Git Reply (NIP34)",
    GitStatusOpen => 1630, "Open Status of Git Patch or Issue (NIP34)",
    GitStatusApplied => 1631, "Applied / Merged Status of Git Patch or Resolved Status of Git Issue (NIP34)",
    GitStatusClosed => 1632, "Closed Status of Git Patch or Issue (NIP34)",
    GitStatusDraft => 1633, "Draft Status of Git Patch or Issue (NIP34)",
    WalletConnectInfo => 13194, "Wallet Service Info (NIP47)",
    Reporting => 1984, "Reporting (NIP56)",
    Label => 1985, "Label <https://github.com/nostr-protocol/nips/blob/master/32.md>",
    ZapPrivateMessage => 9733, "Zap Private Message (NIP57)",
    ZapRequest => 9734, "Zap Request (NIP57)",
    ZapReceipt => 9735, "Zap Receipt (NIP57)",
    MuteList => 10000, "Mute List <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    PinList => 10001, "Pin List <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    Bookmarks => 10003, "Bookmarks <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    Communities => 10004, "Communities <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    PublicChats => 10005, "Public Chats <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    BlockedRelays => 10006, "Blocked Relays <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    SearchRelays => 10007, "Search Relays <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    SimpleGroups => 10009, "Simple Groups <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    Interests => 10015, "Interests <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    Emojis => 10030, "Emojis <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    InboxRelays => 10050, "Inbox Relays <https://github.com/nostr-protocol/nips/blob/master/17.md>",
    MlsKeyPackageRelays => 10051, "MLS Key Package Relays (NIP104)",
    RelayList => 10002, "Relay List Metadata (NIP65)",
    Authentication => 22242, "Client Authentication (NIP42)",
    WalletConnectRequest => 23194, "Wallet Connect Request (NIP47)",
    WalletConnectResponse => 23195, "Wallet Connect Response (NIP47)",
    NostrConnect => 24133, "Nostr Connect (NIP46)",
    LiveEvent => 30311, "Live Event (NIP53)",
    LiveEventMessage => 1311, "Live Event Message (NIP53)",
    ProfileBadges => 30008, "Profile Badges (NIP58)",
    BadgeDefinition => 30009, "Badge Definition (NIP58)",
    Seal => 13, "Seal <https://github.com/nostr-protocol/nips/blob/master/59.md>",
    GiftWrap => 1059, "Gift Wrap <https://github.com/nostr-protocol/nips/blob/master/59.md>",
    PrivateDirectMessage => 14, "Private Direct message <https://github.com/nostr-protocol/nips/blob/master/17.md>",
    SetStall => 30017, "Set stall (NIP15)",
    SetProduct => 30018, "Set product (NIP15)",
    JobFeedback => 7000, "Job Feedback (NIP90)",
    FollowSet => 30000, "Follow Set <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    RelaySet => 30002, "Relay Set <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    BookmarkSet => 30003, "Bookmark Set <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    ArticlesCurationSet => 30004, "Articles Curation Set <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    VideosCurationSet => 30005, "Videos Curation Set <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    InterestSet => 30015, "Interest Set <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    EmojiSet => 30030, "Emoji Set <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    ReleaseArtifactSet => 30063, "Release Artifact Set <https://github.com/nostr-protocol/nips/blob/master/51.md>",
    LongFormTextNote => 30023, "Long-form Text Note (NIP23)",
    GitRepoAnnouncement => 30617, "Git Repository Announcement (NIP34)",
    FileMetadata => 1063, "File Metadata (NIP94)",
    HttpAuth => 27235, "HTTP Auth (NIP98)",
    ApplicationSpecificData => 30078, "Application-specific Data (NIP78)",
}

impl PartialEq<Kind> for Kind {
    fn eq(&self, other: &Kind) -> bool {
        self.as_u16() == other.as_u16()
    }
}

impl Eq for Kind {}

impl PartialOrd for Kind {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Kind {
    fn cmp(&self, other: &Self) -> Ordering {
        self.as_u16().cmp(&other.as_u16())
    }
}

impl Hash for Kind {
    fn hash<H>(&self, state: &mut H)
    where
        H: Hasher,
    {
        self.as_u16().hash(state);
    }
}

impl Kind {
    /// Construct from 16-bit unsigned integer
    #[inline]
    pub fn from_u16(kind: u16) -> Self {
        Self::from(kind)
    }

    /// Get as 16-bit unsigned integer
    #[inline]
    pub fn as_u16(&self) -> u16 {
        (*self).into()
    }

    /// Check if it's regular
    ///
    /// Regular means that event is expected to be stored by relays.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    pub fn is_regular(&self) -> bool {
        let kind: u16 = self.as_u16();

        // Exclude ALL param replaceable and ephemeral
        // Exclude PARTIALLY the replaceable
        if kind > 10_000 {
            return false;
        }

        REGULAR_RANGE.contains(&kind) || !self.is_replaceable()
    }

    /// Check if it's replaceable
    ///
    /// Replaceable means that, for each combination of `pubkey` and `kind`,
    /// only the latest event MUST be stored by relays, older versions MAY be discarded.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn is_replaceable(&self) -> bool {
        matches!(self, Kind::Metadata)
            || matches!(self, Kind::ContactList)
            || matches!(self, Kind::ChannelMetadata)
            || REPLACEABLE_RANGE.contains(&self.as_u16())
    }

    /// Check if it's ephemeral
    ///
    /// Ephemeral means that event is not expected to be stored by relays.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn is_ephemeral(&self) -> bool {
        EPHEMERAL_RANGE.contains(&self.as_u16())
    }

    /// Check if it's parameterized replaceable
    ///
    /// Parametrized replaceable means that, for each combination of `pubkey`, `kind` and the `d` tag's first value,
    /// only the latest event MUST be stored by relays, older versions MAY be discarded.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn is_parameterized_replaceable(&self) -> bool {
        PARAMETERIZED_REPLACEABLE_RANGE.contains(&self.as_u16())
    }

    /// Check if it's a NIP90 job request
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/90.md>
    #[inline]
    pub fn is_job_request(&self) -> bool {
        NIP90_JOB_REQUEST_RANGE.contains(&self.as_u16())
    }

    /// Check if it's a NIP90 job result
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/90.md>
    #[inline]
    pub fn is_job_result(&self) -> bool {
        NIP90_JOB_RESULT_RANGE.contains(&self.as_u16())
    }
}

impl fmt::Display for Kind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_u16())
    }
}

impl FromStr for Kind {
    type Err = ParseIntError;

    fn from_str(kind: &str) -> Result<Self, Self::Err> {
        let kind: u16 = kind.parse()?;
        Ok(Self::from(kind))
    }
}

impl Add<u16> for Kind {
    type Output = Self;

    fn add(self, rhs: u16) -> Self::Output {
        let kind: u16 = self.as_u16();
        Kind::from(kind + rhs)
    }
}

impl Serialize for Kind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_u16(self.as_u16())
    }
}

impl<'de> Deserialize<'de> for Kind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_u16(KindVisitor)
    }
}

struct KindVisitor;

impl Visitor<'_> for KindVisitor {
    type Value = Kind;

    fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "a 16-bit unsigned number (0-65535)")
    }

    fn visit_u16<E>(self, v: u16) -> Result<Self::Value, E>
    where
        E: Error,
    {
        Ok(Self::Value::from(v))
    }

    fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
    where
        E: Error,
    {
        Ok(Self::Value::from(v as u16))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_equal_kind() {
        assert_eq!(Kind::Custom(20100), Kind::Custom(20100));
        assert_eq!(Kind::Custom(20100), Kind::Ephemeral(20100));
        assert_eq!(Kind::TextNote, Kind::Custom(1));
        assert_eq!(Kind::ParameterizedReplaceable(30017), Kind::SetStall);
        assert_eq!(Kind::ParameterizedReplaceable(30018), Kind::SetProduct);
    }

    #[test]
    fn test_not_equal_kind() {
        assert_ne!(Kind::Custom(20100), Kind::Custom(2000));
        assert_ne!(Kind::Authentication, Kind::EncryptedDirectMessage);
        assert_ne!(Kind::TextNote, Kind::Custom(2));
    }

    #[test]
    fn test_kind_is_parameterized_replaceable() {
        assert!(Kind::ParameterizedReplaceable(32122).is_parameterized_replaceable());
        assert!(!Kind::ParameterizedReplaceable(1).is_parameterized_replaceable());
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    #[bench]
    pub fn parse_ephemeral_kind(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(Kind::from(29_999));
        });
    }

    #[bench]
    pub fn parse_kind(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(Kind::from(0));
        });
    }
}

================
File: src/event/mod.rs
================
// Copyright (c) 2021 Paul Miller
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Event

use alloc::borrow::Cow;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::cmp::Ordering;
use core::fmt;
use core::hash::{Hash, Hasher};
use core::str::FromStr;

use bitcoin::secp256k1::schnorr::Signature;
use bitcoin::secp256k1::{Message, Secp256k1, Verification};
use serde::ser::SerializeStruct;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json::Value;

pub mod builder;
pub mod id;
pub mod kind;
pub mod partial;
pub mod raw;
pub mod tag;
pub mod unsigned;

pub use self::builder::EventBuilder;
pub use self::id::EventId;
pub use self::kind::Kind;
pub use self::partial::{MissingPartialEvent, PartialEvent};
pub use self::tag::{Tag, TagKind, TagStandard, Tags};
pub use self::unsigned::UnsignedEvent;
use crate::nips::nip01::Coordinate;
use crate::types::metadata;
#[cfg(feature = "std")]
use crate::types::time::Instant;
use crate::types::time::TimeSupplier;
#[cfg(feature = "std")]
use crate::SECP256K1;
use crate::{JsonUtil, Metadata, PublicKey, Timestamp};

const ID: &str = "id";
const PUBKEY: &str = "pubkey";
const CREATED_AT: &str = "created_at";
const KIND: &str = "kind";
const TAGS: &str = "tags";
const CONTENT: &str = "content";
const SIG: &str = "sig";

/// [`Event`] error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Invalid signature
    InvalidSignature,
    /// Invalid event id
    InvalidId,
    /// Unknown JSON event key
    UnknownKey(String),
    /// Error serializing or deserializing JSON data
    Json(String),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidSignature => write!(f, "Invalid signature"),
            Self::InvalidId => write!(f, "Invalid event id"),
            Self::UnknownKey(key) => write!(f, "Unknown JSON event key: {key}"),
            Self::Json(e) => write!(f, "Json: {e}"),
        }
    }
}

impl From<serde_json::Error> for Error {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e.to_string())
    }
}

/// Nostr event
#[derive(Clone)]
pub struct Event {
    /// ID
    pub id: EventId,
    /// Author
    pub pubkey: PublicKey,
    /// UNIX timestamp (seconds)
    pub created_at: Timestamp,
    /// Kind
    pub kind: Kind,
    /// Tag list
    pub tags: Tags,
    /// Content
    pub content: String,
    /// Signature
    pub sig: Signature,
    /// JSON de/serialization order
    deser_order: Vec<EventKey>,
}

impl fmt::Debug for Event {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Event")
            .field(ID, &self.id)
            .field(PUBKEY, &self.pubkey)
            .field(CREATED_AT, &self.created_at)
            .field(KIND, &self.kind)
            .field(TAGS, &self.tags)
            .field(CONTENT, &self.content)
            .field(SIG, &self.sig)
            .finish()
    }
}

impl PartialEq for Event {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
            && self.pubkey == other.pubkey
            && self.created_at == other.created_at
            && self.kind == other.kind
            && self.tags == other.tags
            && self.content == other.content
            && self.sig == other.sig
    }
}

impl Eq for Event {}

impl PartialOrd for Event {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Event {
    fn cmp(&self, other: &Self) -> Ordering {
        if self.created_at != other.created_at {
            // Descending order
            // NOT EDIT, will break many things!!
            // If the change is required, search for EVENT_ORD_IMPL comment
            // in the code and adj things.
            self.created_at.cmp(&other.created_at).reverse()
        } else {
            self.id.cmp(&other.id)
        }
    }
}

impl Hash for Event {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.id.hash(state);
        self.pubkey.hash(state);
        self.created_at.hash(state);
        self.kind.hash(state);
        self.tags.hash(state);
        self.content.hash(state);
        self.sig.hash(state);
    }
}

impl Event {
    /// Compose event
    pub fn new<I, S>(
        id: EventId,
        public_key: PublicKey,
        created_at: Timestamp,
        kind: Kind,
        tags: I,
        content: S,
        sig: Signature,
    ) -> Self
    where
        I: IntoIterator<Item = Tag>,
        S: Into<String>,
    {
        Self {
            id,
            pubkey: public_key,
            created_at,
            kind,
            tags: Tags::new(tags.into_iter().collect()),
            content: content.into(),
            sig,
            deser_order: Vec::new(),
        }
    }

    /// Verify both [`EventId`] and [`Signature`]
    #[inline]
    #[cfg(feature = "std")]
    pub fn verify(&self) -> Result<(), Error> {
        self.verify_with_ctx(&SECP256K1)
    }

    /// Verify both [`EventId`] and [`Signature`]
    #[inline]
    pub fn verify_with_ctx<C>(&self, secp: &Secp256k1<C>) -> Result<(), Error>
    where
        C: Verification,
    {
        // Verify ID
        if !self.verify_id() {
            return Err(Error::InvalidId);
        }

        // Verify signature
        if !self.verify_signature_with_ctx(secp) {
            return Err(Error::InvalidSignature);
        }

        Ok(())
    }

    /// Verify if the [`EventId`] it's composed correctly
    pub fn verify_id(&self) -> bool {
        let id: EventId = EventId::new(
            &self.pubkey,
            &self.created_at,
            &self.kind,
            self.tags.as_slice(),
            &self.content,
        );
        id == self.id
    }

    /// Verify only event [`Signature`]
    #[inline]
    #[cfg(feature = "std")]
    pub fn verify_signature(&self) -> bool {
        self.verify_signature_with_ctx(&SECP256K1)
    }

    /// Verify event signature
    #[inline]
    pub fn verify_signature_with_ctx<C>(&self, secp: &Secp256k1<C>) -> bool
    where
        C: Verification,
    {
        let message: Message = Message::from_digest(self.id.to_bytes());
        secp.verify_schnorr(&self.sig, &message, &self.pubkey)
            .is_ok()
    }

    /// Check POW
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/13.md>
    #[inline]
    pub fn check_pow(&self, difficulty: u8) -> bool {
        self.id.check_pow(difficulty)
    }

    /// Returns `true` if the event has an expiration tag that is expired.
    /// If an event has no expiration tag, then it will return `false`.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/40.md>
    #[inline]
    #[cfg(feature = "std")]
    pub fn is_expired(&self) -> bool {
        let now: Instant = Instant::now();
        self.is_expired_with_supplier(&now)
    }

    /// Returns `true` if the event has an expiration tag that is expired.
    /// If an event has no expiration tag, then it will return `false`.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/40.md>
    #[inline]
    pub fn is_expired_with_supplier<T>(&self, supplier: &T) -> bool
    where
        T: TimeSupplier,
    {
        let now: Timestamp = Timestamp::now_with_supplier(supplier);
        self.is_expired_at(&now)
    }

    /// Returns `true` if the event has an expiration tag that is expired.
    /// If an event has no expiration tag, then it will return `false`.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/40.md>
    #[inline]
    pub fn is_expired_at(&self, now: &Timestamp) -> bool {
        if let Some(timestamp) = self.tags.expiration() {
            return timestamp < now;
        }
        false
    }

    /// Get the coordinate of this event
    ///
    /// Return a coordinate only if the event kind is [`Kind::Replaceable`] or [`Kind::ParameterizedReplaceable`]
    pub fn coordinate(&self) -> Option<Coordinate> {
        if self.kind.is_replaceable() || self.kind.is_parameterized_replaceable() {
            let mut coordinate: Coordinate = Coordinate::new(self.kind, self.pubkey);

            if let Some(identifier) = self.tags.identifier() {
                coordinate = coordinate.identifier(identifier);
            }

            return Some(coordinate);
        }

        None
    }

    /// Check if it's a protected event
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/70.md>
    #[inline]
    pub fn is_protected(&self) -> bool {
        self.tags.find_standardized(TagKind::Protected).is_some()
    }
}

impl JsonUtil for Event {
    type Err = Error;

    /// Deserialize [`Event`] from JSON
    ///
    /// **This method NOT verify the signature!**
    #[inline]
    fn from_json<T>(json: T) -> Result<Self, Self::Err>
    where
        T: AsRef<[u8]>,
    {
        Ok(serde_json::from_slice(json.as_ref())?)
    }
}

impl TryFrom<&Event> for Metadata {
    type Error = metadata::Error;

    fn try_from(event: &Event) -> Result<Self, Self::Error> {
        Metadata::from_json(&event.content)
    }
}

/// Supported event keys
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
enum EventKey {
    Id,
    PubKey,
    CreatedAt,
    Kind,
    Tags,
    Content,
    Sig,
}

impl FromStr for EventKey {
    type Err = Error;

    fn from_str(key: &str) -> Result<Self, Self::Err> {
        match key {
            ID => Ok(Self::Id),
            PUBKEY => Ok(Self::PubKey),
            CREATED_AT => Ok(Self::CreatedAt),
            KIND => Ok(Self::Kind),
            TAGS => Ok(Self::Tags),
            CONTENT => Ok(Self::Content),
            SIG => Ok(Self::Sig),
            k => Err(Error::UnknownKey(k.to_string())),
        }
    }
}

/// Struct used for de/serialization of [`Event`]
#[derive(Serialize, Deserialize)]
struct EventIntermediate<'a> {
    pub id: Cow<'a, EventId>,
    pub pubkey: Cow<'a, PublicKey>,
    pub created_at: Cow<'a, Timestamp>,
    pub kind: Cow<'a, Kind>,
    pub tags: Cow<'a, Tags>,
    pub content: Cow<'a, String>,
    pub sig: Cow<'a, Signature>,
}

impl<'a> From<&'a Event> for EventIntermediate<'a> {
    fn from(e: &'a Event) -> Self {
        Self {
            id: Cow::Borrowed(&e.id),
            pubkey: Cow::Borrowed(&e.pubkey),
            created_at: Cow::Borrowed(&e.created_at),
            kind: Cow::Borrowed(&e.kind),
            tags: Cow::Borrowed(&e.tags),
            content: Cow::Borrowed(&e.content),
            sig: Cow::Borrowed(&e.sig),
        }
    }
}

impl Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if self.deser_order.is_empty() {
            let e: EventIntermediate<'_> = self.into();
            e.serialize(serializer)
        } else {
            let mut s = serializer.serialize_struct("Event", 7)?;
            for key in self.deser_order.iter() {
                match key {
                    EventKey::Id => s.serialize_field(ID, &self.id)?,
                    EventKey::PubKey => s.serialize_field(PUBKEY, &self.pubkey)?,
                    EventKey::CreatedAt => s.serialize_field(CREATED_AT, &self.created_at)?,
                    EventKey::Kind => s.serialize_field(KIND, &self.kind)?,
                    EventKey::Tags => s.serialize_field(TAGS, &self.tags)?,
                    EventKey::Content => s.serialize_field(CONTENT, &self.content)?,
                    EventKey::Sig => s.serialize_field(SIG, &self.sig)?,
                }
            }
            s.end()
        }
    }
}

impl<'de> Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value: Value = Value::deserialize(deserializer)?;

        let deser_order: Vec<EventKey> = value
            .as_object()
            .map(|map| {
                map.keys()
                    .filter_map(|k| EventKey::from_str(k).ok())
                    .collect()
            })
            .unwrap_or_default();

        let inter: EventIntermediate<'_> =
            serde_json::from_value(value).map_err(serde::de::Error::custom)?;

        Ok(Self {
            id: inter.id.into_owned(),
            pubkey: inter.pubkey.into_owned(),
            created_at: inter.created_at.into_owned(),
            kind: inter.kind.into_owned(),
            tags: inter.tags.into_owned(),
            content: inter.content.into_owned(),
            sig: inter.sig.into_owned(),
            deser_order,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[cfg(feature = "std")]
    use crate::Keys;

    #[test]
    fn test_tags_deser_without_recommended_relay() {
        // The TAG array has dynamic length because the third element(Recommended relay url) is optional
        let sample_event = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let ev_ser = Event::from_json(sample_event).unwrap();
        assert_eq!(ev_ser.as_json(), sample_event);
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_custom_kind() {
        let keys = Keys::generate();
        let e: Event = EventBuilder::new(Kind::Custom(123), "my content")
            .sign_with_keys(&keys)
            .unwrap();

        let serialized = e.as_json();
        let deserialized = Event::from_json(serialized).unwrap();

        assert_eq!(e, deserialized);
        assert_eq!(Kind::Custom(123), e.kind);
        assert_eq!(Kind::Custom(123), deserialized.kind);
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_event_expired() {
        let my_keys = Keys::generate();
        let event = EventBuilder::text_note("my content")
            .tags([Tag::expiration(Timestamp::from(1600000000))])
            .sign_with_keys(&my_keys)
            .unwrap();

        assert!(&event.is_expired());
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_event_not_expired() {
        let now = Timestamp::now();
        let expiry_date: u64 = now.as_u64() * 2;

        let my_keys = Keys::generate();
        let event = EventBuilder::text_note("my content")
            .tags([Tag::expiration(Timestamp::from(expiry_date))])
            .sign_with_keys(&my_keys)
            .unwrap();

        assert!(!&event.is_expired());
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_event_without_expiration_tag() {
        let my_keys = Keys::generate();
        let event = EventBuilder::text_note("my content")
            .sign_with_keys(&my_keys)
            .unwrap();
        assert!(!&event.is_expired());
    }

    #[test]
    fn test_verify_event_id() {
        let event = Event::from_json(r#"{"content":"","created_at":1698412975,"id":"f55c30722f056e330d8a7a6a9ba1522f7522c0f1ced1c93d78ea833c78a3d6ec","kind":3,"pubkey":"f831caf722214748c72db4829986bd0cbb2bb8b3aeade1c959624a52a9629046","sig":"5092a9ffaecdae7d7794706f085ff5852befdf79df424cc3419bb797bf515ae05d4f19404cb8324b8b4380a4bd497763ac7b0f3b1b63ef4d3baa17e5f5901808","tags":[["p","4ddeb9109a8cd29ba279a637f5ec344f2479ee07df1f4043f3fe26d8948cfef9","",""],["p","bb6fd06e156929649a73e6b278af5e648214a69d88943702f1fb627c02179b95","",""],["p","b8b8210f33888fdbf5cedee9edf13c3e9638612698fe6408aff8609059053420","",""],["p","9dcee4fabcd690dc1da9abdba94afebf82e1e7614f4ea92d61d52ef9cd74e083","",""],["p","3eea9e831fefdaa8df35187a204d82edb589a36b170955ac5ca6b88340befaa0","",""],["p","885238ab4568f271b572bf48b9d6f99fa07644731f288259bd395998ee24754e","",""],["p","568a25c71fba591e39bebe309794d5c15d27dbfa7114cacb9f3586ea1314d126","",""]]}"#).unwrap();
        assert!(event.verify_id());

        let event = Event::from_json(r#"{"content":"Think about this.\n\nThe most powerful centralized institutions in the world have been replaced by a protocol that protects the individual. #bitcoin\n\nDo you doubt that we can replace everything else?\n\nBullish on the future of humanity\nnostr:nevent1qqs9ljegkuk2m2ewfjlhxy054n6ld5dfngwzuep0ddhs64gc49q0nmqpzdmhxue69uhhyetvv9ukzcnvv5hx7un8qgsw3mfhnrr0l6ll5zzsrtpeufckv2lazc8k3ru5c3wkjtv8vlwngksrqsqqqqqpttgr27","created_at":1703184271,"id":"38acf9b08d06859e49237688a9fd6558c448766f47457236c2331f93538992c6","kind":1,"pubkey":"e8ed3798c6ffebffa08501ac39e271662bfd160f688f94c45d692d8767dd345a","sig":"f76d5ecc8e7de688ac12b9d19edaacdcffb8f0c8fa2a44c00767363af3f04dbc069542ddc5d2f63c94cb5e6ce701589d538cf2db3b1f1211a96596fabb6ecafe","tags":[["e","5fcb28b72cadab2e4cbf7311f4acf5f6d1a99a1c2e642f6b6f0d5518a940f9ec","","mention"],["p","e8ed3798c6ffebffa08501ac39e271662bfd160f688f94c45d692d8767dd345a","","mention"],["t","bitcoin"],["t","bitcoin"]]}"#).unwrap();
        assert!(event.verify_id());
    }

    // Test only with `std` feature due to `serde_json` preserve_order feature.
    #[test]
    #[cfg(feature = "std")]
    fn test_event_de_serialization_order_preservation() {
        let json = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let event = Event::from_json(json).unwrap();
        let reserialized_json = event.as_json();
        assert_eq!(json, reserialized_json);

        let json = r#"{"kind":3,"pubkey":"f831caf722214748c72db4829986bd0cbb2bb8b3aeade1c959624a52a9629046","content":"","created_at":1698412975,"id":"f55c30722f056e330d8a7a6a9ba1522f7522c0f1ced1c93d78ea833c78a3d6ec","sig":"5092a9ffaecdae7d7794706f085ff5852befdf79df424cc3419bb797bf515ae05d4f19404cb8324b8b4380a4bd497763ac7b0f3b1b63ef4d3baa17e5f5901808","tags":[["p","4ddeb9109a8cd29ba279a637f5ec344f2479ee07df1f4043f3fe26d8948cfef9","",""],["p","bb6fd06e156929649a73e6b278af5e648214a69d88943702f1fb627c02179b95","",""],["p","b8b8210f33888fdbf5cedee9edf13c3e9638612698fe6408aff8609059053420","",""],["p","9dcee4fabcd690dc1da9abdba94afebf82e1e7614f4ea92d61d52ef9cd74e083","",""],["p","3eea9e831fefdaa8df35187a204d82edb589a36b170955ac5ca6b88340befaa0","",""],["p","885238ab4568f271b572bf48b9d6f99fa07644731f288259bd395998ee24754e","",""],["p","568a25c71fba591e39bebe309794d5c15d27dbfa7114cacb9f3586ea1314d126","",""]]}"#;
        let event = Event::from_json(json).unwrap();
        let reserialized_json = event.as_json();
        assert_eq!(
            event.deser_order,
            vec![
                EventKey::Kind,
                EventKey::PubKey,
                EventKey::Content,
                EventKey::CreatedAt,
                EventKey::Id,
                EventKey::Sig,
                EventKey::Tags
            ]
        );
        assert_eq!(json, reserialized_json);

        let json = r#"{"content":"[[\"e\",\"fd40fc62d6349408c5b63d364c1f695b435cc596b58cfaa449519fbc5f2a41a4\"],[\"e\",\"a515bc18a06f0a3561075870f488365e71c5e90aa429a82845e9f7f0d66b6119\"],[\"e\",\"0eb6c73ed0af393a6a2fd9d8200534be064af9d244ef4b211e38503853755b57\"],[\"e\",\"1e8115cb2ba0e14eeb79fcb5ce6cb88f2db59e156aae9ad9302e86e8529e5e7c\"],[\"e\",\"6138b278802611f0685a75d5156f7bd3702a2acab4ba3864665901b1ffd58055\"],[\"e\",\"42105a71922acd113d77d876220fc49aabfa38ba9f34d2267e4f1d45d98b8eaf\"],[\"e\",\"dcd64141fa7af67e61fb28d02085e5c50bb0ccb72270b95e983183179903ef54\"],[\"e\",\"802f72b45a14639477a6ad9d89df9926d59e15d20387ab276dbe92dc48ddc21e\"],[\"e\",\"67ccd79069e27330480e1111f939c0770548e4222f4b5bcdf87ea9ec09e37abf\"],[\"e\",\"c45f94f3c8648536333b657287f0820c4ff1857fb1849a8ce8a541762f233063\"],[\"e\",\"afd22572b31ab14d0c6f65880e626d8e7fe20407ef1486e3ef78820be37e27d8\"],[\"e\",\"bd6a1a577ecfc5ba2ac5a391cae8f21a6238a7ad61a4ebcdd2a44ca488dd03c9\"],[\"e\",\"044ac6073a9cf1b723028a7828fdca098bcd0b79e5e58c21e2372c6b48bd67ca\"],[\"e\",\"2585dcecf6033f82d689a6456af2c82e7d5d9d9e64f90e2c7e86a80eb7dc765b\"],[\"e\",\"08a579677eee0b1796060dbd1e71dcc7ad0937be64ca278b61ef4c3dde149252\"],[\"e\",\"3ed3eaa26cdd1a35808775a8f0c6bd432c0dd1b9c2bc326c9dd249ecf2fe0270\"],[\"e\",\"a2bc2e1149d952a9af202529f3bdd4e8f11a9fda1bd2ad5c6dbbc8b83a1ebc2f\"],[\"e\",\"82e5c6ee536832ababb8eba47e1255d8b1820ca360d2c467f2f32fc610fe3047\"],[\"e\",\"1990b084eb9d0d524ff52f7fb2f0e7f1a1fee977b893c191af7893f53acf7d05\"],[\"e\",\"8df981ac84ca018c7972874770dbf19996f28e9c785eac473bab246e2ad92661\"],[\"e\",\"b975c677ee7517d9124ec8d69d3fafee7ddf6b1d291cc19dffd2678c2241f095\"],[\"e\",\"972599d1139da7e33dc39f049656935ae3b576492f1c535a0eda8d10b1eeb27d\"],[\"e\",\"eaaa6e0cda6315fa30841e9124a526c23dc631fcbf0ffc5e166bbd41d3585efa\"],[\"e\",\"e5eb71fe3dc364d51b6bd6cef73009704df5ee90674a54cb16168e78bbf8fa95\"],[\"e\",\"a49dd0610479b1d81b26f84b949d88d19abc4c3a6b86a1b6501ff393e9618700\"]]","created_at":1701278715,"id":"d05e7ae9271fe2d8968cccb67c01e3458dbafa4a415e306d49b22729b088c8a1","kind":6300,"pubkey":"6b37d5dc88c1cbd32d75b713f6d4c2f7766276f51c9337af9d32c8d715cc1b93","sig":"ee590cf98548039ccbeccb246e55310ad14bb0a307452dacca3f9d1760ac5fdb22d1f1bd932c5fc41d97b8cc16d82719c8ad24440b8d99c38ff2eb0486576253","tags":[["status","success"],["request","{\"created_at\":1701278699,\"content\":\"\",\"tags\":[[\"relays\",\"wss://pablof7z.nostr1.com\",\"wss://purplepag.es\",\"wss://nos.lol\",\"wss://relay.f7z.io\",\"wss://relay.damus.io\",\"wss://relay.snort.social\",\"wss://offchain.pub/\",\"wss://nostr-pub.wellorder.net\"],[\"output\",\"text/plain\"],[\"param\",\"user\",\"99bb5591c9116600f845107d31f9b59e2f7c7e09a1ff802e84f1d43da557ca64\"],[\"relays\",\"wss://relay.damus.io\",\"wss://offchain.pub/\",\"wss://pablof7z.nostr1.com\",\"wss://nos.lol\"]],\"kind\":5300,\"pubkey\":\"99bb5591c9116600f845107d31f9b59e2f7c7e09a1ff802e84f1d43da557ca64\",\"id\":\"5635e5dd930b3c831f6ab1e348bb488f3c9aca2f13190e93ab5e5e1e1ba1835e\",\"sig\":\"babbf39cf1875271d99be7319667f6f83349ffa0ad9262a7ca4719b60601e19642763733840fd7cbef2e883a19fd7829102709fb6af25a6d978b82fba2673140\"}"],["e","5635e5dd930b3c831f6ab1e348bb488f3c9aca2f13190e93ab5e5e1e1ba1835e"],["p","99bb5591c9116600f845107d31f9b59e2f7c7e09a1ff802e84f1d43da557ca64"],["p","99bb5591c9116600f845107d31f9b59e2f7c7e09a1ff802e84f1d43da557ca64"]]}"#;
        let event = Event::from_json(json).unwrap();
        let reserialized_json = event.as_json();
        assert_eq!(json, reserialized_json);
    }

    #[test]
    fn test_iter_event_ids() {
        let json = r#"{
              "content": "+",
              "created_at": 1716508454,
              "id": "3e9e9c2fbf263590860a9c60a7de6b0d166230a5a15aa8dcdb70f537cec9807a",
              "kind": 7,
              "pubkey": "3bbddb5c7233ad993b41cb639e63122120f391b8580a9b83aae33c648230e0a3",
              "sig": "3f2ba6d713e4851500b81de2d2ef44b72f1eff061898bf8488e74f7e4ed141b0dadab4c3a9c6b237f3a6db83171bd41eafd7ab973f6fb067a4305e95abeadeee",
              "tags": [
                [
                  "e",
                  "e1e786c60ed884b6e784712aaf70e63b848b7403ef651b52b701d87739ea1808",
                  "",
                  "",
                  "04c915daefee38317fa734444acee390a8269fe5810b2241e5e6dd343dfbecc9"
                ],
                [
                  "p",
                  "04c915daefee38317fa734444acee390a8269fe5810b2241e5e6dd343dfbecc9"
                ]
              ]
            }"#;
        let event = Event::from_json(json).unwrap();
        assert_eq!(event.tags.event_ids().count(), 1);
    }

    #[test]
    fn test_event_with_unknown_fields() {
        let json: &str = r##"{
               "citedNotesCache": [],
               "citedUsersCache": [
                 "aac07d95089ce6adf08b9156d43c1a4ab594c6130b7dcb12ec199008c5819a2f"
               ],
               "content": "#JoininBox is a minimalistic, security focused Linux environment for #JoinMarket with a terminal based graphical menu.\n\nnostr:npub14tq8m9ggnnn2muytj9tdg0q6f26ef3snpd7ukyhvrxgq33vpnghs8shy62 \n\nhttps://www.nobsbitcoin.com/joininbox-v0-8-0/",
                "created_at": 1687070234,
                "id": "c8acc12a232ea6caedfaaf0c52148635de6ffd312c3f432c6eca11720c102e54",
                "kind": 1,
                "pubkey": "27154fb873badf69c3ea83a0da6e65d6a150d2bf8f7320fc3314248d74645c64",
                "sig": "e27062b1b7187ffa0b521dab23fff6c6b62c00fd1b029e28368d7d070dfb225f7e598e3b1c6b1e2335b286ec3702492bce152035105b934f594cd7323d84f0ee",
                "tags": [
                    [
                "t",
                "joininbox"
                ],
                [
                    "t",
                    "joinmarket"
                ],
                [
                    "p",
                    "aac07d95089ce6adf08b9156d43c1a4ab594c6130b7dcb12ec199008c5819a2f"
                ]
                ]
        }"##;

        // Deserialize
        let event = Event::from_json(json).unwrap();

        // Re-serialize
        let re_serialized_json = event.as_json();

        let expected_json: &str = r##"{"content":"#JoininBox is a minimalistic, security focused Linux environment for #JoinMarket with a terminal based graphical menu.\n\nnostr:npub14tq8m9ggnnn2muytj9tdg0q6f26ef3snpd7ukyhvrxgq33vpnghs8shy62 \n\nhttps://www.nobsbitcoin.com/joininbox-v0-8-0/","created_at":1687070234,"id":"c8acc12a232ea6caedfaaf0c52148635de6ffd312c3f432c6eca11720c102e54","kind":1,"pubkey":"27154fb873badf69c3ea83a0da6e65d6a150d2bf8f7320fc3314248d74645c64","sig":"e27062b1b7187ffa0b521dab23fff6c6b62c00fd1b029e28368d7d070dfb225f7e598e3b1c6b1e2335b286ec3702492bce152035105b934f594cd7323d84f0ee","tags":[["t","joininbox"],["t","joinmarket"],["p","aac07d95089ce6adf08b9156d43c1a4ab594c6130b7dcb12ec199008c5819a2f"]]}"##;
        assert_eq!(re_serialized_json, expected_json.trim());
    }

    #[test]
    fn test_get_event_coordinate() {
        // Text note
        let json: &str = r#"{"id":"cb8feca582979d91fe90455867b34dbf4d65e4b86e86b3c68c368ca9f9eef6f2","pubkey":"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","created_at":1707409439,"kind":1,"tags":[["-"]],"content":"hello members of the secret group","sig":"fa163f5cfb75d77d9b6269011872ee22b34fb48d23251e9879bb1e4ccbdd8aaaf4b6dc5f5084a65ef42c52fbcde8f3178bac3ba207de827ec513a6aa39fa684c"}"#;
        let event = Event::from_json(json).unwrap();
        assert!(event.coordinate().is_none());

        // Replaceable
        let json: &str = r#"{"id":"8b19ce08cc0b20fd6c30e73b102fd3092c4f95f1c2a23d44064f9634b4593da5","pubkey":"2f35aaff0c870f0510a8bed198e1f8c35e95c996148f2d0c0fb1825b05b8dd35","created_at":1731251995,"kind":0,"tags":[],"content":"{\"name\":\"username\",\"display_name\":\"My Username\",\"about\":\"Description\",\"picture\":\"https://example.com/avatar.png\",\"banner\":\"https://example.com/banner.png\",\"nip05\":\"username@example.com\",\"lud16\":\"pay@yukikishimoto.com\"}","sig":"b26e4dfea18d4ecb072c665f9ed34b66d8dd9a45093790ea17cb618d85319587aa094f5c091efa3e237cd50976884e02c64c2f2b187c3ebdc4f773b2d74a61a4"}"#;
        let event = Event::from_json(json).unwrap();
        assert_eq!(
            event.coordinate(),
            Some(Coordinate::new(
                Kind::Metadata,
                PublicKey::from_hex(
                    "2f35aaff0c870f0510a8bed198e1f8c35e95c996148f2d0c0fb1825b05b8dd35"
                )
                .unwrap()
            ))
        );
    }

    #[test]
    fn test_protected_event() {
        let json: &str = r#"{"id":"cb8feca582979d91fe90455867b34dbf4d65e4b86e86b3c68c368ca9f9eef6f2","pubkey":"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","created_at":1707409439,"kind":1,"tags":[["-"]],"content":"hello members of the secret group","sig":"fa163f5cfb75d77d9b6269011872ee22b34fb48d23251e9879bb1e4ccbdd8aaaf4b6dc5f5084a65ef42c52fbcde8f3178bac3ba207de827ec513a6aa39fa684c"}"#;
        let event = Event::from_json(json).unwrap();
        assert!(event.is_protected());

        // NOT protected
        let json: &str = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let event = Event::from_json(json).unwrap();
        assert!(!event.is_protected());
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    #[bench]
    pub fn deserialize_event(bh: &mut Bencher) {
        let json = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        bh.iter(|| {
            black_box(Event::from_json(json)).unwrap();
        });
    }

    #[bench]
    pub fn serialize_event(bh: &mut Bencher) {
        let json = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let event = Event::from_json(json).unwrap();
        bh.iter(|| {
            black_box(event.as_json());
        });
    }

    #[bench]
    pub fn verify_event_id(bh: &mut Bencher) {
        let json = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let event = Event::from_json(json).unwrap();
        bh.iter(|| {
            black_box(event.verify_id());
        });
    }

    #[bench]
    pub fn verify_event_sig(bh: &mut Bencher) {
        let json = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let event = Event::from_json(json).unwrap();
        bh.iter(|| {
            black_box(event.verify_signature());
        });
    }
}

================
File: src/event/partial.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Partial Event for fast deserialization and signature verification

use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;
use core::str::FromStr;

use bitcoin::secp256k1;
use bitcoin::secp256k1::schnorr::Signature;

use super::raw::{self, RawEvent};
use super::tag;
use crate::{Event, EventId, JsonUtil, Kind, PublicKey, Tag, Timestamp};

/// [`PartialEvent`] error
#[derive(Debug)]
pub enum Error {
    /// Error serializing or deserializing JSON data
    Json(serde_json::Error),
    /// Raw event error
    RawEvent(raw::Error),
    /// Tag parse
    Tag(tag::Error),
    /// Secp256k1 error
    Secp256k1(secp256k1::Error),
    /// Invalid signature
    InvalidSignature,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Json(e) => write!(f, "Json: {e}"),
            Self::RawEvent(e) => write!(f, "Raw event: {e}"),
            Self::Tag(e) => write!(f, "Tag: {e}"),
            Self::Secp256k1(e) => write!(f, "{e}"),
            Self::InvalidSignature => write!(f, "Invalid signature"),
        }
    }
}

impl From<serde_json::Error> for Error {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e)
    }
}

impl From<raw::Error> for Error {
    fn from(e: raw::Error) -> Self {
        Self::RawEvent(e)
    }
}

impl From<tag::Error> for Error {
    fn from(e: tag::Error) -> Self {
        Self::Tag(e)
    }
}

impl From<secp256k1::Error> for Error {
    fn from(e: secp256k1::Error) -> Self {
        Self::Secp256k1(e)
    }
}

/// Partial event
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct PartialEvent {
    /// ID
    pub id: EventId,
    /// Author
    pub pubkey: PublicKey,
}

impl PartialEvent {
    /// Compose from [RawEvent]
    #[inline]
    pub fn from_raw(raw: &RawEvent) -> Result<Self, Error> {
        Ok(raw.try_into()?)
    }

    /// Merge [`MissingPartialEvent`] and compose [`Event`]
    pub fn merge(self, missing: MissingPartialEvent) -> Result<Event, Error> {
        let mut tags: Vec<Tag> = Vec::with_capacity(missing.tags.len());
        for tag in missing.tags.into_iter() {
            tags.push(Tag::parse(&tag)?);
        }

        Ok(Event::new(
            self.id,
            self.pubkey,
            missing.created_at,
            missing.kind,
            tags,
            missing.content,
            missing.sig,
        ))
    }
}

impl JsonUtil for PartialEvent {
    type Err = Error;
}

/// Missing Partial event fields
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct MissingPartialEvent {
    /// Timestamp (seconds)
    pub created_at: Timestamp,
    /// Kind
    pub kind: Kind,
    /// Vector of [`Tag`]
    pub tags: Vec<Vec<String>>,
    /// Content
    pub content: String,
    /// Signature
    pub sig: Signature,
}

impl MissingPartialEvent {
    /// Compose from [RawEvent]
    #[inline]
    pub fn from_raw(raw: RawEvent) -> Result<Self, Error> {
        Ok(Self {
            created_at: Timestamp::from(raw.created_at),
            kind: Kind::from(raw.kind),
            tags: raw.tags,
            content: raw.content,
            sig: Signature::from_str(&raw.sig)?,
        })
    }

    /// Extract identifier (`d` tag), if exists.
    pub fn identifier(&self) -> Option<&str> {
        for tag in self.tags.iter() {
            if let Some("d") = tag.first().map(|x| x.as_str()) {
                return tag.get(1).map(|x| x.as_str());
            }
        }
        None
    }
}

impl JsonUtil for MissingPartialEvent {
    type Err = Error;
}

================
File: src/event/raw.rs
================
// Copyright (c) 2021 Paul Miller
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Raw event

use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;
use core::str::FromStr;

use bitcoin::secp256k1;
use bitcoin::secp256k1::schnorr::Signature;

use super::{id, tag};
use crate::{key, Event, EventId, JsonUtil, Kind, PartialEvent, PublicKey, Tag, Timestamp};

/// [`RawEvent`] error
#[derive(Debug)]
pub enum Error {
    /// Secp256k1 error
    Secp256k1(secp256k1::Error),
    /// EventId error
    EventId(id::Error),
    /// Keys error
    Keys(key::Error),
    /// Tag error
    Tag(tag::Error),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Secp256k1(e) => write!(f, "Secp256k1: {e}"),
            Self::EventId(e) => write!(f, "Event ID: {e}"),
            Self::Keys(e) => write!(f, "Keys: {e}"),
            Self::Tag(e) => write!(f, "Tag: {e}"),
        }
    }
}

impl From<secp256k1::Error> for Error {
    fn from(e: secp256k1::Error) -> Self {
        Self::Secp256k1(e)
    }
}

impl From<id::Error> for Error {
    fn from(e: id::Error) -> Self {
        Self::EventId(e)
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Keys(e)
    }
}

impl From<tag::Error> for Error {
    fn from(e: tag::Error) -> Self {
        Self::Tag(e)
    }
}

/// Raw event
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct RawEvent {
    /// ID
    pub id: String,
    /// Author
    pub pubkey: String,
    /// Timestamp (seconds)
    pub created_at: u64,
    /// Kind
    pub kind: u16,
    /// Vector of strings
    pub tags: Vec<Vec<String>>,
    /// Content
    pub content: String,
    /// Signature
    pub sig: String,
}

impl JsonUtil for RawEvent {
    type Err = serde_json::Error;
}

impl TryFrom<RawEvent> for Event {
    type Error = Error;

    fn try_from(raw: RawEvent) -> Result<Self, Self::Error> {
        let id: EventId = EventId::from_hex(raw.id)?;
        let public_key: PublicKey = PublicKey::from_hex(raw.pubkey)?;
        let created_at: Timestamp = Timestamp::from(raw.created_at);
        let kind: Kind = Kind::from(raw.kind);
        let tags: Vec<Tag> = raw
            .tags
            .into_iter()
            .map(Tag::parse)
            .collect::<Result<Vec<_>, _>>()?;
        let sig: Signature = Signature::from_str(&raw.sig)?;
        Ok(Self::new(
            id,
            public_key,
            created_at,
            kind,
            tags,
            raw.content,
            sig,
        ))
    }
}

impl TryFrom<&RawEvent> for PartialEvent {
    type Error = Error;

    fn try_from(raw: &RawEvent) -> Result<Self, Self::Error> {
        let id: EventId = EventId::from_hex(&raw.id)?;
        let public_key: PublicKey = PublicKey::from_hex(&raw.pubkey)?;
        Ok(Self {
            id,
            pubkey: public_key,
        })
    }
}

================
File: src/event/unsigned.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Unsigned Event

use alloc::string::{String, ToString};
use core::fmt;

#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::{CryptoRng, Rng};
use bitcoin::secp256k1::schnorr::Signature;
use bitcoin::secp256k1::{Message, Secp256k1, Signing, Verification};

use crate::{Event, EventId, JsonUtil, Keys, Kind, PublicKey, SignerError, Tag, Tags, Timestamp};
#[cfg(feature = "std")]
use crate::{NostrSigner, SECP256K1};

/// Unsigned event error
#[derive(Debug)]
pub enum Error {
    /// Signer error
    Signer(SignerError),
    /// Error serializing or deserializing JSON data
    Json(String),
    /// Event error
    Event(super::Error),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Signer(e) => write!(f, "{e}"),
            Self::Json(e) => write!(f, "Json: {e}"),
            Self::Event(e) => write!(f, "Event: {e}"),
        }
    }
}

impl From<SignerError> for Error {
    fn from(e: SignerError) -> Self {
        Self::Signer(e)
    }
}

impl From<serde_json::Error> for Error {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e.to_string())
    }
}

impl From<super::Error> for Error {
    fn from(e: super::Error) -> Self {
        Self::Event(e)
    }
}

/// Unsigned event
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct UnsignedEvent {
    /// Event ID
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<EventId>,
    /// Author
    pub pubkey: PublicKey,
    /// Timestamp (seconds)
    pub created_at: Timestamp,
    /// Kind
    pub kind: Kind,
    /// Tag list
    pub tags: Tags,
    /// Content
    pub content: String,
}

impl UnsignedEvent {
    /// Construct new unsigned event
    #[inline]
    pub fn new<I, S>(
        public_key: PublicKey,
        created_at: Timestamp,
        kind: Kind,
        tags: I,
        content: S,
    ) -> Self
    where
        I: IntoIterator<Item = Tag>,
        S: Into<String>,
    {
        Self {
            id: None,
            pubkey: public_key,
            created_at,
            kind,
            tags: Tags::new(tags.into_iter().collect()),
            content: content.into(),
        }
    }

    /// Ensure to set [EventId]
    ///
    /// If `id` is `None`, compute and set it.
    #[inline]
    pub fn ensure_id(&mut self) {
        if self.id.is_none() {
            self.id = Some(self.compute_id());
        }
    }

    #[inline]
    fn compute_id(&self) -> EventId {
        EventId::new(
            &self.pubkey,
            &self.created_at,
            &self.kind,
            self.tags.as_slice(),
            &self.content,
        )
    }

    /// Verify if the [`EventId`] it's composed correctly
    pub fn verify_id(&self) -> Result<(), Error> {
        if let Some(id) = self.id {
            let computed_id: EventId = self.compute_id();
            if id != computed_id {
                return Err(Error::Event(super::Error::InvalidId));
            }
        }

        Ok(())
    }

    /// Sign an unsigned event
    #[inline]
    #[cfg(feature = "std")]
    pub async fn sign<T>(self, signer: &T) -> Result<Event, Error>
    where
        T: NostrSigner,
    {
        Ok(signer.sign_event(self).await?)
    }

    /// Sign an unsigned event with [`Keys`] signer
    ///
    /// Internally: calculate [EventId] (if not set), sign it, compose and verify [Event].
    #[inline]
    #[cfg(feature = "std")]
    pub fn sign_with_keys(self, keys: &Keys) -> Result<Event, Error> {
        self.sign_with_ctx(&SECP256K1, &mut OsRng, keys)
    }

    /// Sign an unsigned event with [`Keys`] signer
    ///
    /// Internally: calculate [EventId] (if not set), sign it, compose and verify [Event].
    pub fn sign_with_ctx<C, R>(
        self,
        secp: &Secp256k1<C>,
        rng: &mut R,
        keys: &Keys,
    ) -> Result<Event, Error>
    where
        C: Signing + Verification,
        R: Rng + CryptoRng,
    {
        let verify_id: bool = self.id.is_some();
        let id: EventId = self.id.unwrap_or_else(|| self.compute_id());
        let message: Message = Message::from_digest(id.to_bytes());
        let sig: Signature = keys.sign_schnorr_with_ctx(secp, &message, rng);
        self.internal_add_signature(secp, id, sig, verify_id, false)
    }

    /// Add signature to unsigned event
    ///
    /// Internally verify the [Event].
    #[inline]
    #[cfg(feature = "std")]
    pub fn add_signature(self, sig: Signature) -> Result<Event, Error> {
        self.add_signature_with_ctx(&SECP256K1, sig)
    }

    /// Add signature to unsigned event
    ///
    /// Internally verify the [Event].
    #[inline]
    pub fn add_signature_with_ctx<C>(
        self,
        secp: &Secp256k1<C>,
        sig: Signature,
    ) -> Result<Event, Error>
    where
        C: Verification,
    {
        let verify_id: bool = self.id.is_some();
        let id: EventId = self.id.unwrap_or_else(|| self.compute_id());
        self.internal_add_signature(secp, id, sig, verify_id, true)
    }

    fn internal_add_signature<C>(
        self,
        secp: &Secp256k1<C>,
        id: EventId,
        sig: Signature,
        verify_id: bool,
        verify_sig: bool,
    ) -> Result<Event, Error>
    where
        C: Verification,
    {
        let event: Event = Event::new(
            id,
            self.pubkey,
            self.created_at,
            self.kind,
            self.tags,
            self.content,
            sig,
        );

        // Verify event ID
        if verify_id && !event.verify_id() {
            return Err(Error::Event(super::Error::InvalidId));
        }

        // Verify event signature
        if verify_sig && !event.verify_signature_with_ctx(secp) {
            return Err(Error::Event(super::Error::InvalidSignature));
        }

        Ok(event)
    }
}

impl JsonUtil for UnsignedEvent {
    type Err = Error;
}

impl From<Event> for UnsignedEvent {
    fn from(event: Event) -> Self {
        Self {
            id: Some(event.id),
            pubkey: event.pubkey,
            created_at: event.created_at,
            kind: event.kind,
            tags: event.tags,
            content: event.content,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deserialize_unsigned_event_with_id() {
        let json = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let event_id: EventId =
            EventId::from_hex("2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45")
                .unwrap();
        let unsigned = UnsignedEvent::from_json(json).unwrap();
        assert_eq!(unsigned.id, Some(event_id));
        assert_eq!(
            unsigned.content,
            "uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA=="
        );
        assert_eq!(unsigned.kind, Kind::EncryptedDirectMessage);
    }

    #[test]
    fn test_deserialize_unsigned_event_without_id() {
        let json = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let unsigned = UnsignedEvent::from_json(json).unwrap();
        assert_eq!(unsigned.id, None);
        assert_eq!(
            unsigned.content,
            "uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA=="
        );
        assert_eq!(unsigned.kind, Kind::EncryptedDirectMessage);
    }
}

================
File: src/key/mod.rs
================
// Copyright (c) 2021 Paul Miller
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Keys

#[cfg(not(feature = "std"))]
use core::cell::OnceCell;
use core::cmp::Ordering;
use core::fmt;
use core::hash::{Hash, Hasher};
#[cfg(feature = "std")]
use core::str::FromStr;
#[cfg(feature = "std")]
use std::sync::OnceLock as OnceCell;

#[cfg(feature = "std")]
use async_trait::async_trait;
#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::{CryptoRng, Rng};
use bitcoin::secp256k1::schnorr::Signature;
use bitcoin::secp256k1::{self, Keypair, Message, Secp256k1, Signing, XOnlyPublicKey};

pub mod public_key;
pub mod secret_key;
#[cfg(feature = "std")]
pub mod vanity;

pub use self::public_key::PublicKey;
pub use self::secret_key::SecretKey;
#[cfg(feature = "std")]
use crate::signer::{NostrSigner, SignerBackend, SignerError};
#[cfg(feature = "std")]
use crate::{Event, UnsignedEvent, SECP256K1};

/// [`Keys`] error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Invalid secret key
    InvalidSecretKey,
    /// Invalid public key
    InvalidPublicKey,
    /// Unsupported char
    InvalidChar(char),
    /// Secp256k1 error
    Secp256k1(secp256k1::Error),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidSecretKey => write!(f, "Invalid secret key"),
            Self::InvalidPublicKey => write!(f, "Invalid public key"),
            Self::InvalidChar(c) => write!(f, "Unsupported char: {c}"),
            Self::Secp256k1(e) => write!(f, "Secp256k1: {e}"),
        }
    }
}

impl From<secp256k1::Error> for Error {
    fn from(e: secp256k1::Error) -> Self {
        Self::Secp256k1(e)
    }
}

/// Nostr keys
#[derive(Clone)]
pub struct Keys {
    /// Public key
    pub public_key: PublicKey,
    secret_key: SecretKey,
    key_pair: OnceCell<Keypair>,
}

impl fmt::Debug for Keys {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Keys")
            .field("public_key", &self.public_key)
            .finish()
    }
}

impl PartialEq for Keys {
    fn eq(&self, other: &Self) -> bool {
        self.public_key == other.public_key
    }
}

impl Eq for Keys {}

impl PartialOrd for Keys {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Keys {
    fn cmp(&self, other: &Self) -> Ordering {
        self.public_key.cmp(&other.public_key)
    }
}

impl Hash for Keys {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.public_key.hash(state)
    }
}

impl Keys {
    /// Initialize nostr keys from secret key.
    ///
    /// This method internally construct the [Keypair] and derive the [PublicKey].
    #[inline]
    #[cfg(feature = "std")]
    pub fn new(secret_key: SecretKey) -> Self {
        Self::new_with_ctx(&SECP256K1, secret_key)
    }

    /// Initialize nostr keys from secret key.
    ///
    /// This method internally construct the [Keypair] and derive the [PublicKey].
    pub fn new_with_ctx<C>(secp: &Secp256k1<C>, secret_key: SecretKey) -> Self
    where
        C: Signing,
    {
        let key_pair: Keypair = Keypair::from_secret_key(secp, &secret_key);
        let public_key: XOnlyPublicKey = XOnlyPublicKey::from_keypair(&key_pair).0;

        Self {
            public_key: PublicKey::from(public_key),
            secret_key,
            key_pair: OnceCell::from(key_pair),
        }
    }

    /// Parse secret key from `hex` or `bech32` and compose keys
    #[inline]
    #[cfg(feature = "std")]
    pub fn parse<S>(secret_key: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        Self::parse_with_ctx(&SECP256K1, secret_key)
    }

    /// Parse secret key from `hex` or `bech32` and compose keys
    #[inline]
    pub fn parse_with_ctx<C, S>(secp: &Secp256k1<C>, secret_key: S) -> Result<Self, Error>
    where
        C: Signing,
        S: AsRef<str>,
    {
        let secret_key: SecretKey = SecretKey::parse(secret_key)?;
        Ok(Self::new_with_ctx(secp, secret_key))
    }

    /// Generate random keys
    ///
    /// This constructor use a random number generator that retrieves randomness from the operating system (see [`OsRng`]).
    ///
    /// Use [`Keys::generate_with_rng`] to specify a custom random source.
    ///
    /// Check [`Keys::generate_with_ctx`] to learn more about how this constructor works internally.
    #[inline]
    #[cfg(feature = "std")]
    pub fn generate() -> Self {
        Self::generate_with_rng(&mut OsRng)
    }

    /// Generate random keys using a custom random source
    ///
    /// Check [`Keys::generate_with_ctx`] to learn more about how this constructor works internally.
    #[inline]
    #[cfg(feature = "std")]
    pub fn generate_with_rng<R>(rng: &mut R) -> Self
    where
        R: Rng + ?Sized,
    {
        Self::generate_with_ctx(&SECP256K1, rng)
    }

    /// Generate random keys
    ///
    /// Generate random keys **without** construct the [`Keypair`].
    /// This allows faster keys generation (i.e. for vanity pubkey mining).
    /// The [`Keypair`] will be automatically created when needed and stored in a cell.
    #[inline]
    pub fn generate_with_ctx<C, R>(secp: &Secp256k1<C>, rng: &mut R) -> Self
    where
        C: Signing,
        R: Rng + ?Sized,
    {
        let (secret_key, public_key) = secp.generate_keypair(rng);
        let (public_key, _) = public_key.x_only_public_key();
        Self {
            public_key: PublicKey::from(public_key),
            secret_key: SecretKey::from(secret_key),
            key_pair: OnceCell::new(),
        }
    }

    /// Get public key
    #[inline]
    pub fn public_key(&self) -> PublicKey {
        self.public_key
    }

    /// Get secret key
    #[inline]
    pub fn secret_key(&self) -> &SecretKey {
        &self.secret_key
    }

    /// Get keypair
    #[inline]
    pub fn key_pair<C>(&self, secp: &Secp256k1<C>) -> &Keypair
    where
        C: Signing,
    {
        self.key_pair
            .get_or_init(|| Keypair::from_secret_key(secp, &self.secret_key))
    }

    /// Creates a schnorr signature of the [`Message`].
    ///
    /// This method use a random number generator that retrieves randomness from the operating system (see [`OsRng`]).
    #[inline]
    #[cfg(feature = "std")]
    pub fn sign_schnorr(&self, message: &Message) -> Signature {
        self.sign_schnorr_with_ctx(&SECP256K1, message, &mut OsRng)
    }

    /// Creates a schnorr signature of the [`Message`] using a custom random number generation source.
    pub fn sign_schnorr_with_ctx<C, R>(
        &self,
        secp: &Secp256k1<C>,
        message: &Message,
        rng: &mut R,
    ) -> Signature
    where
        C: Signing,
        R: Rng + CryptoRng,
    {
        let keypair: &Keypair = self.key_pair(secp);
        secp.sign_schnorr_with_rng(message, keypair, rng)
    }
}

#[cfg(feature = "std")]
impl FromStr for Keys {
    type Err = Error;

    /// Try to parse [Keys] from **secret key** `hex` or `bech32`
    #[inline]
    fn from_str(secret_key: &str) -> Result<Self, Self::Err> {
        Self::parse(secret_key)
    }
}

#[cfg(feature = "std")]
#[cfg_attr(target_arch = "wasm32", async_trait(?Send))]
#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
impl NostrSigner for Keys {
    fn backend(&self) -> SignerBackend {
        SignerBackend::Keys
    }

    async fn get_public_key(&self) -> Result<PublicKey, SignerError> {
        Ok(self.public_key)
    }

    async fn sign_event(&self, unsigned: UnsignedEvent) -> Result<Event, SignerError> {
        unsigned.sign_with_keys(self).map_err(SignerError::backend)
    }

    #[cfg(feature = "nip04")]
    async fn nip04_encrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError> {
        let secret_key: &SecretKey = self.secret_key();
        crate::nips::nip04::encrypt(secret_key, public_key, content).map_err(SignerError::backend)
    }

    #[cfg(feature = "nip04")]
    async fn nip04_decrypt(
        &self,
        public_key: &PublicKey,
        encrypted_content: &str,
    ) -> Result<String, SignerError> {
        let secret_key: &SecretKey = self.secret_key();
        crate::nips::nip04::decrypt(secret_key, public_key, encrypted_content)
            .map_err(SignerError::backend)
    }

    #[cfg(feature = "nip44")]
    async fn nip44_encrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError> {
        use crate::nips::nip44::{self, Version};
        let secret_key: &SecretKey = self.secret_key();
        nip44::encrypt(secret_key, public_key, content, Version::default())
            .map_err(SignerError::backend)
    }

    #[cfg(feature = "nip44")]
    async fn nip44_decrypt(
        &self,
        public_key: &PublicKey,
        payload: &str,
    ) -> Result<String, SignerError> {
        let secret_key: &SecretKey = self.secret_key();
        crate::nips::nip44::decrypt(secret_key, public_key, payload).map_err(SignerError::backend)
    }
}

#[cfg(test)]
#[cfg(feature = "std")]
mod tests {
    use super::*;

    const SECRET_KEY_BECH32: &str =
        "nsec1j4c6269y9w0q2er2xjw8sv2ehyrtfxq3jwgdlxj6qfn8z4gjsq5qfvfk99";
    const SECRET_KEY_HEX: &str = "6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e";

    #[test]
    fn parse_keys() -> Result<(), Error> {
        Keys::parse(SECRET_KEY_BECH32)?;
        Keys::parse(SECRET_KEY_HEX)?;
        Ok(())
    }

    #[test]
    fn parse_invalid_keys() {
        assert_eq!(Keys::parse("nsec...").unwrap_err(), Error::InvalidSecretKey);
        assert_eq!(
            Keys::parse("npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy")
                .unwrap_err(),
            Error::InvalidSecretKey
        );
        assert_eq!(
            Keys::parse("6b911fd37cdf5c8").unwrap_err(),
            Error::InvalidSecretKey
        );
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    #[bench]
    pub fn generate_keys(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(Keys::generate());
        });
    }
}

================
File: src/key/public_key.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Public key

use alloc::string::{String, ToString};
use core::fmt;
use core::ops::Deref;
use core::str::FromStr;

use bitcoin::secp256k1::XOnlyPublicKey;
use serde::{Deserialize, Deserializer, Serialize};

use super::Error;
use crate::nips::nip19::FromBech32;
use crate::nips::nip21::NostrURI;

/// Public Key
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct PublicKey {
    inner: XOnlyPublicKey,
}

impl Deref for PublicKey {
    type Target = XOnlyPublicKey;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl From<XOnlyPublicKey> for PublicKey {
    fn from(inner: XOnlyPublicKey) -> Self {
        Self { inner }
    }
}

impl fmt::Debug for PublicKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "PublicKey({})", self.to_hex())
    }
}

impl fmt::Display for PublicKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_hex())
    }
}

impl PublicKey {
    /// Public Key len
    pub const LEN: usize = 32;

    /// Parse from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    pub fn parse<S>(public_key: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let public_key: &str = public_key.as_ref();

        // Try from hex
        if let Ok(public_key) = Self::from_hex(public_key) {
            return Ok(public_key);
        }

        // Try from bech32
        if let Ok(public_key) = Self::from_bech32(public_key) {
            return Ok(public_key);
        }

        // Try from NIP21 URI
        if let Ok(public_key) = Self::from_nostr_uri(public_key) {
            return Ok(public_key);
        }

        Err(Error::InvalidPublicKey)
    }

    /// Parse [PublicKey] from `bytes`
    #[inline]
    pub fn from_slice(slice: &[u8]) -> Result<Self, Error> {
        Ok(Self {
            inner: XOnlyPublicKey::from_slice(slice)?,
        })
    }

    /// Parse [PublicKey] from `hex` string
    #[inline]
    pub fn from_hex<S>(hex: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        Ok(Self {
            inner: XOnlyPublicKey::from_str(hex.as_ref())?,
        })
    }

    /// Get public key as `hex` string
    #[inline]
    pub fn to_hex(&self) -> String {
        self.inner.to_string()
    }

    /// Get public key as `bytes`
    #[inline]
    pub fn to_bytes(&self) -> [u8; Self::LEN] {
        self.inner.serialize()
    }
}

impl FromStr for PublicKey {
    type Err = Error;

    /// Try to parse [PublicKey] from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    #[inline]
    fn from_str(public_key: &str) -> Result<Self, Self::Err> {
        Self::parse(public_key)
    }
}

// Required to keep clean the methods of `Filter` struct
impl From<PublicKey> for String {
    fn from(public_key: PublicKey) -> Self {
        public_key.to_hex()
    }
}

impl Serialize for PublicKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_hex())
    }
}

impl<'de> Deserialize<'de> for PublicKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let public_key: String = String::deserialize(deserializer)?;
        Self::parse(public_key).map_err(serde::de::Error::custom)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_public_key_parse() {
        let public_key = PublicKey::parse(
            "nostr:npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy",
        )
        .unwrap();
        assert_eq!(
            public_key.to_hex(),
            "aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4"
        );
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;
    use crate::nips::nip19::ToBech32;

    const NIP21_URI: &str = "nostr:npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy";
    const HEX: &str = "aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4";
    const BECH32: &str = "npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy";

    #[bench]
    pub fn parse_public_key_nip21_uri(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(PublicKey::parse(NIP21_URI)).unwrap();
        });
    }

    #[bench]
    pub fn parse_public_key_hex(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(PublicKey::parse(HEX)).unwrap();
        });
    }

    #[bench]
    pub fn public_key_from_hex(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(PublicKey::from_hex(HEX)).unwrap();
        });
    }

    #[bench]
    pub fn parse_public_key_bech32(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(PublicKey::parse(BECH32)).unwrap();
        });
    }

    #[bench]
    pub fn public_key_from_bech32(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(PublicKey::from_bech32(BECH32)).unwrap();
        });
    }

    #[bench]
    pub fn public_key_to_hex(bh: &mut Bencher) {
        let public_key = PublicKey::from_hex(HEX).unwrap();
        bh.iter(|| {
            black_box(public_key.to_bech32()).unwrap();
        });
    }

    #[bench]
    pub fn public_key_to_bech32(bh: &mut Bencher) {
        let public_key = PublicKey::from_hex(HEX).unwrap();
        bh.iter(|| {
            black_box(public_key.to_bech32()).unwrap();
        });
    }
}

================
File: src/key/secret_key.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Secret key

use alloc::string::{String, ToString};
use core::ops::{Deref, DerefMut};
use core::str::FromStr;

use bitcoin::secp256k1;
use serde::{Deserialize, Deserializer};

use super::Error;
use crate::nips::nip19::FromBech32;
#[cfg(all(feature = "std", feature = "nip49"))]
use crate::nips::nip49::{self, EncryptedSecretKey, KeySecurity};
#[cfg(feature = "std")]
use crate::prelude::rand::rngs::OsRng;
use crate::prelude::rand::Rng;
use crate::secp256k1::{Secp256k1, Signing};
#[cfg(feature = "std")]
use crate::SECP256K1;

/// Secret key
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SecretKey {
    inner: secp256k1::SecretKey,
}

impl Deref for SecretKey {
    type Target = secp256k1::SecretKey;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl DerefMut for SecretKey {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.inner
    }
}

impl From<secp256k1::SecretKey> for SecretKey {
    fn from(inner: secp256k1::SecretKey) -> Self {
        Self { inner }
    }
}

impl SecretKey {
    /// Secret Key len
    pub const LEN: usize = 32;

    /// Parse from `hex` or `bech32`
    pub fn parse<S>(secret_key: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let secret_key: &str = secret_key.as_ref();

        // Try from hex
        if let Ok(secret_key) = Self::from_hex(secret_key) {
            return Ok(secret_key);
        }

        // Try from bech32
        if let Ok(secret_key) = Self::from_bech32(secret_key) {
            return Ok(secret_key);
        }

        Err(Error::InvalidSecretKey)
    }

    /// Parse [SecretKey] from `bytes`
    #[inline]
    pub fn from_slice(slice: &[u8]) -> Result<Self, Error> {
        Ok(Self {
            inner: secp256k1::SecretKey::from_slice(slice)?,
        })
    }

    /// Parse [SecretKey] from `hex` string
    #[inline]
    pub fn from_hex<S>(hex: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        Ok(Self {
            inner: secp256k1::SecretKey::from_str(hex.as_ref())?,
        })
    }

    /// Generate new random secret key
    #[inline]
    #[cfg(feature = "std")]
    pub fn generate() -> Self {
        Self::generate_with_rng(&mut OsRng)
    }

    /// Generate random secret key with custom [`Rng`]
    #[inline]
    #[cfg(feature = "std")]
    pub fn generate_with_rng<R>(rng: &mut R) -> Self
    where
        R: Rng + ?Sized,
    {
        Self::generate_with_ctx(&SECP256K1, rng)
    }

    /// Generate random secret key with custom `secp256k1` context and [`Rng`]
    #[inline]
    pub fn generate_with_ctx<C, R>(secp: &Secp256k1<C>, rng: &mut R) -> Self
    where
        C: Signing,
        R: Rng + ?Sized,
    {
        let (secret_key, _) = secp.generate_keypair(rng);
        Self { inner: secret_key }
    }

    /// Get secret key as `hex` string
    #[inline]
    pub fn to_secret_hex(&self) -> String {
        self.inner.display_secret().to_string()
    }

    /// Get secret key as `bytes`
    #[inline]
    pub fn as_secret_bytes(&self) -> &[u8] {
        self.inner.as_ref()
    }

    /// Get secret key as `bytes`
    #[inline]
    pub fn to_secret_bytes(&self) -> [u8; Self::LEN] {
        self.inner.secret_bytes()
    }

    /// Encrypt [SecretKey]
    ///
    /// By default `LOG_N` is set to `16` and [KeySecurity] to `Unknown`.
    /// To use custom values check [EncryptedSecretKey] constructors.
    #[inline]
    #[cfg(all(feature = "std", feature = "nip49"))]
    pub fn encrypt<S>(&self, password: S) -> Result<EncryptedSecretKey, nip49::Error>
    where
        S: AsRef<str>,
    {
        EncryptedSecretKey::new(self, password, 16, KeySecurity::Unknown)
    }
}

impl FromStr for SecretKey {
    type Err = Error;

    /// Try to parse [SecretKey] from `hex` or `bech32`
    #[inline]
    fn from_str(secret_key: &str) -> Result<Self, Self::Err> {
        Self::parse(secret_key)
    }
}

impl<'de> Deserialize<'de> for SecretKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let secret_key: String = String::deserialize(deserializer)?;
        Self::parse(secret_key).map_err(serde::de::Error::custom)
    }
}

impl Drop for SecretKey {
    fn drop(&mut self) {
        self.inner.non_secure_erase();
    }
}

================
File: src/key/vanity.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Vanity

use alloc::string::{String, ToString};
use alloc::sync::Arc;
use alloc::vec::Vec;
use core::fmt;
use core::sync::atomic::{AtomicBool, Ordering};
use std::sync::mpsc::{sync_channel, RecvError};
use std::thread;

use bitcoin::secp256k1::rand;

use super::Keys;
use crate::nips::nip19::{ToBech32, PREFIX_BECH32_PUBLIC_KEY};

const BECH32_SPAN: usize = PREFIX_BECH32_PUBLIC_KEY.len() + 1;
const BECH32_CHARS: &str = "023456789acdefghjklmnpqrstuvwxyz";
const HEX_CHARS: &str = "0123456789abcdef";

/// [`Keys`] vanity error
#[derive(Debug, Eq, PartialEq)]
pub enum Error {
    /// Unsupported char
    InvalidChar(char),
    /// RecvError
    RecvError(RecvError),
    /// Thread Join failed
    JoinHandleError,
}

impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidChar(c) => write!(f, "Unsupported char: {c}"),
            Self::RecvError(e) => write!(f, "{e}"),
            Self::JoinHandleError => write!(f, "impossible to join threads"),
        }
    }
}

impl From<RecvError> for Error {
    fn from(e: RecvError) -> Self {
        Self::RecvError(e)
    }
}

impl Keys {
    /// check validity of prefix characters
    fn check_prefix_chars(prefixes: &[String], valid_chars: &str) -> Result<(), Error> {
        for prefix in prefixes.iter() {
            for c in prefix.chars() {
                if !valid_chars.contains(c) {
                    return Err(Error::InvalidChar(c));
                }
            }
        }
        Ok(())
    }

    /// Generate new vanity public key
    pub fn vanity<S>(prefixes: Vec<S>, bech32: bool, num_cores: usize) -> Result<Self, Error>
    where
        S: Into<String>,
    {
        let prefixes: Vec<String> = prefixes.into_iter().map(|p| p.into()).collect();
        if bech32 {
            Self::check_prefix_chars(&prefixes, BECH32_CHARS)?;
        } else {
            Self::check_prefix_chars(&prefixes, HEX_CHARS)?;
        }
        let (tx, rx) = sync_channel::<Keys>(1);
        let found = Arc::new(AtomicBool::new(false));
        let mut handles = Vec::with_capacity(num_cores);

        for _ in 0..num_cores {
            let tx = tx.clone();
            let found = found.clone();
            let prefixes = prefixes.clone();
            let handle = thread::spawn(move || {
                let mut rng = rand::thread_rng();
                loop {
                    if found.load(Ordering::SeqCst) {
                        break;
                    }

                    let keys: Keys = Keys::generate_with_rng(&mut rng);

                    if bech32 {
                        let bech32_key = keys
                            .public_key
                            .to_bech32()
                            .expect("Unable to convert key to bech32");
                        if prefixes
                            .iter()
                            .any(|prefix| bech32_key[BECH32_SPAN..].starts_with(prefix))
                        {
                            tx.send(keys).expect("Unable to send on channel");
                            found.store(true, Ordering::SeqCst);
                            break;
                        }
                    } else {
                        let pubkey = keys.public_key.to_string();
                        if prefixes.iter().any(|prefix| pubkey.starts_with(prefix)) {
                            tx.send(keys).expect("Unable to send on channel");
                            found.store(true, Ordering::SeqCst);
                            break;
                        }
                    }
                }
            });
            handles.push(handle);
        }

        for handle in handles {
            handle.join().map_err(|_| Error::JoinHandleError)?;
        }

        Ok(rx.recv()?)
    }
}

================
File: src/message/relay/mod.rs
================
// Copyright (c) 2021 Paul Miller
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Relay messages

use alloc::boxed::Box;
use alloc::string::{String, ToString};
use core::fmt;

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json::{json, Value};

mod raw;

pub use self::raw::RawRelayMessage;
use super::MessageHandleError;
use crate::{Event, EventId, JsonUtil, SubscriptionId};

/// Machine-readable prefixes for `OK` and `CLOSED` relay messages
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum MachineReadablePrefix {
    /// Duplicate
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Duplicate,
    /// POW
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Pow,
    /// Blocked
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Blocked,
    /// Rate limited
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    RateLimited,
    /// Invalid
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Invalid,
    /// Error
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Error,
    /// Authentication required
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/42.md>
    AuthRequired,
    /// Restricted
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/42.md>
    Restricted,
}

impl fmt::Display for MachineReadablePrefix {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Duplicate => write!(f, "duplicate"),
            Self::Pow => write!(f, "pow"),
            Self::Blocked => write!(f, "blocked"),
            Self::RateLimited => write!(f, "rate-limited"),
            Self::Invalid => write!(f, "invalid"),
            Self::Error => write!(f, "error"),
            Self::AuthRequired => write!(f, "auth-required"),
            Self::Restricted => write!(f, "restricted"),
        }
    }
}

impl MachineReadablePrefix {
    /// Parse machine-readable prefix
    pub fn parse<S>(message: S) -> Option<Self>
    where
        S: AsRef<str>,
    {
        match message.as_ref() {
            m if m.starts_with("duplicate:") => Some(Self::Duplicate),
            m if m.starts_with("pow:") => Some(Self::Pow),
            m if m.starts_with("blocked:") => Some(Self::Blocked),
            m if m.starts_with("rate-limited:") => Some(Self::RateLimited),
            m if m.starts_with("invalid:") => Some(Self::Invalid),
            m if m.starts_with("error:") => Some(Self::Error),
            m if m.starts_with("auth-required:") => Some(Self::AuthRequired),
            m if m.starts_with("restricted:") => Some(Self::Restricted),
            _ => None,
        }
    }
}

/// Negentropy error code
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum NegentropyErrorCode {
    /// Results too big
    ResultsTooBig,
    /// Because the NEG-OPEN queries are stateful, relays may choose to time-out inactive queries to recover memory resources
    Closed,
    /// If an event ID is used as the filter, this error will be returned if the relay does not have this event.
    /// The client should retry with the full filter, or upload the event to the relay.
    FilterNotFound,
    /// The event's content was not valid JSON, or the filter was invalid for some other reason.
    FilterInvalid,
    /// Other
    Other(String),
}

impl fmt::Display for NegentropyErrorCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::ResultsTooBig => write!(f, "RESULTS_TOO_BIG"),
            Self::Closed => write!(f, "CLOSED"),
            Self::FilterNotFound => write!(f, "FILTER_NOT_FOUND"),
            Self::FilterInvalid => write!(f, "FILTER_INVALID"),
            Self::Other(e) => write!(f, "{e}"),
        }
    }
}

impl<S> From<S> for NegentropyErrorCode
where
    S: Into<String>,
{
    fn from(code: S) -> Self {
        let code: String = code.into();
        match code.as_str() {
            "RESULTS_TOO_BIG" => Self::ResultsTooBig,
            "CLOSED" => Self::Closed,
            "FILTER_NOT_FOUND" => Self::FilterNotFound,
            "FILTER_INVALID" => Self::FilterInvalid,
            _ => Self::Other(code),
        }
    }
}

impl Serialize for NegentropyErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for NegentropyErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = Value::deserialize(deserializer)?;
        let alphaber: String = serde_json::from_value(value).map_err(serde::de::Error::custom)?;
        Ok(Self::from(alphaber))
    }
}

/// Messages sent by relays, received by clients
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum RelayMessage {
    /// `["EVENT", <subscription_id>, <event JSON>]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Event {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Event
        event: Box<Event>,
    },
    /// `["OK", <event_id>, <true|false>, <message>]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Ok {
        /// Event ID
        event_id: EventId,
        /// Status
        status: bool,
        /// Message
        message: String,
    },
    /// `["EOSE", <subscription_id>]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    EndOfStoredEvents(SubscriptionId),
    /// `["NOTICE", <message>]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Notice {
        /// Message
        message: String,
    },
    /// `["CLOSED", <subscription_id>, <message>]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    Closed {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Message
        message: String,
    },
    /// `["AUTH", <challenge-string>]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/42.md>
    Auth {
        /// Challenge
        challenge: String,
    },
    /// `["COUNT", <subscription_id>, {"count": <integer>}]`
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/45.md>
    Count {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Events count
        count: usize,
    },
    /// Negentropy Message
    NegMsg {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Message
        message: String,
    },
    /// Negentropy Error
    NegErr {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Error code
        code: NegentropyErrorCode,
    },
}

impl Serialize for RelayMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let json_value: Value = self.as_value();
        json_value.serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for RelayMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let json_value = Value::deserialize(deserializer)?;
        RelayMessage::from_value(json_value).map_err(serde::de::Error::custom)
    }
}

impl RelayMessage {
    /// Create `EVENT` message
    #[inline]
    pub fn event(subscription_id: SubscriptionId, event: Event) -> Self {
        Self::Event {
            subscription_id,
            event: Box::new(event),
        }
    }

    /// Create `NOTICE` message
    #[inline]
    pub fn notice<S>(message: S) -> Self
    where
        S: Into<String>,
    {
        Self::Notice {
            message: message.into(),
        }
    }

    /// Create `CLOSED` message
    #[inline]
    pub fn closed<S>(subscription_id: SubscriptionId, message: S) -> Self
    where
        S: Into<String>,
    {
        Self::Closed {
            subscription_id,
            message: message.into(),
        }
    }

    /// Create `EOSE` message
    #[inline]
    pub fn eose(subscription_id: SubscriptionId) -> Self {
        Self::EndOfStoredEvents(subscription_id)
    }

    /// Create `OK` message
    #[inline]
    pub fn ok<S>(event_id: EventId, status: bool, message: S) -> Self
    where
        S: Into<String>,
    {
        Self::Ok {
            event_id,
            status,
            message: message.into(),
        }
    }

    /// Create `AUTH` message
    #[inline]
    pub fn auth<S>(challenge: S) -> Self
    where
        S: Into<String>,
    {
        Self::Auth {
            challenge: challenge.into(),
        }
    }

    /// Create  `EVENT` message
    #[inline]
    pub fn count(subscription_id: SubscriptionId, count: usize) -> Self {
        Self::Count {
            subscription_id,
            count,
        }
    }

    fn as_value(&self) -> Value {
        match self {
            Self::Event {
                event,
                subscription_id,
            } => json!(["EVENT", subscription_id, event]),
            Self::Notice { message } => json!(["NOTICE", message]),
            Self::Closed {
                subscription_id,
                message,
            } => json!(["CLOSED", subscription_id, message]),
            Self::EndOfStoredEvents(subscription_id) => {
                json!(["EOSE", subscription_id])
            }
            Self::Ok {
                event_id,
                status,
                message,
            } => json!(["OK", event_id, status, message]),
            Self::Auth { challenge } => json!(["AUTH", challenge]),
            Self::Count {
                subscription_id,
                count,
            } => json!(["COUNT", subscription_id, { "count": count }]),
            Self::NegMsg {
                subscription_id,
                message,
            } => json!(["NEG-MSG", subscription_id, message]),
            Self::NegErr {
                subscription_id,
                code,
            } => json!(["NEG-ERR", subscription_id, code]),
        }
    }

    /// Deserialize [`RelayMessage`] from [`Value`]
    #[inline]
    pub fn from_value(msg: Value) -> Result<Self, MessageHandleError> {
        let raw = RawRelayMessage::from_value(msg)?;
        RelayMessage::try_from(raw)
    }
}

impl JsonUtil for RelayMessage {
    type Err = MessageHandleError;

    /// Deserialize [`RelayMessage`] from JSON string
    ///
    /// **This method NOT verify the event signature!**
    fn from_json<T>(json: T) -> Result<Self, Self::Err>
    where
        T: AsRef<[u8]>,
    {
        let msg: &[u8] = json.as_ref();

        if msg.is_empty() {
            return Err(MessageHandleError::EmptyMsg);
        }

        let value: Value = serde_json::from_slice(msg)?;
        Self::from_value(value)
    }
}

impl TryFrom<RawRelayMessage> for RelayMessage {
    type Error = MessageHandleError;

    fn try_from(raw: RawRelayMessage) -> Result<Self, Self::Error> {
        match raw {
            RawRelayMessage::Event {
                subscription_id,
                event,
            } => Ok(Self::Event {
                subscription_id: SubscriptionId::new(subscription_id),
                event: Box::new(event.try_into()?),
            }),
            RawRelayMessage::Ok {
                event_id,
                status,
                message,
            } => Ok(Self::Ok {
                event_id: EventId::from_hex(event_id)?,
                status,
                message,
            }),
            RawRelayMessage::EndOfStoredEvents(subscription_id) => Ok(Self::EndOfStoredEvents(
                SubscriptionId::new(subscription_id),
            )),
            RawRelayMessage::Notice { message } => Ok(Self::Notice { message }),
            RawRelayMessage::Closed {
                subscription_id,
                message,
            } => Ok(Self::Closed {
                subscription_id: SubscriptionId::new(subscription_id),
                message,
            }),
            RawRelayMessage::Auth { challenge } => Ok(Self::Auth { challenge }),
            RawRelayMessage::Count {
                subscription_id,
                count,
            } => Ok(Self::Count {
                subscription_id: SubscriptionId::new(subscription_id),
                count,
            }),
            RawRelayMessage::NegMsg {
                subscription_id,
                message,
            } => Ok(Self::NegMsg {
                subscription_id: SubscriptionId::new(subscription_id),
                message,
            }),
            RawRelayMessage::NegErr {
                subscription_id,
                code,
            } => Ok(Self::NegErr {
                subscription_id: SubscriptionId::new(subscription_id),
                code: NegentropyErrorCode::from(code),
            }),
        }
    }
}

#[cfg(feature = "std")]
#[cfg(test)]
mod tests {
    use core::str::FromStr;

    use bitcoin::secp256k1::schnorr::Signature;

    use super::*;
    use crate::{Kind, PublicKey, Timestamp};

    #[test]
    fn test_handle_valid_notice() {
        let valid_notice_msg = r#"["NOTICE","Invalid event format!"]"#;
        let handled_valid_notice_msg = RelayMessage::notice(String::from("Invalid event format!"));

        assert_eq!(
            RelayMessage::from_json(valid_notice_msg).unwrap(),
            handled_valid_notice_msg
        );
    }
    #[test]
    fn test_handle_invalid_notice() {
        // Missing content
        let invalid_notice_msg = r#"["NOTICE"]"#;
        // The content is not string
        let invalid_notice_msg_content = r#"["NOTICE": 404]"#;

        assert!(RelayMessage::from_json(invalid_notice_msg).is_err(),);
        assert!(RelayMessage::from_json(invalid_notice_msg_content).is_err(),);
    }

    #[test]
    fn test_handle_valid_closed() {
        let valid_closed_msg = r#"["CLOSED","random-subscription-id","reason"]"#;
        let handled_valid_closed_msg =
            RelayMessage::closed(SubscriptionId::new("random-subscription-id"), "reason");

        assert_eq!(
            RelayMessage::from_json(valid_closed_msg).unwrap(),
            handled_valid_closed_msg
        );
    }

    #[test]
    fn test_handle_invalid_closed() {
        // Missing subscription ID
        assert!(RelayMessage::from_json(r#"["CLOSED"]"#).is_err());

        // The subscription ID is not a string
        assert!(RelayMessage::from_json(r#"["CLOSED", 404, "reason"]"#).is_err());

        // The content is not a string
        assert!(RelayMessage::from_json(r#"["CLOSED", "random-subscription-id", 404]"#).is_err())
    }

    #[test]
    fn test_handle_valid_event() {
        let valid_event_msg = r#"["EVENT", "random_string", {"id":"70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5","pubkey":"379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe","created_at":1612809991,"kind":1,"tags":[],"content":"test","sig":"273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502"}]"#;

        let id =
            EventId::from_hex("70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5")
                .unwrap();
        let pubkey =
            PublicKey::from_str("379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe")
                .unwrap();
        let created_at = Timestamp::from(1612809991);
        let kind = Kind::TextNote;
        let content = "test";
        let sig = Signature::from_str("273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502").unwrap();

        let handled_event = Event::new(id, pubkey, created_at, kind, [], content, sig);

        assert_eq!(
            RelayMessage::from_json(valid_event_msg).unwrap(),
            RelayMessage::event(SubscriptionId::new("random_string"), handled_event)
        );

        let message = RelayMessage::from_json(r#"["EVENT","bf7da933d6c6d67e5c97f94f17cf8762",{"content":"Think about this.\n\nThe most powerful centralized institutions in the world have been replaced by a protocol that protects the individual. #bitcoin\n\nDo you doubt that we can replace everything else?\n\nBullish on the future of humanity\nnostr:nevent1qqs9ljegkuk2m2ewfjlhxy054n6ld5dfngwzuep0ddhs64gc49q0nmqpzdmhxue69uhhyetvv9ukzcnvv5hx7un8qgsw3mfhnrr0l6ll5zzsrtpeufckv2lazc8k3ru5c3wkjtv8vlwngksrqsqqqqqpttgr27","created_at":1703184271,"id":"38acf9b08d06859e49237688a9fd6558c448766f47457236c2331f93538992c6","kind":1,"pubkey":"e8ed3798c6ffebffa08501ac39e271662bfd160f688f94c45d692d8767dd345a","sig":"f76d5ecc8e7de688ac12b9d19edaacdcffb8f0c8fa2a44c00767363af3f04dbc069542ddc5d2f63c94cb5e6ce701589d538cf2db3b1f1211a96596fabb6ecafe","tags":[["e","5fcb28b72cadab2e4cbf7311f4acf5f6d1a99a1c2e642f6b6f0d5518a940f9ec","","mention"],["p","e8ed3798c6ffebffa08501ac39e271662bfd160f688f94c45d692d8767dd345a","","mention"],["t","bitcoin"],["t","bitcoin"]]}]"#).unwrap();
        if let RelayMessage::Event { event, .. } = message {
            event.verify().unwrap();
        } else {
            panic!("Wrong relay message");
        }
    }

    #[test]
    fn test_handle_invalid_event() {
        // Missing Event field
        let invalid_event_msg = r#"["EVENT", "random_string"]"#;
        // Event JSON with incomplete content
        let invalid_event_msg_content = r#"["EVENT", "random_string", {"id":"70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5","pubkey":"379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"}]"#;

        assert!(RelayMessage::from_json(invalid_event_msg).is_err(),);

        assert!(RelayMessage::from_json(invalid_event_msg_content).is_err(),);
    }

    #[test]
    fn test_handle_valid_eose() {
        let valid_eose_msg = r#"["EOSE","random-subscription-id"]"#;
        let handled_valid_eose_msg =
            RelayMessage::eose(SubscriptionId::new("random-subscription-id"));

        assert_eq!(
            RelayMessage::from_json(valid_eose_msg).unwrap(),
            handled_valid_eose_msg
        );
    }
    #[test]
    fn test_handle_invalid_eose() {
        // Missing subscription ID
        assert!(RelayMessage::from_json(r#"["EOSE"]"#).is_err(),);

        // The subscription ID is not string
        assert!(RelayMessage::from_json(r#"["EOSE", 404]"#).is_err(),);
    }

    #[test]
    fn test_handle_valid_ok() {
        let valid_ok_msg = r#"["OK", "b1a649ebe8b435ec71d3784793f3bbf4b93e64e17568a741aecd4c7ddeafce30", true, "pow: difficulty 25>=24"]"#;
        let handled_valid_ok_msg = RelayMessage::ok(
            EventId::from_hex("b1a649ebe8b435ec71d3784793f3bbf4b93e64e17568a741aecd4c7ddeafce30")
                .unwrap(),
            true,
            "pow: difficulty 25>=24",
        );

        assert_eq!(
            RelayMessage::from_json(valid_ok_msg).unwrap(),
            handled_valid_ok_msg
        );
    }
    #[test]
    fn test_handle_invalid_ok() {
        // Missing params
        assert!(RelayMessage::from_json(
            r#"["OK", "b1a649ebe8b435ec71d3784793f3bbf4b93e64e17568a741aecd4c7ddeafce30"]"#
        )
        .is_err(),);

        // Invalid event_id
        assert!(RelayMessage::from_json(
            r#"["OK", "b1a649ebe8b435ec71d3784793f3bbf4b93e64e17568a741aecd4c7dde", true, ""]"#
        )
        .is_err(),);

        // Invalid status
        assert!(
            RelayMessage::from_json(r#"["OK", "b1a649ebe8b435ec71d3784793f3bbf4b93e64e17568a741aecd4c7ddeafce30", hello, ""]"#).is_err(),
        );

        // Invalid message
        assert!(
            RelayMessage::from_json(r#"["OK", "b1a649ebe8b435ec71d3784793f3bbf4b93e64e17568a741aecd4c7ddeafce30", hello, 404]"#).is_err()
        );
    }

    #[test]
    fn parse_message() {
        // Got this fresh off the wire
        pub const SAMPLE_EVENT: &str = r#"["EVENT", "random_string", {"id":"70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5","pubkey":"379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe","created_at":1612809991,"kind":1,"tags":[],"content":"test","sig":"273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502"}]"#;

        // Hand parsed version as a sanity check
        let id =
            EventId::from_hex("70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5")
                .unwrap();
        let pubkey =
            PublicKey::from_str("379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe")
                .unwrap();
        let created_at = Timestamp::from(1612809991);
        let kind = Kind::TextNote;
        let content = "test";
        let sig = Signature::from_str("273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502").unwrap();

        let event = Event::new(id, pubkey, created_at, kind, [], content, sig);

        let parsed_event = RelayMessage::from_json(SAMPLE_EVENT).expect("Failed to parse event");

        assert_eq!(
            parsed_event,
            RelayMessage::event(SubscriptionId::new("random_string"), event)
        );
    }

    #[test]
    fn test_raw_relay_message() {
        pub const SAMPLE_EVENT: &str = r#"["EVENT", "random_string", {"id":"70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5","pubkey":"379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe","created_at":1612809991,"kind":1,"tags":[],"content":"test","sig":"273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502"}]"#;

        let raw = RawRelayMessage::from_json(SAMPLE_EVENT).unwrap();
        let msg = RelayMessage::try_from(raw).unwrap();

        assert_eq!(msg, RelayMessage::from_json(SAMPLE_EVENT).unwrap());
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    #[bench]
    pub fn parse_ok_relay_message(bh: &mut Bencher) {
        let json: &str = r#"["OK", "70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5", true, "pow: difficulty 25>=24"]"#;
        bh.iter(|| {
            black_box(RelayMessage::from_json(&json)).unwrap();
        });
    }

    #[bench]
    pub fn parse_event_relay_message(bh: &mut Bencher) {
        let json: &str = r#"["EVENT", "random_string", {"id":"70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5","pubkey":"379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe","created_at":1612809991,"kind":1,"tags":[],"content":"test","sig":"273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502"}]"#;
        bh.iter(|| {
            black_box(RelayMessage::from_json(&json)).unwrap();
        });
    }
}

================
File: src/message/relay/raw.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Raw Relay messages

use alloc::string::String;
use alloc::vec::IntoIter;

use serde::de::DeserializeOwned;
use serde_json::Value;

use crate::event::raw::RawEvent;
use crate::message::MessageHandleError;

/// Raw Relay Message
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RawRelayMessage {
    /// `["EVENT", <subscription_id>, <event JSON>]` (NIP01)
    Event {
        /// Subscription ID
        subscription_id: String,
        /// Event JSON
        event: RawEvent,
    },
    /// `["OK", <event_id>, <true|false>, <message>]` (NIP01)
    Ok {
        /// Event ID
        event_id: String,
        /// Status
        status: bool,
        /// Message
        message: String,
    },
    /// `["EOSE", <subscription_id>]` (NIP01)
    EndOfStoredEvents(String),
    /// `["NOTICE", <message>]` (NIP01)
    Notice {
        /// Message
        message: String,
    },
    /// `["CLOSED", <subscription_id>, <message>]` (NIP01)
    Closed {
        /// Subscription ID
        subscription_id: String,
        /// Message
        message: String,
    },
    /// `["AUTH", <challenge-string>]` (NIP42)
    Auth {
        /// Challenge
        challenge: String,
    },
    /// `["COUNT", <subscription_id>, {"count": <integer>}]` (NIP45)
    Count {
        /// Subscription ID
        subscription_id: String,
        /// Events count
        count: usize,
    },
    /// Negentropy Message
    NegMsg {
        /// Subscription ID
        subscription_id: String,
        /// Message
        message: String,
    },
    /// Negentropy Error
    NegErr {
        /// Subscription ID
        subscription_id: String,
        /// Error code
        code: String,
    },
}

impl RawRelayMessage {
    /// Deserialize [`RawRelayMessage`] from [`Value`]
    pub fn from_value(msg: Value) -> Result<Self, MessageHandleError> {
        let Value::Array(v) = msg else {
            return Err(MessageHandleError::InvalidMessageFormat);
        };

        if v.is_empty() {
            return Err(MessageHandleError::InvalidMessageFormat);
        }

        let mut v_iter = v.into_iter();

        // Index 0
        let v_type: String = next_and_deser(&mut v_iter)?;

        match v_type.as_str() {
            "NOTICE" => {
                // ["NOTICE", <message>]
                Ok(Self::Notice {
                    message: next_and_deser(&mut v_iter)?, // Index 1
                })
            }
            "CLOSED" => {
                // ["CLOSED", <subscription_id>, <message>]
                Ok(Self::Closed {
                    subscription_id: next_and_deser(&mut v_iter)?, // Index 1
                    message: next_and_deser(&mut v_iter)?,         // Index 2
                })
            }
            "EVENT" => {
                // ["EVENT", <subscription id>, <event JSON>]
                Ok(Self::Event {
                    subscription_id: next_and_deser(&mut v_iter)?, // Index 1
                    event: next_and_deser(&mut v_iter)?,           // Index 2
                })
            }
            "EOSE" => {
                // ["EOSE", <subscription_id>]
                let subscription_id: String = next_and_deser(&mut v_iter)?; // Index 1
                Ok(Self::EndOfStoredEvents(subscription_id))
            }
            "OK" => {
                // ["OK", <event_id>, <true|false>, <message>]
                Ok(Self::Ok {
                    event_id: next_and_deser(&mut v_iter)?, // Index 1
                    status: next_and_deser(&mut v_iter)?,   // Index 2
                    message: next_and_deser(&mut v_iter)?,  // Index 3
                })
            }
            "AUTH" => {
                // ["AUTH", <challenge>]
                Ok(Self::Auth {
                    challenge: next_and_deser(&mut v_iter)?, // Index 1
                })
            }
            "COUNT" => {
                // ["COUNT", <subscription id>, {"count": num}]
                let subscription_id: String = next_and_deser(&mut v_iter)?; // Index 1
                let Count { count } = next_and_deser(&mut v_iter)?; // Index 2

                Ok(Self::Count {
                    subscription_id,
                    count,
                })
            }
            "NEG-MSG" => {
                // ["NEG-MSG", <subscription ID string>, <message, lowercase hex-encoded>]
                Ok(Self::NegMsg {
                    subscription_id: next_and_deser(&mut v_iter)?, // Index 1
                    message: next_and_deser(&mut v_iter)?,         // Index 2
                })
            }
            "NEG-ERR" => {
                // ["NEG-ERR", <subscription ID string>, <reason-code>]
                Ok(Self::NegErr {
                    subscription_id: next_and_deser(&mut v_iter)?, // Index 1
                    code: next_and_deser(&mut v_iter)?,            // Index 2
                })
            }
            _ => Err(MessageHandleError::InvalidMessageFormat),
        }
    }

    /// Deserialize [`RawRelayMessage`] from JSON string
    #[inline]
    pub fn from_json<T>(json: T) -> Result<Self, MessageHandleError>
    where
        T: AsRef<[u8]>,
    {
        let msg: &[u8] = json.as_ref();

        if msg.is_empty() {
            return Err(MessageHandleError::EmptyMsg);
        }

        let value: Value = serde_json::from_slice(msg)?;
        Self::from_value(value)
    }
}

#[inline]
fn next_and_deser<T>(iter: &mut IntoIter<Value>) -> Result<T, MessageHandleError>
where
    T: DeserializeOwned,
{
    let val: Value = iter
        .next()
        .ok_or(MessageHandleError::InvalidMessageFormat)?;
    Ok(serde_json::from_value(val)?)
}

#[derive(Deserialize)]
struct Count {
    count: usize,
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    const EVENT: &'static str = r#"["EVENT", "random_string", {"id":"70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5","pubkey":"379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe","created_at":1612809991,"kind":1,"tags":[],"content":"test","sig":"273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502"}]"#;

    #[bench]
    pub fn parse_raw_message_relay(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(RawRelayMessage::from_json(EVENT)).unwrap();
        });
    }
}

================
File: src/message/client.rs
================
// Copyright (c) 2021 Paul Miller
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Client messages

use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;

use negentropy::{Bytes, Negentropy, NegentropyStorageBase};
use negentropy_deprecated::{Bytes as BytesDeprecated, Negentropy as NegentropyDeprecated};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json::{json, Value};

use super::MessageHandleError;
use crate::{Event, Filter, JsonUtil, SubscriptionId};

/// Messages sent by clients, received by relays
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ClientMessage {
    /// Event
    Event(Box<Event>),
    /// Req
    Req {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Filters
        filters: Vec<Filter>,
    },
    /// Count
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/45.md>
    Count {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Filters
        filters: Vec<Filter>,
    },
    /// Close
    Close(SubscriptionId),
    /// Auth
    Auth(Box<Event>),
    /// Negentropy Open
    NegOpen {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Filter
        filter: Box<Filter>,
        /// ID size (deprecated)
        id_size: Option<u8>,
        /// Initial message
        initial_message: String,
    },
    /// Negentropy Message
    NegMsg {
        /// Subscription ID
        subscription_id: SubscriptionId,
        /// Message
        message: String,
    },
    /// Negentropy Close
    NegClose {
        /// Subscription ID
        subscription_id: SubscriptionId,
    },
}

impl Serialize for ClientMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let json_value: Value = self.as_value();
        json_value.serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for ClientMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let json_value = Value::deserialize(deserializer)?;
        ClientMessage::from_value(json_value).map_err(serde::de::Error::custom)
    }
}

impl ClientMessage {
    /// Create `EVENT` message
    #[inline]
    pub fn event(event: Event) -> Self {
        Self::Event(Box::new(event))
    }

    /// Create `REQ` message
    #[inline]
    pub fn req(subscription_id: SubscriptionId, filters: Vec<Filter>) -> Self {
        Self::Req {
            subscription_id,
            filters,
        }
    }

    /// Create `COUNT` message
    #[inline]
    pub fn count(subscription_id: SubscriptionId, filters: Vec<Filter>) -> Self {
        Self::Count {
            subscription_id,
            filters,
        }
    }

    /// Create new `CLOSE` message
    #[inline]
    pub fn close(subscription_id: SubscriptionId) -> Self {
        Self::Close(subscription_id)
    }

    /// Create `AUTH` message
    #[inline]
    pub fn auth(event: Event) -> Self {
        Self::Auth(Box::new(event))
    }

    /// Create new `NEG-OPEN` message
    pub fn neg_open<T>(
        negentropy: &mut Negentropy<T>,
        subscription_id: SubscriptionId,
        filter: Filter,
    ) -> Result<Self, negentropy::Error>
    where
        T: NegentropyStorageBase,
    {
        let initial_message: Bytes = negentropy.initiate()?;
        Ok(Self::NegOpen {
            subscription_id,
            filter: Box::new(filter),
            id_size: None,
            initial_message: initial_message.to_hex(),
        })
    }

    /// Create new `NEG-OPEN` message (deprecated protocol version)
    pub fn neg_open_deprecated(
        negentropy: &mut NegentropyDeprecated,
        subscription_id: SubscriptionId,
        filter: Filter,
    ) -> Result<Self, negentropy_deprecated::Error> {
        let initial_message: BytesDeprecated = negentropy.initiate()?;
        Ok(Self::NegOpen {
            subscription_id,
            filter: Box::new(filter),
            id_size: Some(negentropy.id_size() as u8),
            initial_message: initial_message.to_hex(),
        })
    }

    /// Check if is an `EVENT` message
    #[inline]
    pub fn is_event(&self) -> bool {
        matches!(self, ClientMessage::Event(_))
    }

    /// Check if is an `REQ` message
    #[inline]
    pub fn is_req(&self) -> bool {
        matches!(self, ClientMessage::Req { .. })
    }

    /// Check if is an `CLOSE` message
    #[inline]
    pub fn is_close(&self) -> bool {
        matches!(self, ClientMessage::Close(_))
    }

    /// Check if is an `AUTH` message
    #[inline]
    pub fn is_auth(&self) -> bool {
        matches!(self, ClientMessage::Auth(_))
    }

    /// Serialize as [`Value`]
    pub fn as_value(&self) -> Value {
        match self {
            Self::Event(event) => json!(["EVENT", event]),
            Self::Req {
                subscription_id,
                filters,
            } => {
                let mut json = json!(["REQ", subscription_id]);
                let mut filters = json!(filters);

                if let Some(json) = json.as_array_mut() {
                    if let Some(filters) = filters.as_array_mut() {
                        json.append(filters);
                    }
                }

                json
            }
            Self::Count {
                subscription_id,
                filters,
            } => {
                let mut json = json!(["COUNT", subscription_id]);
                let mut filters = json!(filters);

                if let Some(json) = json.as_array_mut() {
                    if let Some(filters) = filters.as_array_mut() {
                        json.append(filters);
                    }
                }

                json
            }
            Self::Close(subscription_id) => json!(["CLOSE", subscription_id]),
            Self::Auth(event) => json!(["AUTH", event]),
            Self::NegOpen {
                subscription_id,
                filter,
                id_size,
                initial_message,
            } => match id_size {
                Some(id_size) => json!([
                    "NEG-OPEN",
                    subscription_id,
                    filter,
                    id_size,
                    initial_message
                ]),
                None => json!(["NEG-OPEN", subscription_id, filter, initial_message]),
            },
            Self::NegMsg {
                subscription_id,
                message,
            } => json!(["NEG-MSG", subscription_id, message]),
            Self::NegClose { subscription_id } => json!(["NEG-CLOSE", subscription_id]),
        }
    }

    /// Deserialize from [`Value`]
    ///
    /// **This method NOT verify the event signature!**
    pub fn from_value(msg: Value) -> Result<Self, MessageHandleError> {
        let v = msg
            .as_array()
            .ok_or(MessageHandleError::InvalidMessageFormat)?;

        if v.is_empty() {
            return Err(MessageHandleError::InvalidMessageFormat);
        }

        let v_len: usize = v.len();

        // Event
        // ["EVENT", <event JSON>]
        if v[0] == "EVENT" {
            if v_len >= 2 {
                let event: Event = serde_json::from_value(v[1].clone())?;
                return Ok(Self::event(event));
            } else {
                return Err(MessageHandleError::InvalidMessageFormat);
            }
        }

        // Req
        // ["REQ", <subscription_id>, <filter JSON>, <filter JSON>...]
        if v[0] == "REQ" {
            if v_len == 2 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                return Ok(Self::req(subscription_id, Vec::new()));
            } else if v_len >= 3 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                let filters: Vec<Filter> = serde_json::from_value(Value::Array(v[2..].to_vec()))?;
                return Ok(Self::req(subscription_id, filters));
            } else {
                return Err(MessageHandleError::InvalidMessageFormat);
            }
        }

        // ["COUNT", <subscription_id>, <filter JSON>, <filter JSON>...]
        if v[0] == "COUNT" {
            if v_len == 2 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                return Ok(Self::count(subscription_id, Vec::new()));
            } else if v_len >= 3 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                let filters: Vec<Filter> = serde_json::from_value(Value::Array(v[2..].to_vec()))?;
                return Ok(Self::count(subscription_id, filters));
            } else {
                return Err(MessageHandleError::InvalidMessageFormat);
            }
        }

        // Close
        // ["CLOSE", <subscription_id>]
        if v[0] == "CLOSE" {
            if v_len >= 2 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                return Ok(Self::close(subscription_id));
            } else {
                return Err(MessageHandleError::InvalidMessageFormat);
            }
        }

        // Auth
        // ["AUTH", <event JSON>]
        if v[0] == "AUTH" {
            if v_len >= 2 {
                let event: Event = serde_json::from_value(v[1].clone())?;
                return Ok(Self::auth(event));
            } else {
                return Err(MessageHandleError::InvalidMessageFormat);
            }
        }

        // Negentropy Open
        // New: ["NEG-OPEN", <subscription ID string>, <filter>, <initialMessage as lowercase hex-encoded>]
        // Old: ["NEG-OPEN", <subscription ID string>, <filter>, <idSize>, <initialMessage as lowercase hex-encoded>]
        if v[0] == "NEG-OPEN" {
            // New negentropy protocol message
            if v_len == 4 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                let filter: Filter = Filter::from_json(v[2].to_string())?;
                let initial_message: String = serde_json::from_value(v[3].clone())?;
                return Ok(Self::NegOpen {
                    subscription_id,
                    filter: Box::new(filter),
                    id_size: None,
                    initial_message,
                });
            }

            // Old negentropy protocol message
            if v_len == 5 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                let filter: Filter = Filter::from_json(v[2].to_string())?;
                let id_size: u8 =
                    v[3].as_u64()
                        .ok_or(MessageHandleError::InvalidMessageFormat)? as u8;
                let initial_message: String = serde_json::from_value(v[4].clone())?;
                return Ok(Self::NegOpen {
                    subscription_id,
                    filter: Box::new(filter),
                    id_size: Some(id_size),
                    initial_message,
                });
            }

            return Err(MessageHandleError::InvalidMessageFormat);
        }

        // Negentropy Message
        // ["NEG-MSG", <subscription ID string>, <message, lowercase hex-encoded>]
        if v[0] == "NEG-MSG" {
            if v_len >= 3 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                let message: String = serde_json::from_value(v[2].clone())?;
                return Ok(Self::NegMsg {
                    subscription_id,
                    message,
                });
            } else {
                return Err(MessageHandleError::InvalidMessageFormat);
            }
        }

        // Negentropy Close
        // ["NEG-CLOSE", <subscription ID string>]
        if v[0] == "NEG-CLOSE" {
            if v_len >= 2 {
                let subscription_id: SubscriptionId = serde_json::from_value(v[1].clone())?;
                return Ok(Self::NegClose { subscription_id });
            } else {
                return Err(MessageHandleError::InvalidMessageFormat);
            }
        }

        Err(MessageHandleError::InvalidMessageFormat)
    }
}

impl JsonUtil for ClientMessage {
    type Err = MessageHandleError;

    /// Deserialize [`ClientMessage`] from JSON string
    ///
    /// **This method NOT verify the event signature!**
    fn from_json<T>(json: T) -> Result<Self, Self::Err>
    where
        T: AsRef<[u8]>,
    {
        let msg: &[u8] = json.as_ref();

        if msg.is_empty() {
            return Err(MessageHandleError::InvalidMessageFormat);
        }

        let value: Value = serde_json::from_slice(msg)?;
        Self::from_value(value)
    }
}

#[cfg(test)]
mod tests {
    use core::str::FromStr;

    use super::*;
    use crate::{Kind, PublicKey};

    #[test]
    fn test_client_message_req() {
        let pk =
            PublicKey::from_str("379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe")
                .unwrap();
        let filters = vec![
            Filter::new().kind(Kind::EncryptedDirectMessage),
            Filter::new().pubkey(pk),
        ];

        let client_req = ClientMessage::req(SubscriptionId::new("test"), filters);
        assert_eq!(
            client_req.as_json(),
            r##"["REQ","test",{"kinds":[4]},{"#p":["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"]}]"##
        );
    }

    #[test]
    fn test_client_message_custom_kind() {
        let pk =
            PublicKey::from_str("379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe")
                .unwrap();
        let filters = vec![
            Filter::new().kind(Kind::Custom(22)),
            Filter::new().pubkey(pk),
        ];

        let client_req = ClientMessage::req(SubscriptionId::new("test"), filters);
        assert_eq!(
            client_req.as_json(),
            r##"["REQ","test",{"kinds":[22]},{"#p":["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"]}]"##
        );
    }
}

================
File: src/message/mod.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Messages

use alloc::string::{String, ToString};
use core::fmt;

use bitcoin::hashes::sha256::Hash as Sha256Hash;
use bitcoin::hashes::Hash;
#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::RngCore;
use serde::{Deserialize, Deserializer, Serialize, Serializer};

pub mod client;
pub mod relay;

pub use self::client::ClientMessage;
pub use self::relay::{MachineReadablePrefix, RawRelayMessage, RelayMessage};
use crate::event;
use crate::util::hex;

/// Messages error
#[derive(Debug)]
pub enum MessageHandleError {
    /// Invalid message format
    InvalidMessageFormat,
    /// Impossible to deserialize message
    Json(serde_json::Error),
    /// Event ID error
    EventId(event::id::Error),
    /// Event error
    Event(event::Error),
    /// Raw event error
    RawEvent(event::raw::Error),
    /// Empty message
    EmptyMsg,
}

#[cfg(feature = "std")]
impl std::error::Error for MessageHandleError {}

impl fmt::Display for MessageHandleError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidMessageFormat => write!(f, "Message has an invalid format"),
            Self::Json(e) => write!(f, "Json deserialization failed: {e}"),
            Self::EventId(e) => write!(f, "EventId: {e}"),
            Self::Event(e) => write!(f, "Event: {e}"),
            Self::RawEvent(e) => write!(f, "Raw event: {e}"),
            Self::EmptyMsg => write!(f, "Received empty message"),
        }
    }
}

impl From<serde_json::Error> for MessageHandleError {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e)
    }
}

impl From<event::id::Error> for MessageHandleError {
    fn from(e: event::id::Error) -> Self {
        Self::EventId(e)
    }
}

impl From<event::Error> for MessageHandleError {
    fn from(e: event::Error) -> Self {
        Self::Event(e)
    }
}

impl From<event::raw::Error> for MessageHandleError {
    fn from(e: event::raw::Error) -> Self {
        Self::RawEvent(e)
    }
}

/// Subscription ID
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SubscriptionId(String);

impl SubscriptionId {
    /// Create new [`SubscriptionId`]
    #[inline]
    pub fn new<S>(id: S) -> Self
    where
        S: Into<String>,
    {
        Self(id.into())
    }

    /// Generate new random [`SubscriptionId`]
    #[inline]
    #[cfg(feature = "std")]
    pub fn generate() -> Self {
        Self::generate_with_rng(&mut OsRng)
    }

    /// Generate new random [`SubscriptionId`]
    pub fn generate_with_rng<R>(rng: &mut R) -> Self
    where
        R: RngCore,
    {
        // Random bytes
        let mut bytes: [u8; 32] = [0u8; 32];
        rng.fill_bytes(&mut bytes);

        // Hash random bytes
        let hash: [u8; 32] = Sha256Hash::hash(&bytes).to_byte_array();

        // Cut the hash and encode to hex
        Self::new(hex::encode(&hash[..16]))
    }
}

impl fmt::Display for SubscriptionId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Serialize for SubscriptionId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for SubscriptionId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let id: String = String::deserialize(deserializer)?;
        Ok(Self::new(id))
    }
}

================
File: src/nips/nip44/mod.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP44: Versioned Encryption
//!
//! <https://github.com/nostr-protocol/nips/blob/master/44.md>

use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;

use base64::engine::{general_purpose, Engine};
#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::RngCore;

pub mod v2;

use self::v2::ConversationKey;
use crate::{PublicKey, SecretKey};

/// Error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// NIP44 V2 error
    V2(v2::ErrorV2),
    /// Error while decoding from base64
    Base64Decode(base64::DecodeError),
    /// Invalid length
    InvalidLength,
    /// Error while encoding to UTF-8
    Utf8Encode,
    /// Unknown version
    UnknownVersion(u8),
    /// Version not found in payload
    VersionNotFound,
    /// Not found in payload
    NotFound(String),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::V2(e) => write!(f, "{e}"),
            Self::Base64Decode(e) => write!(f, "Error while decoding from base64: {e}"),
            Self::InvalidLength => write!(f, "Invalid length"),
            Self::Utf8Encode => write!(f, "Error while encoding to UTF-8"),
            Self::UnknownVersion(v) => write!(f, "unknown version: {v}"),
            Self::VersionNotFound => write!(f, "Version not found in payload"),
            Self::NotFound(value) => write!(f, "{value} not found in payload"),
        }
    }
}

impl From<v2::ErrorV2> for Error {
    fn from(e: v2::ErrorV2) -> Self {
        Self::V2(e)
    }
}

impl From<base64::DecodeError> for Error {
    fn from(e: base64::DecodeError) -> Self {
        Self::Base64Decode(e)
    }
}

/// Payload version
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u8)]
pub enum Version {
    /// V2 - Secp256k1 ECDH, HKDF, padding, ChaCha20, HMAC-SHA256 and base64
    #[default]
    V2 = 0x02,
}

impl Version {
    /// Get [`Version`] as `u8`
    #[inline]
    pub fn as_u8(&self) -> u8 {
        *self as u8
    }
}

impl TryFrom<u8> for Version {
    type Error = Error;

    fn try_from(version: u8) -> Result<Self, Self::Error> {
        match version {
            0x02 => Ok(Self::V2),
            v => Err(Error::UnknownVersion(v)),
        }
    }
}

/// Encrypt
#[inline]
#[cfg(feature = "std")]
pub fn encrypt<T>(
    secret_key: &SecretKey,
    public_key: &PublicKey,
    content: T,
    version: Version,
) -> Result<String, Error>
where
    T: AsRef<[u8]>,
{
    encrypt_with_rng(&mut OsRng, secret_key, public_key, content, version)
}

/// Encrypt
pub fn encrypt_with_rng<R, T>(
    rng: &mut R,
    secret_key: &SecretKey,
    public_key: &PublicKey,
    content: T,
    version: Version,
) -> Result<String, Error>
where
    R: RngCore,
    T: AsRef<[u8]>,
{
    match version {
        Version::V2 => {
            let conversation_key: ConversationKey = ConversationKey::derive(secret_key, public_key);
            let payload: Vec<u8> = v2::encrypt_to_bytes_with_rng(rng, &conversation_key, content)?;
            Ok(general_purpose::STANDARD.encode(payload))
        }
    }
}

/// Decrypt
#[inline]
pub fn decrypt<T>(
    secret_key: &SecretKey,
    public_key: &PublicKey,
    payload: T,
) -> Result<String, Error>
where
    T: AsRef<[u8]>,
{
    let bytes: Vec<u8> = decrypt_to_bytes(secret_key, public_key, payload)?;
    String::from_utf8(bytes.to_vec()).map_err(|_| Error::Utf8Encode)
}

/// Decrypt **without** converting bytes to UTF-8 string
pub fn decrypt_to_bytes<T>(
    secret_key: &SecretKey,
    public_key: &PublicKey,
    payload: T,
) -> Result<Vec<u8>, Error>
where
    T: AsRef<[u8]>,
{
    // Decode base64 payload
    let payload: Vec<u8> = general_purpose::STANDARD.decode(payload)?;

    // Get version byte
    let version: u8 = *payload.first().ok_or(Error::VersionNotFound)?;

    match Version::try_from(version)? {
        Version::V2 => {
            let conversation_key: ConversationKey = ConversationKey::derive(secret_key, public_key);
            v2::decrypt_to_bytes(&conversation_key, &payload)
        }
    }
}

#[cfg(test)]
#[cfg(feature = "std")]
mod tests {
    use core::str::FromStr;

    use super::*;
    use crate::Keys;

    #[test]
    fn test_nip44_encryption_decryption() {
        // Alice keys
        let alice_sk =
            SecretKey::from_str("5c0c523f52a5b6fad39ed2403092df8cebc36318b39383bca6c00808626fab3a")
                .unwrap();
        let alice_keys = Keys::new(alice_sk);
        let alice_pk = alice_keys.public_key();

        // Bob keys
        let bob_sk =
            SecretKey::from_str("4b22aa260e4acb7021e32f38a6cdf4b673c6a277755bfce287e370c924dc936d")
                .unwrap();
        let bob_keys = Keys::new(bob_sk);
        let bob_pk = bob_keys.public_key();

        let content = String::from("hello");
        let encrypted_content =
            encrypt(alice_keys.secret_key(), &bob_pk, &content, Version::V2).unwrap();
        assert_eq!(
            decrypt(bob_keys.secret_key(), &alice_pk, encrypted_content).unwrap(),
            content
        );
    }
}

================
File: src/nips/nip44/nip44.vectors.json
================
{
    "v2": {
      "valid": {
        "get_conversation_key": [
          {
            "sec1": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364139",
            "pub2": "0000000000000000000000000000000000000000000000000000000000000002",
            "conversation_key": "8b6392dbf2ec6a2b2d5b1477fc2be84d63ef254b667cadd31bd3f444c44ae6ba",
            "note": "sec1 = n-2, pub2: random, 0x02"
          },
          {
            "sec1": "0000000000000000000000000000000000000000000000000000000000000002",
            "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdeb",
            "conversation_key": "be234f46f60a250bef52a5ee34c758800c4ca8e5030bf4cc1a31d37ba2104d43",
            "note": "sec1 = 2, pub2: rand"
          },
          {
            "sec1": "0000000000000000000000000000000000000000000000000000000000000001",
            "pub2": "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
            "conversation_key": "3b4610cb7189beb9cc29eb3716ecc6102f1247e8f3101a03a1787d8908aeb54e",
            "note": "sec1 == pub2"
          }
        ],
        "calc_padded_len": [
          [16, 32],
          [32, 32],
          [33, 64],
          [37, 64],
          [45, 64],
          [49, 64],
          [64, 64],
          [65, 96],
          [100, 128],
          [111, 128],
          [200, 224],
          [250, 256],
          [320, 320],
          [383, 384],
          [384, 384],
          [400, 448],
          [500, 512],
          [512, 512],
          [515, 640],
          [700, 768],
          [800, 896],
          [900, 1024],
          [1020, 1024],
          [65536, 65536]
        ],
        "encrypt_decrypt": [
          {
            "sec1": "0000000000000000000000000000000000000000000000000000000000000001",
            "sec2": "0000000000000000000000000000000000000000000000000000000000000002",
            "conversation_key": "c41c775356fd92eadc63ff5a0dc1da211b268cbea22316767095b2871ea1412d",
            "nonce": "0000000000000000000000000000000000000000000000000000000000000001",
            "plaintext": "a",
            "ciphertext": "AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABee0G5VSK0/9YypIObAtDKfYEAjD35uVkHyB0F4DwrcNaCXlCWZKaArsGrY6M9wnuTMxWfp1RTN9Xga8no+kF5Vsb"
          },
          {
            "sec1": "0000000000000000000000000000000000000000000000000000000000000002",
            "sec2": "0000000000000000000000000000000000000000000000000000000000000001",
            "conversation_key": "c41c775356fd92eadc63ff5a0dc1da211b268cbea22316767095b2871ea1412d",
            "nonce": "f00000000000000000000000000000f00000000000000000000000000000000f",
            "plaintext": "",
            "ciphertext": "AvAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAAPSKSK6is9ngkX2+cSq85Th16oRTISAOfhStnixqZziKMDvB0QQzgFZdjLTPicCJaV8nDITO+QfaQ61+KbWQIOO2Yj"
          },
          {
            "sec1": "5c0c523f52a5b6fad39ed2403092df8cebc36318b39383bca6c00808626fab3a",
            "sec2": "4b22aa260e4acb7021e32f38a6cdf4b673c6a277755bfce287e370c924dc936d",
            "conversation_key": "3e2b52a63be47d34fe0a80e34e73d436d6963bc8f39827f327057a9986c20a45",
            "nonce": "b635236c42db20f021bb8d1cdff5ca75dd1a0cc72ea742ad750f33010b24f73b",
            "plaintext": "A",
            "ciphertext": "ArY1I2xC2yDwIbuNHN/1ynXdGgzHLqdCrXUPMwELJPc7s7JqlCMJBAIIjfkpHReBPXeoMCyuClwgbT419jUWU1PwaNl4FEQYKCDKVJz+97Mp3K+Q2YGa77B6gpxB/lr1QgoqpDf7wDVrDmOqGoiPjWDqy8KzLueKDcm9BVP8xeTJIxs="
          },
          {
            "sec1": "8f40e50a84a7462e2b8d24c28898ef1f23359fff50d8c509e6fb7ce06e142f9c",
            "sec2": "b9b0a1e9cc20100c5faa3bbe2777303d25950616c4c6a3fa2e3e046f936ec2ba",
            "conversation_key": "d5a2f879123145a4b291d767428870f5a8d9e5007193321795b40183d4ab8c2b",
            "nonce": "b20989adc3ddc41cd2c435952c0d59a91315d8c5218d5040573fc3749543acaf",
            "plaintext": "ability ",
            "ciphertext": "ArIJia3D3cQc0sQ1lSwNWakTFdjFIY1QQFc/w3SVQ6yvbG2S0x4Yu86QGwPTy7mP3961I1XqB6SFFTzqDZZavhxoWMj7mEVGMQIsh2RLWI5EYQaQDIePSnXPlzf7CIt+voTD"
          },
          {
            "sec1": "875adb475056aec0b4809bd2db9aa00cff53a649e7b59d8edcbf4e6330b0995c",
            "sec2": "9c05781112d5b0a2a7148a222e50e0bd891d6b60c5483f03456e982185944aae",
            "conversation_key": "3b15c977e20bfe4b8482991274635edd94f366595b1a3d2993515705ca3cedb8",
            "nonce": "8d4442713eb9d4791175cb040d98d6fc5be8864d6ec2f89cf0895a2b2b72d1b1",
            "plaintext": "pepper",
            "ciphertext": "Ao1EQnE+udR5EXXLBA2Y1vxb6IZNbsL4nPCJWisrctGxY3AduCS+jTUgAAnfvKafkmpy15+i9YMwCdccisRa8SvzW671T2JO4LFSPX31K4kYUKelSAdSPwe9NwO6LhOsnoJ+"
          },
          {
            "sec1": "eba1687cab6a3101bfc68fd70f214aa4cc059e9ec1b79fdb9ad0a0a4e259829f",
            "sec2": "dff20d262bef9dfd94666548f556393085e6ea421c8af86e9d333fa8747e94b3",
            "conversation_key": "4f1538411098cf11c8af216836444787c462d47f97287f46cf7edb2c4915b8a5",
            "nonce": "2180b52ae645fcf9f5080d81b1f0b5d6f2cd77ff3c986882bb549158462f3407",
            "plaintext": "(   )",
            "ciphertext": "AiGAtSrmRfz59QgNgbHwtdbyzXf/PJhogrtUkVhGLzQHv4qhKQwnFQ54OjVMgqCea/Vj0YqBSdhqNR777TJ4zIUk7R0fnizp6l1zwgzWv7+ee6u+0/89KIjY5q1wu6inyuiv"
          },
          {
            "sec1": "d5633530f5bcfebceb5584cfbbf718a30df0751b729dd9a789b9f30c0587d74e",
            "sec2": "b74e6a341fb134127272b795a08b59250e5fa45a82a2eb4095e4ce9ed5f5e214",
            "conversation_key": "75fe686d21a035f0c7cd70da64ba307936e5ca0b20710496a6b6b5f573377bdd",
            "nonce": "e4cd5f7ce4eea024bc71b17ad456a986a74ac426c2c62b0a15eb5c5c8f888b68",
            "plaintext": "          ",
            "ciphertext": "AuTNX3zk7qAkvHGxetRWqYanSsQmwsYrChXrXFyPiItoIBsWu1CB+sStla2M4VeANASHxM78i1CfHQQH1YbBy24Tng7emYW44ol6QkFD6D8Zq7QPl+8L1c47lx8RoODEQMvNCbOk5ffUV3/AhONHBXnffrI+0025c+uRGzfqpYki4lBqm9iYU+k3Tvjczq9wU0mkVDEaM34WiQi30MfkJdRbeeYaq6kNvGPunLb3xdjjs5DL720d61Flc5ZfoZm+CBhADy9D9XiVZYLKAlkijALJur9dATYKci6OBOoc2SJS2Clai5hOVzR0yVeyHRgRfH9aLSlWW5dXcUxTo7qqRjNf8W5+J4jF4gNQp5f5d0YA4vPAzjBwSP/5bGzNDslKfcAH"
          },
          {
            "sec1": "d5633530f5bcfebceb5584cfbbf718a30df0751b729dd9a789b9f30c0587d74e",
            "sec2": "b74e6a341fb134127272b795a08b59250e5fa45a82a2eb4095e4ce9ed5f5e214",
            "conversation_key": "75fe686d21a035f0c7cd70da64ba307936e5ca0b20710496a6b6b5f573377bdd",
            "nonce": "38d1ca0abef9e5f564e89761a86cee04574b6825d3ef2063b10ad75899e4b023",
            "plaintext": "    (5)",
            "ciphertext": "AjjRygq++eX1ZOiXYahs7gRXS2gl0+8gY7EK11iZ5LAjbOTrlfrxak5Lki42v2jMPpLSicy8eHjsWkkMtF0i925vOaKG/ZkMHh9ccQBdfTvgEGKzztedqDCAWb5TP1YwU1PsWaiiqG3+WgVvJiO4lUdMHXL7+zKKx8bgDtowzz4QAwI="
          },
          {
            "sec1": "d5633530f5bcfebceb5584cfbbf718a30df0751b729dd9a789b9f30c0587d74e",
            "sec2": "b74e6a341fb134127272b795a08b59250e5fa45a82a2eb4095e4ce9ed5f5e214",
            "conversation_key": "75fe686d21a035f0c7cd70da64ba307936e5ca0b20710496a6b6b5f573377bdd",
            "nonce": "4f1a31909f3483a9e69c8549a55bbc9af25fa5bbecf7bd32d9896f83ef2e12e0",
            "plaintext": " ",
            "ciphertext": "Ak8aMZCfNIOp5pyFSaVbvJryX6W77Pe9MtmJb4PvLhLgh/TsxPLFSANcT67EC1t/qxjru5ZoADjKVEt2ejdx+xGvH49mcdfbc+l+L7gJtkH7GLKpE9pQNQWNHMAmj043PAXJZ++fiJObMRR2mye5VHEANzZWkZXMrXF7YjuG10S1pOU="
          },
          {
            "sec1": "d5633530f5bcfebceb5584cfbbf718a30df0751b729dd9a789b9f30c0587d74e",
            "sec2": "b74e6a341fb134127272b795a08b59250e5fa45a82a2eb4095e4ce9ed5f5e214",
            "conversation_key": "75fe686d21a035f0c7cd70da64ba307936e5ca0b20710496a6b6b5f573377bdd",
            "nonce": "a3e219242d85465e70adcd640b564b3feff57d2ef8745d5e7a0663b2dccceb54",
            "plaintext": "   0 1 2 3 4 5 6 7 8 9  Power  h  ",
            "ciphertext": "AqPiGSQthUZecK3NZAtWSz/v9X0u+HRdXnoGY7LczOtUf05aMF89q1FLwJvaFJYICZoMYgRJHFLwPiOHce7fuAc40kX0wXJvipyBJ9HzCOj7CgtnC1/cmPCHR3s5AIORmroBWglm1LiFMohv1FSPEbaBD51VXxJa4JyWpYhreSOEjn1wd0lMKC9b+osV2N2tpbs+rbpQem2tRen3sWflmCqjkG5VOVwRErCuXuPb5+hYwd8BoZbfCrsiAVLd7YT44dRtKNBx6rkabWfddKSLtreHLDysOhQUVOp/XkE7OzSkWl6sky0Hva6qJJ/V726hMlomvcLHjE41iKmW2CpcZfOedg=="
          }
        ],
        "encrypt_decrypt_long_msg": [
          {
            "sec1": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364139",
            "pub2": "0000000000000000000000000000000000000000000000000000000000000002",
            "conversation_key": "7a1ccf5ce5a08e380f590de0c02776623b85a61ae67cfb6a017317e505b7cb51",
            "nonce": "a000000000000000000000000000000000000000000000000000000000000001",
            "letter": "",
            "repeat": 65535,
            "ciphertext_checksum": "",
            "note": "... (65535 times)"
          }
        ]
      },
      "invalid": {
        "encrypt_msg_lengths": [0, 65536, 100000, 10000000],
        "decrypt_msg_lengths": [0, 1, 2, 5, 10, 20, 32, 48, 64],
        "get_conversation_key": [
            {
              "sec1": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
              "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
              "note": "sec1 higher than curve.n"
            },
            {
              "sec1": "0000000000000000000000000000000000000000000000000000000000000000",
              "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
              "note": "sec1 is 0"
            },
            {
              "sec1": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364139",
              "pub2": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
              "note": "pub2 is invalid, no sqrt, all-ff"
            },
            {
              "sec1": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
              "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
              "note": "sec1 == curve.n"
            },
            {
              "sec1": "0000000000000000000000000000000000000000000000000000000000000002",
              "pub2": "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
              "note": "pub2 is invalid, no sqrt"
            },
            {
              "sec1": "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
              "pub2": "0000000000000000000000000000000000000000000000000000000000000000",
              "note": "pub2 is point of order 3 on twist"
            },
            {
              "sec1": "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
              "pub2": "eb1f7200aecaa86682376fb1c13cd12b732221e774f553b0a0857f88fa20f86d",
              "note": "pub2 is point of order 13 on twist"
            },
            {
              "sec1": "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20",
              "pub2": "709858a4c121e4a84eb59c0ded0261093c71e8ca29efeef21a6161c447bcaf9f",
              "note": "pub2 is point of order 3319 on twist"
            }
          ],
          "decrypt": [
            {
              "conversation_key": "cff7bd6a3e29a450fd27f6c125d5edeb0987c475fd1e8d97591e0d4d8a89763c",
              "nonce": "09ff97750b084012e15ecb84614ce88180d7b8ec0d468508a86b6d70c0361a25",
              "plaintext": "\\_()_/",
              "ciphertext": "Agn/l3ULCEAS4V7LhGFM6IGA17jsDUaFCKhrbXDANholyySBfeh+EN8wNB9gaLlg4j6wdBYh+3oK+mnxWu3NKRbSvQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
              "note": "invalid MAC"
            },
            {
              "conversation_key": "cfcc9cf682dfb00b11357f65bdc45e29156b69db424d20b3596919074f5bf957",
              "nonce": "65b14b0b949aaa7d52c417eb753b390e8ad6d84b23af4bec6d9bfa3e03a08af4",
              "plaintext": "",
              "ciphertext": "AmWxSwuUmqp9UsQX63U7OQ6K1thLI69L7G2b+j4DoIr0oRWQ8avl4OLqWZiTJ10vIgKrNqjoaX+fNhE9RqmR5g0f6BtUg1ijFMz71MO1D4lQLQfW7+UHva8PGYgQ1QpHlKgR",
              "note": "invalid MAC"
            },
            {
              "conversation_key": "5254827d29177622d40a7b67cad014fe7137700c3c523903ebbe3e1b74d40214",
              "nonce": "7ab65dbb8bbc2b8e35cafb5745314e1f050325a864d11d0475ef75b3660d91c1",
              "plaintext": "elliptic-curve cryptography",
              "ciphertext": "Anq2XbuLvCuONcr7V0UxTh8FAyWoZNEdBHXvdbNmDZHB573MI7R7rrTYftpqmvUpahmBC2sngmI14/L0HjOZ7lWGJlzdh6luiOnGPc46cGxf08MRC4CIuxx3i2Lm0KqgJ7vA",
              "note": "invalid padding"
            },
            {
              "conversation_key": "fea39aca9aa8340c3a78ae1f0902aa7e726946e4efcd7783379df8096029c496",
              "nonce": "7d4283e3b54c885d6afee881f48e62f0a3f5d7a9e1cb71ccab594a7882c39330",
              "plaintext": "noble",
              "ciphertext": "An1Cg+O1TIhdav7ogfSOYvCj9dep4ctxzKtZSniCw5MwRrrPJFyAQYZh5VpjC2QYzny5LIQ9v9lhqmZR4WBYRNJ0ognHVNMwiFV1SHpvUFT8HHZN/m/QarflbvDHAtO6pY16",
              "note": "invalid padding"
            },
            {
              "conversation_key": "0c4cffb7a6f7e706ec94b2e879f1fc54ff8de38d8db87e11787694d5392d5b3f",
              "nonce": "6f9fd72667c273acd23ca6653711a708434474dd9eb15c3edb01ce9a95743e9b",
              "plaintext": "censorship-resistant and global social network",
              "ciphertext": "Am+f1yZnwnOs0jymZTcRpwhDRHTdnrFcPtsBzpqVdD6b2NZDaNm/TPkZGr75kbB6tCSoq7YRcbPiNfJXNch3Tf+o9+zZTMxwjgX/nm3yDKR2kHQMBhVleCB9uPuljl40AJ8kXRD0gjw+aYRJFUMK9gCETZAjjmrsCM+nGRZ1FfNsHr6Z",
              "note": "invalid padding"
            }
          ]
      }
    }
  }

================
File: src/nips/nip44/v2.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP44 (v2)
//!
//! <https://github.com/nostr-protocol/nips/blob/master/44.md>

use alloc::string::{FromUtf8Error, String, ToString};
use alloc::vec;
use alloc::vec::Vec;
use core::array::TryFromSliceError;
use core::ops::{Deref, Range};
use core::{fmt, iter};

use bitcoin::hashes::hmac::{Hmac, HmacEngine};
use bitcoin::hashes::sha256::Hash as Sha256Hash;
use bitcoin::hashes::{FromSliceError, Hash, HashEngine};
#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::RngCore;
use chacha20::cipher::{KeyIvInit, StreamCipher};
use chacha20::ChaCha20;

use super::Error;
use crate::util::{self, hkdf};
use crate::{PublicKey, SecretKey};

const MESSAGE_KEYS_SIZE: usize = 76;
const MESSAGES_KEYS_ENCRYPTION_SIZE: usize = 32;
const MESSAGES_KEYS_NONCE_SIZE: usize = 12;
const MESSAGES_KEYS_ENCRYPTION_RANGE: Range<usize> = 0..MESSAGES_KEYS_ENCRYPTION_SIZE;
const MESSAGES_KEYS_NONCE_RANGE: Range<usize> =
    MESSAGES_KEYS_ENCRYPTION_SIZE..MESSAGES_KEYS_ENCRYPTION_SIZE + MESSAGES_KEYS_NONCE_SIZE;
const MESSAGES_KEYS_AUTH_RANGE: Range<usize> =
    MESSAGES_KEYS_ENCRYPTION_SIZE + MESSAGES_KEYS_NONCE_SIZE..MESSAGE_KEYS_SIZE;

/// Error
#[derive(Debug, PartialEq, Eq)]
pub enum ErrorV2 {
    /// From slice error
    FromSlice(FromSliceError),
    /// Error while encoding to UTF-8
    Utf8Encode(FromUtf8Error),
    /// Try from slice
    TryFromSlice(String),
    /// HKDF Length
    HkdfLength(usize),
    /// Message is empty
    MessageEmpty,
    /// Message is too long
    MessageTooLong,
    /// Invalid HMAC
    InvalidHmac,
    /// Invalid padding
    InvalidPadding,
}

#[cfg(feature = "std")]
impl std::error::Error for ErrorV2 {}

impl fmt::Display for ErrorV2 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::FromSlice(e) => write!(f, "{e}"),
            Self::Utf8Encode(e) => write!(f, "error while encoding to UTF-8: {e}"),
            Self::TryFromSlice(e) => write!(f, "try from slice error: {e}"),
            Self::HkdfLength(size) => write!(f, "invalid Length for HKDF: {size}"),
            Self::MessageEmpty => write!(f, "message empty"),
            Self::MessageTooLong => write!(f, "message too long"),
            Self::InvalidHmac => write!(f, "invalid HMAC"),
            Self::InvalidPadding => write!(f, "invalid padding"),
        }
    }
}

impl From<FromSliceError> for ErrorV2 {
    fn from(e: FromSliceError) -> Self {
        Self::FromSlice(e)
    }
}

impl From<FromUtf8Error> for ErrorV2 {
    fn from(e: FromUtf8Error) -> Self {
        Self::Utf8Encode(e)
    }
}

impl From<TryFromSliceError> for ErrorV2 {
    fn from(e: TryFromSliceError) -> Self {
        Self::TryFromSlice(e.to_string())
    }
}

struct MessageKeys([u8; MESSAGE_KEYS_SIZE]);

impl MessageKeys {
    #[inline]
    pub fn from_slice(slice: &[u8]) -> Result<Self, TryFromSliceError> {
        Ok(Self(slice.try_into()?))
    }

    #[inline]
    pub fn encryption(&self) -> &[u8] {
        &self.0[MESSAGES_KEYS_ENCRYPTION_RANGE]
    }

    #[inline]
    pub fn nonce(&self) -> &[u8] {
        &self.0[MESSAGES_KEYS_NONCE_RANGE]
    }

    #[inline]
    pub fn auth(&self) -> &[u8] {
        &self.0[MESSAGES_KEYS_AUTH_RANGE]
    }
}

/// NIP44 v2 Conversation Key
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct ConversationKey(Hmac<Sha256Hash>);

impl fmt::Debug for ConversationKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Conversation key: <sensitive>")
    }
}

impl Deref for ConversationKey {
    type Target = Hmac<Sha256Hash>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl ConversationKey {
    /// Construct conversation key from 32-byte array
    #[inline]
    pub fn new(bytes: [u8; 32]) -> Self {
        Self(Hmac::from_byte_array(bytes))
    }

    /// Derive Conversation Key
    #[inline]
    pub fn derive(secret_key: &SecretKey, public_key: &PublicKey) -> Self {
        let shared_key: [u8; 32] = util::generate_shared_key(secret_key, public_key);
        Self(hkdf::extract(b"nip44-v2", &shared_key))
    }

    /// Compose Conversation Key from bytes
    #[inline]
    pub fn from_slice(slice: &[u8]) -> Result<Self, Error> {
        Ok(Self(
            Hmac::from_slice(slice).map_err(|e| Error::from(ErrorV2::from(e)))?,
        ))
    }

    /// Get Conversation Key as bytes
    #[inline]
    pub fn as_bytes(&self) -> &[u8] {
        self.deref().as_byte_array()
    }
}

/// Encrypt with NIP44 (v2)
///
/// **The result is NOT encoded in base64!**
#[inline]
#[cfg(feature = "std")]
pub fn encrypt_to_bytes<T>(
    conversation_key: &ConversationKey,
    plaintext: T,
) -> Result<Vec<u8>, Error>
where
    T: AsRef<[u8]>,
{
    encrypt_to_bytes_with_rng(&mut OsRng, conversation_key, plaintext)
}

/// Encrypt with NIP44 (v2) using custom Rng
///
/// **The result is NOT encoded in base64!**
#[inline]
pub fn encrypt_to_bytes_with_rng<R, T>(
    rng: &mut R,
    conversation_key: &ConversationKey,
    plaintext: T,
) -> Result<Vec<u8>, Error>
where
    R: RngCore,
    T: AsRef<[u8]>,
{
    internal_encrypt_to_bytes_with_rng(rng, conversation_key, plaintext, None)
}

fn internal_encrypt_to_bytes_with_rng<R, T>(
    rng: &mut R,
    conversation_key: &ConversationKey,
    plaintext: T,
    override_random_nonce: Option<&[u8; 32]>,
) -> Result<Vec<u8>, Error>
where
    R: RngCore,
    T: AsRef<[u8]>,
{
    // Generate nonce
    let nonce: [u8; 32] = match override_random_nonce {
        Some(nonce) => *nonce,
        None => {
            let mut nonce: [u8; 32] = [0; 32];
            rng.fill_bytes(&mut nonce);
            nonce
        }
    };

    // Get Message Keys
    let keys: MessageKeys = get_message_keys(conversation_key, &nonce)?;

    // Pad
    let mut buffer: Vec<u8> = pad(plaintext)?;

    // Compose cipher and encrypt
    let mut cipher = ChaCha20::new(keys.encryption().into(), keys.nonce().into());
    cipher.apply_keystream(&mut buffer);

    // HMAC-SHA256
    let mut engine: HmacEngine<Sha256Hash> = HmacEngine::new(keys.auth());
    engine.input(&nonce);
    engine.input(&buffer);
    let hmac: [u8; 32] = Hmac::from_engine(engine).to_byte_array();

    // Compose payload
    let mut payload: Vec<u8> = vec![2]; // Version
    payload.extend_from_slice(&nonce);
    payload.extend_from_slice(&buffer);
    payload.extend_from_slice(&hmac);

    Ok(payload)
}

/// Decrypt with NIP44 (v2)
///
/// **The payload MUST be already decoded from base64**
pub fn decrypt_to_bytes<T>(conversation_key: &ConversationKey, payload: T) -> Result<Vec<u8>, Error>
where
    T: AsRef<[u8]>,
{
    // Get data from payload
    let payload: &[u8] = payload.as_ref();
    let len: usize = payload.len();
    let nonce: &[u8] = payload
        .get(1..33)
        .ok_or_else(|| Error::NotFound(String::from("nonce")))?;
    let buffer: &[u8] = payload
        .get(33..len - 32)
        .ok_or_else(|| Error::NotFound(String::from("buffer")))?;
    let mac: &[u8] = payload
        .get(len - 32..)
        .ok_or_else(|| Error::NotFound(String::from("hmac")))?;

    // Compose Message Keys
    let keys: MessageKeys = get_message_keys(conversation_key, nonce)?;

    // Check HMAC-SHA256
    let mut engine: HmacEngine<Sha256Hash> = HmacEngine::new(keys.auth());
    engine.input(nonce);
    engine.input(buffer);
    let calculated_mac: [u8; 32] = Hmac::from_engine(engine).to_byte_array();
    if mac != calculated_mac.as_slice() {
        return Err(ErrorV2::InvalidHmac.into());
    }

    // Compose cipher
    let mut cipher = ChaCha20::new(keys.encryption().into(), keys.nonce().into());
    let mut buffer: Vec<u8> = buffer.to_vec();
    cipher.apply_keystream(&mut buffer);

    let be_bytes: [u8; 2] = buffer[0..2]
        .try_into()
        .map_err(|e| Error::from(ErrorV2::from(e)))?;
    let unpadded_len: usize = u16::from_be_bytes(be_bytes) as usize;

    if buffer.len() < 2 + unpadded_len {
        return Err(ErrorV2::InvalidPadding.into());
    }

    let unpadded: &[u8] = &buffer[2..2 + unpadded_len];
    if unpadded.is_empty() {
        return Err(ErrorV2::MessageEmpty.into());
    }

    if unpadded.len() != unpadded_len {
        return Err(ErrorV2::InvalidPadding.into());
    }

    if buffer.len() != 2 + calc_padding(unpadded_len) {
        return Err(ErrorV2::InvalidPadding.into());
    }

    Ok(unpadded.to_vec())
}

#[inline]
fn get_message_keys(
    conversation_key: &ConversationKey,
    nonce: &[u8],
) -> Result<MessageKeys, ErrorV2> {
    let expanded_key: Vec<u8> = hkdf::expand(conversation_key.as_bytes(), nonce, MESSAGE_KEYS_SIZE);
    MessageKeys::from_slice(&expanded_key).map_err(|_| ErrorV2::HkdfLength(expanded_key.len()))
}

fn pad<T>(unpadded: T) -> Result<Vec<u8>, ErrorV2>
where
    T: AsRef<[u8]>,
{
    let unpadded: &[u8] = unpadded.as_ref();
    let len: usize = unpadded.len();

    if len < 1 {
        return Err(ErrorV2::MessageEmpty);
    }

    if len > 65536 - 128 {
        return Err(ErrorV2::MessageTooLong);
    }

    let take: usize = calc_padding(len) - len;
    let mut padded: Vec<u8> = Vec::with_capacity(2 + len + take);
    padded.extend_from_slice(&(len as u16).to_be_bytes());
    padded.extend_from_slice(unpadded);
    padded.extend(iter::repeat(0).take(take));
    Ok(padded)
}

#[inline]
fn calc_padding(len: usize) -> usize {
    if len <= 32 {
        return 32;
    }
    let nextpower: usize = 1 << (log2_round_down(len - 1) + 1);
    let chunk: usize = if nextpower <= 256 { 32 } else { nextpower / 8 };
    chunk * (((len - 1) / chunk) + 1)
}

/// Returns the base 2 logarithm of the number, rounded down.
#[inline]
fn log2_round_down(x: usize) -> u32 {
    if x == 0 {
        0
    } else {
        let x: f64 = x as f64;
        x.log2().floor() as u32
    }
}

#[cfg(test)]
#[cfg(feature = "std")]
mod tests {
    #![allow(dead_code)]

    use core::str::FromStr;

    use base64::engine::{general_purpose, Engine};

    use super::*;
    use crate::nips::nip44;
    use crate::Keys;

    const JSON_VECTORS: &str = include_str!("nip44.vectors.json");

    fn val(c: u8, idx: usize) -> u8 {
        match c {
            b'A'..=b'F' => c - b'A' + 10,
            b'a'..=b'f' => c - b'a' + 10,
            b'0'..=b'9' => c - b'0',
            _ => panic!("Invalid character {} at position {}", c as char, idx),
        }
    }

    pub fn hex_decode<T>(hex: T) -> Vec<u8>
    where
        T: AsRef<[u8]>,
    {
        let hex = hex.as_ref();
        let len = hex.len();

        if len % 2 != 0 {
            panic!("Odd number of digits");
        }

        let mut bytes: Vec<u8> = Vec::with_capacity(len / 2);

        for i in (0..len).step_by(2) {
            let high = val(hex[i], i);
            let low = val(hex[i + 1], i + 1);
            bytes.push(high << 4 | low);
        }

        bytes
    }

    #[test]
    fn test_valid_get_conversation_key() {
        let json: serde_json::Value = serde_json::from_str(JSON_VECTORS).unwrap();

        for vectorobj in json
            .as_object()
            .unwrap()
            .get("v2")
            .unwrap()
            .as_object()
            .unwrap()
            .get("valid")
            .unwrap()
            .as_object()
            .unwrap()
            .get("get_conversation_key")
            .unwrap()
            .as_array()
            .unwrap()
        {
            let vector = vectorobj.as_object().unwrap();

            let sec1 = {
                let sec1hex = vector.get("sec1").unwrap().as_str().unwrap();
                SecretKey::from_str(sec1hex).unwrap()
            };
            let pub2 = {
                let pub2hex = vector.get("pub2").unwrap().as_str().unwrap();
                PublicKey::from_str(pub2hex).unwrap()
            };
            let conversation_key: [u8; 32] = {
                let ckeyhex = vector.get("conversation_key").unwrap().as_str().unwrap();
                hex_decode(ckeyhex).try_into().unwrap()
            };
            let note = vector.get("note").unwrap().as_str().unwrap();

            let computed_conversation_key = ConversationKey::derive(&sec1, &pub2);

            assert_eq!(
                conversation_key,
                computed_conversation_key.to_byte_array(),
                "Conversation key failure on {}",
                note
            );
        }
    }

    #[test]
    fn test_valid_calc_padded_len() {
        let json: serde_json::Value = serde_json::from_str(JSON_VECTORS).unwrap();

        for elem in json
            .as_object()
            .unwrap()
            .get("v2")
            .unwrap()
            .as_object()
            .unwrap()
            .get("valid")
            .unwrap()
            .as_object()
            .unwrap()
            .get("calc_padded_len")
            .unwrap()
            .as_array()
            .unwrap()
        {
            let len = elem[0].as_number().unwrap().as_u64().unwrap() as usize;
            let pad = elem[1].as_number().unwrap().as_u64().unwrap() as usize;
            assert_eq!(calc_padding(len), pad);
        }
    }

    #[test]
    fn test_valid_encrypt_decrypt() {
        let json: serde_json::Value = serde_json::from_str(JSON_VECTORS).unwrap();

        for (i, vectorobj) in json
            .as_object()
            .unwrap()
            .get("v2")
            .unwrap()
            .as_object()
            .unwrap()
            .get("valid")
            .unwrap()
            .as_object()
            .unwrap()
            .get("encrypt_decrypt")
            .unwrap()
            .as_array()
            .unwrap()
            .iter()
            .enumerate()
        {
            let vector = vectorobj.as_object().unwrap();

            let sec1 = {
                let sec1hex = vector.get("sec1").unwrap().as_str().unwrap();
                SecretKey::from_str(sec1hex).unwrap()
            };
            let pub2 = {
                let sec2hex = vector.get("sec2").unwrap().as_str().unwrap();
                let secret_key = SecretKey::from_str(sec2hex).unwrap();
                Keys::new(secret_key).public_key()
            };
            let conversation_key: ConversationKey = {
                let ckeyhex = vector.get("conversation_key").unwrap().as_str().unwrap();
                ConversationKey::from_slice(&hex_decode(ckeyhex)).unwrap()
            };
            let nonce: [u8; 32] = {
                let noncehex = vector.get("nonce").unwrap().as_str().unwrap();
                hex_decode(noncehex).try_into().unwrap()
            };
            let plaintext = vector.get("plaintext").unwrap().as_str().unwrap();
            let ciphertext = vector.get("ciphertext").unwrap().as_str().unwrap();

            // Test conversation key
            let computed_conversation_key = ConversationKey::derive(&sec1, &pub2);
            assert_eq!(
                computed_conversation_key, conversation_key,
                "Conversation key failure on ValidSec #{}",
                i
            );

            // Test encryption with an overridden nonce
            let computed_ciphertext = internal_encrypt_to_bytes_with_rng(
                &mut OsRng,
                &conversation_key,
                plaintext,
                Some(&nonce),
            )
            .unwrap();
            let computed_ciphertext = general_purpose::STANDARD.encode(computed_ciphertext);
            assert_eq!(
                computed_ciphertext, ciphertext,
                "Encryption does not match on ValidSec #{}",
                i
            );

            // Test decryption
            let computed_plaintext = nip44::decrypt(&sec1, &pub2, ciphertext).unwrap();
            assert_eq!(
                computed_plaintext, plaintext,
                "Decryption does not match on ValidSec #{}",
                i
            );
        }
    }

    #[test]
    fn test_invalid_get_conversation_key() {
        let json: serde_json::Value = serde_json::from_str(JSON_VECTORS).unwrap();

        for vectorobj in json
            .as_object()
            .unwrap()
            .get("v2")
            .unwrap()
            .as_object()
            .unwrap()
            .get("invalid")
            .unwrap()
            .as_object()
            .unwrap()
            .get("get_conversation_key")
            .unwrap()
            .as_array()
            .unwrap()
        {
            let vector = vectorobj.as_object().unwrap();

            let sec1result = {
                let sec1hex = vector.get("sec1").unwrap().as_str().unwrap();
                SecretKey::from_str(sec1hex)
            };
            let pub2result = {
                let pub2hex = vector.get("pub2").unwrap().as_str().unwrap();
                PublicKey::from_str(pub2hex)
            };
            let note = vector.get("note").unwrap().as_str().unwrap();

            assert!(
                sec1result.is_err() || pub2result.is_err(),
                "One of the keys should have failed: {}",
                note
            );
        }
    }

    #[test]
    fn test_invalid_decrypt() {
        let json: serde_json::Value = serde_json::from_str(JSON_VECTORS).unwrap();

        let known_errors = [
            Error::V2(ErrorV2::InvalidHmac),
            Error::V2(ErrorV2::InvalidHmac),
            Error::V2(ErrorV2::InvalidPadding),
            Error::V2(ErrorV2::MessageEmpty),
            Error::V2(ErrorV2::InvalidPadding),
            Error::V2(ErrorV2::InvalidPadding),
        ];

        for (i, vectorobj) in json
            .as_object()
            .unwrap()
            .get("v2")
            .unwrap()
            .as_object()
            .unwrap()
            .get("invalid")
            .unwrap()
            .as_object()
            .unwrap()
            .get("decrypt")
            .unwrap()
            .as_array()
            .unwrap()
            .iter()
            .enumerate()
        {
            let vector = vectorobj.as_object().unwrap();
            let conversation_key: ConversationKey = {
                let ckeyhex = vector.get("conversation_key").unwrap().as_str().unwrap();
                ConversationKey::from_slice(&hex_decode(ckeyhex)).unwrap()
            };
            let ciphertext = vector.get("ciphertext").unwrap().as_str().unwrap();
            let note = vector.get("note").unwrap().as_str().unwrap();

            let payload: Vec<u8> = general_purpose::STANDARD.decode(ciphertext).unwrap();
            let result = decrypt_to_bytes(&conversation_key, &payload);
            assert!(result.is_err(), "Should not have decrypted: {}", note);

            let err = result.unwrap_err();
            assert_eq!(
                err, known_errors[i],
                "Unexpected error in invalid decrypt #{}",
                i
            );
        }
    }
}

================
File: src/nips/mod.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIPs
//!
//! See all at <https://github.com/nostr-protocol/nips>

pub mod nip01;
#[cfg(feature = "nip04")]
pub mod nip04;
#[cfg(all(feature = "std", feature = "nip05"))]
pub mod nip05;
#[cfg(feature = "nip06")]
pub mod nip06;
#[cfg(all(feature = "nip07", target_arch = "wasm32"))]
pub mod nip07;
pub mod nip10;
#[cfg(all(feature = "std", feature = "nip11"))]
pub mod nip11;
pub mod nip13;
pub mod nip15;
pub mod nip17;
pub mod nip19;
pub mod nip21;
pub mod nip26;
pub mod nip34;
pub mod nip39;
#[cfg(feature = "nip44")]
pub mod nip44;
#[cfg(all(feature = "std", feature = "nip46"))]
pub mod nip46;
#[cfg(feature = "nip47")]
pub mod nip47;
pub mod nip48;
#[cfg(feature = "nip49")]
pub mod nip49;
pub mod nip51;
pub mod nip53;
pub mod nip56;
#[cfg(feature = "nip57")]
pub mod nip57;
pub mod nip58;
#[cfg(feature = "nip59")]
pub mod nip59;
pub mod nip65;
pub mod nip73;
pub mod nip90;
pub mod nip94;
pub mod nip98;

================
File: src/nips/nip01.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP01: Basic protocol flow description
//!
//! <https://github.com/nostr-protocol/nips/blob/master/01.md>

use alloc::borrow::ToOwned;
use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;
use core::num::ParseIntError;
use core::str::FromStr;

use super::nip19::FromBech32;
use super::nip21::NostrURI;
use crate::event::id;
use crate::types::RelayUrl;
use crate::{key, Filter, Kind, PublicKey, Tag, TagStandard};

/// Raw Event error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Keys error
    Keys(key::Error),
    /// Event ID error
    EventId(id::Error),
    /// Parse Int error
    ParseInt(ParseIntError),
    /// Invalid coordinate
    InvalidCoordinate,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Keys(e) => write!(f, "Keys: {e}"),
            Self::EventId(e) => write!(f, "Event ID: {e}"),
            Self::ParseInt(e) => write!(f, "Parse Int: {e}"),
            Self::InvalidCoordinate => write!(f, "Invalid coordinate"),
        }
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Keys(e)
    }
}

impl From<id::Error> for Error {
    fn from(e: id::Error) -> Self {
        Self::EventId(e)
    }
}

impl From<ParseIntError> for Error {
    fn from(e: ParseIntError) -> Self {
        Self::ParseInt(e)
    }
}

/// Coordinate for event (`a` tag)
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Coordinate {
    /// Kind
    pub kind: Kind,
    /// Public Key
    pub public_key: PublicKey,
    /// `d` tag identifier
    ///
    /// Needed for a parametrized replaceable event.
    /// Leave empty for a replaceable event.
    pub identifier: String,
    /// Relays
    pub relays: Vec<RelayUrl>,
}

impl Coordinate {
    /// Create new event coordinate
    #[inline]
    pub fn new(kind: Kind, public_key: PublicKey) -> Self {
        Self {
            kind,
            public_key,
            identifier: String::new(),
            relays: Vec::new(),
        }
    }

    /// Parse coordinate from `<kind>:<pubkey>:[<d-tag>]` format, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    pub fn parse<S>(coordinate: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let coordinate: &str = coordinate.as_ref();

        // Try from hex
        if let Ok(coordinate) = Self::from_kpi_format(coordinate) {
            return Ok(coordinate);
        }

        // Try from bech32
        if let Ok(coordinate) = Self::from_bech32(coordinate) {
            return Ok(coordinate);
        }

        // Try from NIP21 URI
        if let Ok(coordinate) = Self::from_nostr_uri(coordinate) {
            return Ok(coordinate);
        }

        Err(Error::InvalidCoordinate)
    }

    /// Try to parse from `<kind>:<pubkey>:[<d-tag>]` format
    pub fn from_kpi_format<S>(coordinate: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let coordinate: &str = coordinate.as_ref();
        let mut kpi = coordinate.split(':');
        if let (Some(kind_str), Some(public_key_str), Some(identifier)) =
            (kpi.next(), kpi.next(), kpi.next())
        {
            Ok(Self {
                kind: Kind::from_str(kind_str)?,
                public_key: PublicKey::from_hex(public_key_str)?,
                identifier: identifier.to_owned(),
                relays: Vec::new(),
            })
        } else {
            Err(Error::InvalidCoordinate)
        }
    }

    /// Set a `d` tag identifier
    ///
    /// Needed for a parametrized replaceable event.
    pub fn identifier<S>(mut self, identifier: S) -> Self
    where
        S: Into<String>,
    {
        self.identifier = identifier.into();
        self
    }

    /// Check if coordinate has identifier
    #[inline]
    pub fn has_identifier(&self) -> bool {
        !self.identifier.is_empty()
    }
}

impl From<Coordinate> for Tag {
    fn from(coordinate: Coordinate) -> Self {
        Self::from_standardized(TagStandard::Coordinate {
            relay_url: coordinate.relays.first().cloned(),
            coordinate,
            uppercase: false,
        })
    }
}

impl From<Coordinate> for Filter {
    fn from(value: Coordinate) -> Self {
        if value.identifier.is_empty() {
            Filter::new().kind(value.kind).author(value.public_key)
        } else {
            Filter::new()
                .kind(value.kind)
                .author(value.public_key)
                .identifier(value.identifier)
        }
    }
}

impl From<&Coordinate> for Filter {
    fn from(value: &Coordinate) -> Self {
        if value.identifier.is_empty() {
            Filter::new().kind(value.kind).author(value.public_key)
        } else {
            Filter::new()
                .kind(value.kind)
                .author(value.public_key)
                .identifier(value.identifier.clone())
        }
    }
}

impl fmt::Display for Coordinate {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}:{}", self.kind, self.public_key, self.identifier)
    }
}

impl FromStr for Coordinate {
    type Err = Error;

    /// Try to parse [Coordinate] from `<kind>:<pubkey>:[<d-tag>]` format, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    #[inline]
    fn from_str(coordinate: &str) -> Result<Self, Self::Err> {
        Self::parse(coordinate)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_valid_coordinate() {
        let coordinate: &str =
            "30023:aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4:ipsum";
        let coordinate: Coordinate = Coordinate::parse(coordinate).unwrap();

        let expected_public_key: PublicKey =
            PublicKey::from_hex("aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4")
                .unwrap();

        assert_eq!(coordinate.kind.as_u16(), 30023);
        assert_eq!(coordinate.public_key, expected_public_key);
        assert_eq!(coordinate.identifier, "ipsum");

        let coordinate: &str =
            "20500:aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4:";
        let coordinate: Coordinate = Coordinate::parse(coordinate).unwrap();

        assert_eq!(coordinate.kind.as_u16(), 20500);
        assert_eq!(coordinate.public_key, expected_public_key);
        assert_eq!(coordinate.identifier, "");
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    #[bench]
    pub fn parse_coordinate(bh: &mut Bencher) {
        let coordinate: &str =
            "30023:aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4:ipsum";
        bh.iter(|| {
            black_box(Coordinate::parse(coordinate)).unwrap();
        });
    }
}

================
File: src/nips/nip04.rs
================
// Copyright (c) 2021 Paul Miller
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP04: Encrypted Direct Message (deprecated in favor of NIP17)
//!
//! <div class="warning"><strong>Unsecure!</strong> Deprecated in favor of NIP17!</div>
//!
//! <https://github.com/nostr-protocol/nips/blob/master/04.md>

use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;

use aes::cipher::block_padding::Pkcs7;
use aes::cipher::{BlockDecryptMut, BlockEncryptMut, KeyIvInit};
use aes::Aes256;
use base64::engine::{general_purpose, Engine};
#[cfg(feature = "std")]
use bitcoin::secp256k1::rand;
use bitcoin::secp256k1::rand::RngCore;
use cbc::{Decryptor, Encryptor};

use crate::{util, PublicKey, SecretKey};

type Aes256CbcEnc = Encryptor<Aes256>;
type Aes256CbcDec = Decryptor<Aes256>;

/// `NIP04` error
#[derive(Debug, Eq, PartialEq)]
pub enum Error {
    /// Invalid content format
    InvalidContentFormat,
    /// Error while decoding from base64
    Base64Decode,
    /// Error while encoding to UTF-8
    Utf8Encode,
    /// Wrong encryption block mode
    WrongBlockMode,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidContentFormat => write!(f, "Invalid NIP04 content format"),
            Self::Base64Decode => write!(f, "Error while decoding NIP04 from base64"),
            Self::Utf8Encode => write!(f, "Error while encoding NIP04 to UTF-8"),
            Self::WrongBlockMode => write!(
                f,
                "Wrong encryption block mode. The content must be encrypted using CBC mode!"
            ),
        }
    }
}

/// Encrypt
///
/// <div class="warning"><strong>Unsecure!</strong> Deprecated in favor of NIP17!</div>
#[inline]
#[cfg(feature = "std")]
pub fn encrypt<T>(
    secret_key: &SecretKey,
    public_key: &PublicKey,
    content: T,
) -> Result<String, Error>
where
    T: AsRef<[u8]>,
{
    encrypt_with_rng(&mut rand::thread_rng(), secret_key, public_key, content)
}

/// Encrypt
///
/// <div class="warning"><strong>Unsecure!</strong> Deprecated in favor of NIP17!</div>
pub fn encrypt_with_rng<R, T>(
    rng: &mut R,
    secret_key: &SecretKey,
    public_key: &PublicKey,
    content: T,
) -> Result<String, Error>
where
    R: RngCore,
    T: AsRef<[u8]>,
{
    // Generate key
    let key: [u8; 32] = util::generate_shared_key(secret_key, public_key);

    // Generate iv
    let mut iv: [u8; 16] = [0u8; 16];
    rng.fill_bytes(&mut iv);

    // Compose cipher
    let cipher = Aes256CbcEnc::new(&key.into(), &iv.into());

    // Encrypt
    let result: Vec<u8> = cipher.encrypt_padded_vec_mut::<Pkcs7>(content.as_ref());

    // Encode with base64
    Ok(format!(
        "{}?iv={}",
        general_purpose::STANDARD.encode(result),
        general_purpose::STANDARD.encode(iv)
    ))
}

/// Decrypts content to bytes
///
/// <div class="warning"><strong>Unsecure!</strong> Deprecated in favor of NIP17!</div>
pub fn decrypt_to_bytes<S>(
    secret_key: &SecretKey,
    public_key: &PublicKey,
    encrypted_content: S,
) -> Result<Vec<u8>, Error>
where
    S: Into<String>,
{
    let encrypted_content: String = encrypted_content.into();
    let parsed_content: Vec<&str> = encrypted_content.split("?iv=").collect();
    if parsed_content.len() != 2 {
        return Err(Error::InvalidContentFormat);
    }

    let encrypted_content: Vec<u8> = general_purpose::STANDARD
        .decode(parsed_content[0])
        .map_err(|_| Error::Base64Decode)?;
    let iv: Vec<u8> = general_purpose::STANDARD
        .decode(parsed_content[1])
        .map_err(|_| Error::Base64Decode)?;
    let key: [u8; 32] = util::generate_shared_key(secret_key, public_key);

    let cipher = Aes256CbcDec::new(&key.into(), iv.as_slice().into());
    let result = cipher
        .decrypt_padded_vec_mut::<Pkcs7>(&encrypted_content)
        .map_err(|_| Error::WrongBlockMode)?;

    Ok(result)
}

/// Decrypts content to a UTF-8 string
///
/// <div class="warning"><strong>Unsecure!</strong> Deprecated in favor of NIP17!</div>
#[inline]
pub fn decrypt<T>(
    secret_key: &SecretKey,
    public_key: &PublicKey,
    encrypted_content: T,
) -> Result<String, Error>
where
    T: Into<String>,
{
    let result = decrypt_to_bytes(secret_key, public_key, encrypted_content)?;
    String::from_utf8(result).map_err(|_| Error::Utf8Encode)
}

#[cfg(test)]
#[cfg(feature = "std")]
mod tests {
    use core::str::FromStr;

    use super::*;
    use crate::Keys;

    #[test]
    fn test_encryption_decryption() {
        let sender_sk =
            SecretKey::from_str("6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e")
                .unwrap();
        let sender_keys = Keys::new(sender_sk);
        let sender_pk = sender_keys.public_key();

        let receiver_sk =
            SecretKey::from_str("7b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e")
                .unwrap();
        let receiver_keys = Keys::new(receiver_sk);
        let receiver_pk = receiver_keys.public_key();

        let encrypted_content_from_outside =
            "dJc+WbBgaFCD2/kfg1XCWJParplBDxnZIdJGZ6FCTOg=?iv=M6VxRPkMZu7aIdD+10xPuw==";

        let content = String::from("Saturn, bringer of old age");

        let encrypted_content = encrypt(sender_keys.secret_key(), &receiver_pk, &content).unwrap();

        assert_eq!(
            decrypt(receiver_keys.secret_key(), &sender_pk, encrypted_content).unwrap(),
            content
        );

        assert_eq!(
            decrypt(
                receiver_keys.secret_key(),
                &sender_pk,
                encrypted_content_from_outside
            )
            .unwrap(),
            content
        );

        assert_eq!(
            decrypt(
                sender_keys.secret_key(),
                &receiver_pk,
                "invalidcontentformat"
            )
            .unwrap_err(),
            Error::InvalidContentFormat
        );
        assert_eq!(
            decrypt(
                sender_keys.secret_key(),
                &receiver_pk,
                "badbase64?iv=encode"
            )
            .unwrap_err(),
            Error::Base64Decode
        );

        // Content encrypted with aes256 using GCM mode
        assert_eq!(
            decrypt(
                sender_keys.secret_key(),
                &receiver_pk,
                "nseh0cQPEFID5C0CxYdcPwp091NhRQ==?iv=8PHy8/T19vf4+fr7/P3+/w=="
            )
            .unwrap_err(),
            Error::WrongBlockMode
        );
    }
}

================
File: src/nips/nip05.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP05: Mapping Nostr keys to DNS-based internet identifiers
//!
//! <https://github.com/nostr-protocol/nips/blob/master/05.md>

use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;
use std::net::SocketAddr;

#[cfg(not(target_arch = "wasm32"))]
use reqwest::Proxy;
use reqwest::{Client, Response};
use serde_json::Value;

use crate::{key, PublicKey, RelayUrl};

/// `NIP05` error
#[derive(Debug)]
pub enum Error {
    /// Invalid format
    InvalidFormat,
    /// Impossible to verify
    ImpossibleToVerify,
    /// Reqwest error
    Reqwest(reqwest::Error),
    /// Error deserializing JSON data
    Json(serde_json::Error),
    /// Keys error
    Keys(key::Error),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidFormat => write!(f, "invalid format"),
            Self::ImpossibleToVerify => write!(f, "impossible to verify"),
            Self::Reqwest(e) => write!(f, "{e}"),
            Self::Json(e) => write!(f, "impossible to deserialize NIP05 data: {e}"),
            Self::Keys(e) => write!(f, "{e}"),
        }
    }
}

impl From<reqwest::Error> for Error {
    fn from(e: reqwest::Error) -> Self {
        Self::Reqwest(e)
    }
}

impl From<serde_json::Error> for Error {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e)
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Keys(e)
    }
}

/// NIP05 profile
///
/// <https://github.com/nostr-protocol/nips/blob/master/05.md>
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Nip05Profile {
    /// Public key
    pub public_key: PublicKey,
    /// Relays
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/05.md>
    pub relays: Vec<RelayUrl>,
    /// NIP46 relays
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/46.md>
    pub nip46: Vec<RelayUrl>,
}

fn compose_url(nip05: &str) -> Result<(String, &str), Error> {
    let mut split = nip05.split('@');
    if let (Some(name), Some(domain)) = (split.next(), split.next()) {
        let url = format!("https://{domain}/.well-known/nostr.json?name={name}");
        return Ok((url, name));
    }
    Err(Error::InvalidFormat)
}

#[inline]
fn get_key_from_json(json: &Value, name: &str) -> Option<PublicKey> {
    json.get("names")
        .and_then(|names| names.get(name))
        .and_then(|value| value.as_str())
        .and_then(|pubkey| PublicKey::from_hex(pubkey).ok())
}

#[inline]
fn get_relays_from_json(json: &Value, pk: &PublicKey) -> Vec<RelayUrl> {
    json.get("relays")
        .and_then(|relays| relays.get(pk.to_hex()))
        .and_then(|value| serde_json::from_value(value.clone()).ok())
        .unwrap_or_default()
}

#[inline]
fn get_nip46_relays_from_json(json: &Value, pk: &PublicKey) -> Vec<RelayUrl> {
    json.get("nip46")
        .and_then(|relays| relays.get(pk.to_hex()))
        .and_then(|value| serde_json::from_value(value.clone()).ok())
        .unwrap_or_default()
}

fn verify_from_json(public_key: &PublicKey, json: &Value, name: &str) -> bool {
    if let Some(pubkey) = get_key_from_json(json, name) {
        if &pubkey == public_key {
            return true;
        }
    }

    false
}

async fn make_req(nip05: &str, _proxy: Option<SocketAddr>) -> Result<(Value, &str), Error> {
    let (url, name) = compose_url(nip05)?;

    #[cfg(not(target_arch = "wasm32"))]
    let client: Client = {
        let mut builder = Client::builder();
        if let Some(proxy) = _proxy {
            let proxy = format!("socks5h://{proxy}");
            builder = builder.proxy(Proxy::all(proxy)?);
        }
        builder.build()?
    };

    #[cfg(target_arch = "wasm32")]
    let client: Client = Client::new();

    let res: Response = client.get(url).send().await?;
    let json: Value = res.json().await?;

    Ok((json, name))
}

/// Verify NIP05
///
/// **Proxy is ignored for WASM targets!**
///
/// <https://github.com/nostr-protocol/nips/blob/master/05.md>
pub async fn verify<S>(
    public_key: &PublicKey,
    nip05: S,
    _proxy: Option<SocketAddr>,
) -> Result<bool, Error>
where
    S: AsRef<str>,
{
    let (json, name) = make_req(nip05.as_ref(), _proxy).await?;
    Ok(verify_from_json(public_key, &json, name))
}

/// Get NIP05 profile
///
/// **Proxy is ignored for WASM targets!**
///
/// <https://github.com/nostr-protocol/nips/blob/master/05.md>
pub async fn profile<S>(nip05: S, _proxy: Option<SocketAddr>) -> Result<Nip05Profile, Error>
where
    S: AsRef<str>,
{
    let (json, name) = make_req(nip05.as_ref(), _proxy).await?;

    let public_key: PublicKey = get_key_from_json(&json, name).ok_or(Error::ImpossibleToVerify)?;
    let relays: Vec<RelayUrl> = get_relays_from_json(&json, &public_key);
    let nip46: Vec<RelayUrl> = get_nip46_relays_from_json(&json, &public_key);

    Ok(Nip05Profile {
        public_key,
        relays,
        nip46,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_verify_nip05() {
        // nostr.json
        let json: &str = r#"{
            "names": {
              "yuki": "68d81165918100b7da43fc28f7d1fc12554466e1115886b9e7bb326f65ec4272",
              "_": "68d81165918100b7da43fc28f7d1fc12554466e1115886b9e7bb326f65ec4272"
            }
          }"#;
        let json: Value = serde_json::from_str(json).unwrap();

        let (url, name) = compose_url("_@yukikishimoto.com").unwrap();
        assert_eq!(
            url,
            "https://yukikishimoto.com/.well-known/nostr.json?name=_"
        );
        assert_eq!(name, "_");

        let public_key =
            PublicKey::from_hex("68d81165918100b7da43fc28f7d1fc12554466e1115886b9e7bb326f65ec4272")
                .unwrap();
        assert!(verify_from_json(&public_key, &json, name));
        assert!(verify_from_json(&public_key, &json, "yuki"));

        let public_key =
            PublicKey::from_hex("b2d670de53b27691c0c3400225b65c35a26d06093bcc41f48ffc71e0907f9d4a")
                .unwrap();
        assert!(!verify_from_json(&public_key, &json, "yuki"));
    }
}

================
File: src/nips/nip06.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP06: Basic key derivation from mnemonic seed phrase
//!
//! <https://github.com/nostr-protocol/nips/blob/master/06.md>

use alloc::vec;
use alloc::vec::Vec;
use core::fmt;
use core::str::FromStr;

use bip39::Mnemonic;
use bitcoin::bip32::{ChildNumber, DerivationPath, Xpriv};
use bitcoin::secp256k1::{Secp256k1, Signing};
use bitcoin::Network;

#[cfg(feature = "std")]
use crate::SECP256K1;
use crate::{Keys, SecretKey};

const PURPOSE: u32 = 44;
const COIN: u32 = 1237;

/// `NIP06` error
#[derive(Debug, Eq, PartialEq)]
pub enum Error {
    /// BIP32 error
    BIP32(bitcoin::bip32::Error),
    /// BIP39 error
    BIP39(bip39::Error),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::BIP32(e) => write!(f, "BIP32: {e}"),
            Self::BIP39(e) => write!(f, "BIP39: {e}"),
        }
    }
}

impl From<bitcoin::bip32::Error> for Error {
    fn from(e: bitcoin::bip32::Error) -> Self {
        Self::BIP32(e)
    }
}

impl From<bip39::Error> for Error {
    fn from(e: bip39::Error) -> Self {
        Self::BIP39(e)
    }
}

/// NIP06 utils
///
/// <https://github.com/nostr-protocol/nips/blob/master/06.md>
pub trait FromMnemonic: Sized {
    /// Error
    type Err;

    /// Derive from BIP-39 mnemonics (ENGLISH wordlist).
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/06.md>
    #[inline]
    #[cfg(feature = "std")]
    fn from_mnemonic<S>(mnemonic: S, passphrase: Option<S>) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        Self::from_mnemonic_with_account(mnemonic, passphrase, None)
    }

    /// Derive from BIP-39 mnemonics with **custom account** (ENGLISH wordlist).
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/06.md>
    #[inline]
    #[cfg(feature = "std")]
    fn from_mnemonic_with_account<S>(
        mnemonic: S,
        passphrase: Option<S>,
        account: Option<u32>,
    ) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        Self::from_mnemonic_advanced(mnemonic, passphrase, account, None, None)
    }

    /// Derive from BIP-39 mnemonics with **custom** `account`, `type` and/or `index` (ENGLISH wordlist).
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/06.md>
    #[inline]
    #[cfg(feature = "std")]
    fn from_mnemonic_advanced<S>(
        mnemonic: S,
        passphrase: Option<S>,
        account: Option<u32>,
        r#type: Option<u32>,
        index: Option<u32>,
    ) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        Self::from_mnemonic_with_ctx(&SECP256K1, mnemonic, passphrase, account, r#type, index)
    }

    /// Derive from BIP-39 mnemonics with **custom account** (ENGLISH wordlist).
    ///
    /// By default `account`, `type` and `index` are set to `0`.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/06.md>
    fn from_mnemonic_with_ctx<C, S>(
        secp: &Secp256k1<C>,
        mnemonic: S,
        passphrase: Option<S>,
        account: Option<u32>,
        r#type: Option<u32>,
        index: Option<u32>,
    ) -> Result<Self, Self::Err>
    where
        C: Signing,
        S: AsRef<str>;
}

impl FromMnemonic for Keys {
    type Err = Error;

    fn from_mnemonic_with_ctx<C, S>(
        secp: &Secp256k1<C>,
        mnemonic: S,
        passphrase: Option<S>,
        account: Option<u32>,
        r#type: Option<u32>,
        index: Option<u32>,
    ) -> Result<Self, Self::Err>
    where
        C: Signing,
        S: AsRef<str>,
    {
        // Parse menmonic
        let mnemonic: Mnemonic = Mnemonic::from_str(mnemonic.as_ref())?;

        // Convert mnemonic to seed
        let seed: [u8; 64] = mnemonic
            .to_seed_normalized(passphrase.as_ref().map(|s| s.as_ref()).unwrap_or_default());

        // Derive BIP32 root key
        let root_key = Xpriv::new_master(Network::Bitcoin, &seed)?;

        // Unwrap idx
        let account: u32 = account.unwrap_or_default();
        let _type: u32 = r#type.unwrap_or_default();
        let index: u32 = index.unwrap_or_default();

        // Compose derivation path
        let path: Vec<ChildNumber> = vec![
            ChildNumber::from_hardened_idx(PURPOSE)?,
            ChildNumber::from_hardened_idx(COIN)?,
            ChildNumber::from_hardened_idx(account)?,
            ChildNumber::from_normal_idx(_type)?,
            ChildNumber::from_normal_idx(index)?,
        ];
        let path = DerivationPath::from(path);

        // Derive secret key
        let child_xprv = root_key.derive_priv(secp, &path)?;
        let secret_key = SecretKey::from(child_xprv.private_key);

        // Compose keys
        Ok(Self::new_with_ctx(secp, secret_key))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_nip06() {
        let secp = Secp256k1::new();

        let list = vec![
            ("equal dragon fabric refuse stable cherry smoke allow alley easy never medal attend together lumber movie what sad siege weather matrix buffalo state shoot", "06992419a8fe821dd8de03d4c300614e8feefb5ea936b76f89976dcace8aebee"),
            ("leader monkey parrot ring guide accident before fence cannon height naive bean", "7f7ff03d123792d6ac594bfa67bf6d0c0ab55b6b1fdb6249303fe861f1ccba9a"),
            ("what bleak badge arrange retreat wolf trade produce cricket blur garlic valid proud rude strong choose busy staff weather area salt hollow arm fade", "c15d739894c81a2fcfd3a2df85a0d2c0dbc47a280d092799f144d73d7ae78add"),
        ];

        for (mnemonic, expected_secret_key) in list.into_iter() {
            let keys =
                Keys::from_mnemonic_with_ctx(&secp, mnemonic, None, None, None, None).unwrap();
            assert_eq!(
                keys.secret_key(),
                &SecretKey::from_str(expected_secret_key).unwrap()
            );
        }
    }
}

================
File: src/nips/nip07.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP07: `window.nostr` capability for web browsers
//!
//! <https://github.com/nostr-protocol/nips/blob/master/07.md>

use alloc::string::{String, ToString};
use core::fmt;
use core::str::FromStr;

use async_trait::async_trait;
use bitcoin::secp256k1;
use bitcoin::secp256k1::schnorr::Signature;
use js_sys::{Array, Function, Object, Promise, Reflect};
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;
use web_sys::Window;

use crate::event::{self, unsigned};
use crate::signer::{NostrSigner, SignerBackend, SignerError};
use crate::{key, Event, PublicKey, UnsignedEvent};

/// NIP07 error
#[derive(Debug)]
pub enum Error {
    /// Secp256k1 error
    Secp256k1(secp256k1::Error),
    /// Keys error
    Keys(key::Error),
    /// Event error
    Event(event::Error),
    /// Unsigned error
    Unsigned(unsigned::Error),
    /// Generic WASM error
    Wasm(String),
    /// Impossible to get window
    NoGlobalWindowObject,
    /// Impossible to get window
    NamespaceNotFound(String),
    /// Object key not found
    ObjectKeyNotFound(String),
    /// Invalid type: expected a string
    TypeMismatch(String),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Secp256k1(e) => write!(f, "Secp256k1: {e}"),
            Self::Keys(e) => write!(f, "Keys: {e}"),
            Self::Event(e) => write!(f, "Event: {e}"),
            Self::Unsigned(e) => write!(f, "Unsigned event: {e}"),
            Self::Wasm(e) => write!(f, "{e}"),
            Self::NoGlobalWindowObject => write!(f, "No global `window` object"),
            Self::NamespaceNotFound(n) => write!(f, "`{n}` namespace not found"),
            Self::ObjectKeyNotFound(n) => write!(f, "Key `{n}` not found in object"),
            Self::TypeMismatch(e) => write!(f, "Type mismatch: {e}"),
        }
    }
}

impl From<secp256k1::Error> for Error {
    fn from(e: secp256k1::Error) -> Self {
        Self::Secp256k1(e)
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Keys(e)
    }
}

impl From<event::Error> for Error {
    fn from(e: event::Error) -> Self {
        Self::Event(e)
    }
}

impl From<unsigned::Error> for Error {
    fn from(e: unsigned::Error) -> Self {
        Self::Unsigned(e)
    }
}

impl From<JsValue> for Error {
    #[inline]
    fn from(e: JsValue) -> Self {
        Self::Wasm(format!("{e:?}"))
    }
}

/// NIP07 Signer for interaction with browser extensions (ex. Alby)
///
/// <https://github.com/aljazceru/awesome-nostr#nip-07-browser-extensions>
#[derive(Debug, Clone)]
pub struct Nip07Signer {
    /// `window.nostr` object
    nostr_obj: Object,
}

impl Nip07Signer {
    /// Compose new NIP07 Signer
    pub fn new() -> Result<Self, Error> {
        let window: Window = web_sys::window().ok_or(Error::NoGlobalWindowObject)?;
        let namespace: JsValue = Reflect::get(&window, &JsValue::from_str("nostr"))
            .map_err(|_| Error::NamespaceNotFound(String::from("nostr")))?;
        let nostr_obj: Object = namespace
            .dyn_into()
            .map_err(|_| Error::NamespaceNotFound(String::from("nostr")))?;
        Ok(Self { nostr_obj })
    }

    /// Check if `window.nostr` object is available
    #[inline]
    pub fn is_available() -> bool {
        Self::new().is_ok()
    }

    fn get_func<S>(&self, obj: &Object, name: S) -> Result<Function, Error>
    where
        S: AsRef<str>,
    {
        let name: &str = name.as_ref();
        let val: JsValue = Reflect::get(obj, &JsValue::from_str(name))
            .map_err(|_| Error::NamespaceNotFound(name.to_string()))?;
        val.dyn_into()
            .map_err(|_| Error::NamespaceNotFound(name.to_string()))
    }

    /// Get value from object key
    #[inline]
    fn get_value_by_key(&self, obj: &Object, key: &str) -> Result<JsValue, Error> {
        Reflect::get(obj, &JsValue::from_str(key))
            .map_err(|_| Error::ObjectKeyNotFound(key.to_string()))
    }

    /// Get Public Key
    async fn _get_public_key(&self) -> Result<PublicKey, Error> {
        let func: Function = self.get_func(&self.nostr_obj, "getPublicKey")?;
        let promise: Promise = Promise::resolve(&func.call0(&self.nostr_obj)?);
        let result: JsValue = JsFuture::from(promise).await?;
        let public_key: String = result
            .as_string()
            .ok_or_else(|| Error::TypeMismatch(String::from("expected a hex string")))?;
        Ok(PublicKey::from_hex(public_key)?)
    }

    async fn _sign_event(&self, unsigned: UnsignedEvent) -> Result<Event, Error> {
        let func: Function = self.get_func(&self.nostr_obj, "signEvent")?;

        let tags: Array = unsigned
            .tags
            .iter()
            .map(|t| {
                t.as_slice()
                    .iter()
                    .map(|v| JsValue::from_str(v))
                    .collect::<Array>()
            })
            .collect();

        let unsigned_obj = Object::new();

        if let Some(id) = unsigned.id {
            Reflect::set(&unsigned_obj, &JsValue::from_str("id"), &id.to_hex().into())?;
        }

        Reflect::set(
            &unsigned_obj,
            &JsValue::from_str("pubkey"),
            &unsigned.pubkey.to_string().into(),
        )?;

        Reflect::set(
            &unsigned_obj,
            &JsValue::from_str("created_at"),
            &(unsigned.created_at.as_u64() as f64).into(),
        )?;

        Reflect::set(
            &unsigned_obj,
            &JsValue::from_str("kind"),
            &(unsigned.kind.as_u16() as f64).into(),
        )?;

        Reflect::set(&unsigned_obj, &JsValue::from_str("tags"), &tags.into())?;

        Reflect::set(
            &unsigned_obj,
            &JsValue::from_str("content"),
            &unsigned.content.as_str().into(),
        )?;

        let promise: Promise = Promise::resolve(&func.call1(&self.nostr_obj, &unsigned_obj)?);
        let result: JsValue = JsFuture::from(promise).await?;
        let event_obj: Object = result.dyn_into()?;

        // Extract signature from event object
        let sig: String = self
            .get_value_by_key(&event_obj, "sig")?
            .as_string()
            .ok_or_else(|| Error::TypeMismatch(String::from("expected a hex string")))?;
        let sig: Signature = Signature::from_str(&sig)?;

        // Add signature
        Ok(unsigned.add_signature(sig)?)
    }

    // TODO: add `getRelays`

    fn nip04_obj(&self) -> Result<Object, Error> {
        let namespace: JsValue = Reflect::get(&self.nostr_obj, &JsValue::from_str("nip04"))
            .map_err(|_| Error::NamespaceNotFound(String::from("nip04")))?;
        namespace
            .dyn_into()
            .map_err(|_| Error::NamespaceNotFound(String::from("nip04")))
    }

    async fn _nip04_encrypt<T>(&self, public_key: &PublicKey, content: T) -> Result<String, Error>
    where
        T: AsRef<[u8]>,
    {
        let nip04_obj: Object = self.nip04_obj()?;
        let func: Function = self.get_func(&nip04_obj, "encrypt")?;
        let content: &[u8] = content.as_ref();
        let content: String = String::from_utf8_lossy(content).to_string();
        let promise: Promise = Promise::resolve(&func.call2(
            &nip04_obj,
            &JsValue::from_str(&public_key.to_hex()),
            &JsValue::from_str(&content),
        )?);
        let result: JsValue = JsFuture::from(promise).await?;
        result
            .as_string()
            .ok_or_else(|| Error::TypeMismatch(String::from("expected a string")))
    }

    async fn _nip04_decrypt<S>(
        &self,
        public_key: &PublicKey,
        ciphertext: S,
    ) -> Result<String, Error>
    where
        S: AsRef<str>,
    {
        let nip04_obj: Object = self.nip04_obj()?;
        let func: Function = self.get_func(&nip04_obj, "decrypt")?;
        let promise: Promise = Promise::resolve(&func.call2(
            &nip04_obj,
            &JsValue::from_str(&public_key.to_hex()),
            &JsValue::from_str(ciphertext.as_ref()),
        )?);
        let result: JsValue = JsFuture::from(promise).await?;
        result
            .as_string()
            .ok_or_else(|| Error::TypeMismatch(String::from("expected a string")))
    }

    fn nip44_obj(&self) -> Result<Object, Error> {
        let namespace: JsValue = Reflect::get(&self.nostr_obj, &JsValue::from_str("nip44"))
            .map_err(|_| Error::NamespaceNotFound(String::from("nip44")))?;
        namespace
            .dyn_into()
            .map_err(|_| Error::NamespaceNotFound(String::from("nip44")))
    }

    async fn _nip44_encrypt<T>(&self, public_key: &PublicKey, content: T) -> Result<String, Error>
    where
        T: AsRef<[u8]>,
    {
        let nip44_obj: Object = self.nip44_obj()?;
        let func: Function = self.get_func(&nip44_obj, "encrypt")?;
        let content: &[u8] = content.as_ref();
        let content: String = String::from_utf8_lossy(content).to_string();
        let promise: Promise = Promise::resolve(&func.call2(
            &nip44_obj,
            &JsValue::from_str(&public_key.to_hex()),
            &JsValue::from_str(&content),
        )?);
        let result: JsValue = JsFuture::from(promise).await?;
        result
            .as_string()
            .ok_or_else(|| Error::TypeMismatch(String::from("expected a string")))
    }

    async fn _nip44_decrypt<T>(
        &self,
        public_key: &PublicKey,
        ciphertext: T,
    ) -> Result<String, Error>
    where
        T: AsRef<[u8]>,
    {
        let nip44_obj: Object = self.nip44_obj()?;
        let func: Function = self.get_func(&nip44_obj, "decrypt")?;
        let ciphertext: &[u8] = ciphertext.as_ref();
        let ciphertext: String = String::from_utf8_lossy(ciphertext).to_string();
        let promise: Promise = Promise::resolve(&func.call2(
            &nip44_obj,
            &JsValue::from_str(&public_key.to_hex()),
            &JsValue::from_str(&ciphertext),
        )?);
        let result: JsValue = JsFuture::from(promise).await?;
        result
            .as_string()
            .ok_or_else(|| Error::TypeMismatch(String::from("expected a string")))
    }
}

#[async_trait(?Send)]
impl NostrSigner for Nip07Signer {
    fn backend(&self) -> SignerBackend {
        SignerBackend::BrowserExtension
    }

    async fn get_public_key(&self) -> Result<PublicKey, SignerError> {
        self._get_public_key().await.map_err(SignerError::backend)
    }

    async fn sign_event(&self, unsigned: UnsignedEvent) -> Result<Event, SignerError> {
        self._sign_event(unsigned)
            .await
            .map_err(SignerError::backend)
    }

    async fn nip04_encrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError> {
        self._nip04_encrypt(public_key, content)
            .await
            .map_err(SignerError::backend)
    }

    async fn nip04_decrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError> {
        self._nip04_decrypt(public_key, content)
            .await
            .map_err(SignerError::backend)
    }

    async fn nip44_encrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError> {
        self._nip44_encrypt(public_key, content)
            .await
            .map_err(SignerError::backend)
    }

    async fn nip44_decrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError> {
        self._nip44_decrypt(public_key, content)
            .await
            .map_err(SignerError::backend)
    }
}

================
File: src/nips/nip10.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP10: Conventions for clients' use of `e` and `p` tags in text events
//!
//! <https://github.com/nostr-protocol/nips/blob/master/10.md>

use core::fmt;
use core::str::FromStr;

/// NIP10 error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Invalid marker
    InvalidMarker,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidMarker => write!(f, "invalid marker"),
        }
    }
}

/// Marker
///
/// <https://github.com/nostr-protocol/nips/blob/master/10.md>
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Marker {
    /// Root
    Root,
    /// Reply
    Reply,
    /// Mention
    Mention,
}

impl fmt::Display for Marker {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Root => write!(f, "root"),
            Self::Reply => write!(f, "reply"),
            Self::Mention => write!(f, "mention"),
        }
    }
}

impl FromStr for Marker {
    type Err = Error;

    fn from_str(marker: &str) -> Result<Self, Self::Err> {
        match marker {
            "root" => Ok(Self::Root),
            "reply" => Ok(Self::Reply),
            "mention" => Ok(Self::Mention),
            _ => Err(Error::InvalidMarker),
        }
    }
}

================
File: src/nips/nip11.rs
================
// Copyright (c) 2022 Thomas (0xtlt)
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP11: Relay Information Document
//!
//! <https://github.com/nostr-protocol/nips/blob/master/11.md>

use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;
use std::net::SocketAddr;

use reqwest::Client;
#[cfg(not(target_arch = "wasm32"))]
use reqwest::Proxy;

use crate::{Timestamp, Url};

/// `NIP11` error
#[derive(Debug)]
pub enum Error {
    /// The relay information document is invalid
    InvalidInformationDocument,
    /// The relay information document is not accessible
    InaccessibleInformationDocument,
    /// Provided URL scheme is not valid
    InvalidScheme,
    /// Reqwest error
    Reqwest(reqwest::Error),
}

impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidInformationDocument => {
                write!(f, "The relay information document is invalid")
            }
            Self::InaccessibleInformationDocument => {
                write!(f, "The relay information document is not accessible")
            }
            Self::InvalidScheme => write!(f, "Provided URL scheme is not valid"),
            Self::Reqwest(e) => write!(f, "{e}"),
        }
    }
}

impl From<reqwest::Error> for Error {
    fn from(e: reqwest::Error) -> Self {
        Self::Reqwest(e)
    }
}

/// Relay information document
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct RelayInformationDocument {
    /// Name
    pub name: Option<String>,
    /// Description
    pub description: Option<String>,
    /// Owner public key
    pub pubkey: Option<String>,
    /// Owner contact
    pub contact: Option<String>,
    /// Supported NIPs
    pub supported_nips: Option<Vec<u16>>,
    /// Software
    pub software: Option<String>,
    /// Software version
    pub version: Option<String>,
    /// Limitations imposed by the relay on clients
    pub limitation: Option<Limitation>,
    /// The relay's retention policies
    #[serde(skip_serializing_if = "Vec::is_empty")]
    #[serde(default)]
    pub retention: Vec<Retention>,
    /// Country codes whose laws and policies may affect this relay
    #[serde(skip_serializing_if = "Vec::is_empty")]
    #[serde(default)]
    pub relay_countries: Vec<String>,
    /// Ordered list of IETF language tags indicating the major languages spoken on the relay
    #[serde(skip_serializing_if = "Vec::is_empty")]
    #[serde(default)]
    pub language_tags: Vec<String>,
    /// List of limitations on the topics to be discussed
    #[serde(skip_serializing_if = "Vec::is_empty")]
    #[serde(default)]
    pub tags: Vec<String>,
    /// Link to a human-readable page which specifies the community policies
    pub posting_policy: Option<String>,
    /// Link to relay's fee schedules
    pub payments_url: Option<String>,
    /// Relay fee schedules
    pub fees: Option<FeeSchedules>,
    /// URL pointing to an image to be used as an icon for the relay
    pub icon: Option<String>,
}

/// These are limitations imposed by the relay on clients. Your client should
/// expect that requests which exceed these practical limitations are rejected or fail immediately.
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Limitation {
    /// Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
    pub max_message_length: Option<i32>,
    /// Total number of subscriptions that may be active on a single websocket connection
    pub max_subscriptions: Option<i32>,
    /// Maximum number of filter values in each subscription
    pub max_filters: Option<i32>,
    /// Relay will clamp each filter's limit value to this number
    pub max_limit: Option<i32>,
    /// Maximum length of subscription id as a string
    pub max_subid_length: Option<i32>,
    /// Maximum number of elements in the tags list
    pub max_event_tags: Option<i32>,
    /// Maximum number of characters in the content field of any event
    pub max_content_length: Option<i32>,
    /// New events will require at least this difficulty of PoW,
    pub min_pow_difficulty: Option<i32>,
    /// Relay requires NIP42 authentication to happen before a new connection may perform any other action
    pub auth_required: Option<bool>,
    /// Relay requires payment before a new connection may perform any action
    pub payment_required: Option<bool>,
    /// 'created_at' lower limit
    pub created_at_lower_limit: Option<Timestamp>,
    /// 'created_at' upper limit
    pub created_at_upper_limit: Option<Timestamp>,
}

/// A retention schedule for the relay
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Retention {
    /// The event kinds this retention pertains to
    pub kinds: Option<Vec<RetentionKind>>,
    /// The amount of time these events are kept
    pub time: Option<u64>,
    /// The max number of events kept before removing older events
    pub count: Option<u64>,
}

/// A single kind or range of kinds the retention pertains to
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetentionKind {
    /// A single kind
    Single(u64),
    /// A kind range
    Range(u64, u64),
}

/// Available fee schedules
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct FeeSchedules {
    /// Fees for admission to use the relay
    #[serde(skip_serializing_if = "Vec::is_empty")]
    #[serde(default)]
    pub admission: Vec<FeeSchedule>,
    /// Fees for subscription to use the relay
    #[serde(skip_serializing_if = "Vec::is_empty")]
    #[serde(default)]
    pub subscription: Vec<FeeSchedule>,
    /// Fees to publish to the relay
    #[serde(skip_serializing_if = "Vec::is_empty")]
    #[serde(default)]
    pub publication: Vec<FeeSchedule>,
}

/// The specific information about a fee schedule
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct FeeSchedule {
    /// The fee amount
    pub amount: i32,
    /// The denomination of the feed
    pub unit: String,
    /// The duration for which the fee is valid
    pub period: Option<i32>,
    /// The event kinds the fee allows the client to publish to the relay
    pub kinds: Option<Vec<String>>,
}

impl RelayInformationDocument {
    /// Create new empty [`RelayInformationDocument`]
    pub fn new() -> Self {
        Self::default()
    }

    /// Get Relay Information Document
    ///
    /// **Proxy is ignored for WASM targets!**
    pub async fn get(mut url: Url, _proxy: Option<SocketAddr>) -> Result<Self, Error> {
        #[cfg(not(target_arch = "wasm32"))]
        let client: Client = {
            let mut builder = Client::builder();
            if let Some(proxy) = _proxy {
                let proxy = format!("socks5h://{proxy}");
                builder = builder.proxy(Proxy::all(proxy)?);
            }
            builder.build()?
        };

        #[cfg(target_arch = "wasm32")]
        let client: Client = Client::new();

        let url: &str = Self::with_http_scheme(&mut url)?;
        let req = client.get(url).header("Accept", "application/nostr+json");
        match req.send().await {
            Ok(response) => {
                let json: String = response.text().await?;
                match serde_json::from_slice(json.as_bytes()) {
                    Ok(json) => Ok(json),
                    Err(_) => Err(Error::InvalidInformationDocument),
                }
            }
            Err(_) => Err(Error::InaccessibleInformationDocument),
        }
    }

    /// Returns new URL with scheme substituted to HTTP(S) if WS(S) was provided,
    /// other schemes leaves untouched.
    fn with_http_scheme(url: &mut Url) -> Result<&str, Error> {
        match url.scheme() {
            "wss" => url.set_scheme("https").map_err(|_| Error::InvalidScheme)?,
            "ws" => url.set_scheme("http").map_err(|_| Error::InvalidScheme)?,
            _ => {}
        }
        Ok(url.as_str())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn correctly_serializes_retention_kind() {
        let kinds = vec![
            RetentionKind::Single(0),
            RetentionKind::Single(1),
            RetentionKind::Range(5, 7),
            RetentionKind::Range(40, 49),
        ];
        let got = serde_json::to_string(&kinds).unwrap();
        let expected = "[0,1,[5,7],[40,49]]".to_string();

        assert_eq!(got, expected, "got: {}, expected: {}", got, expected);
    }

    #[test]
    fn correctly_deserializes_retention_kind() {
        let kinds = "[0, 1, [5, 7], [40, 49]]";
        let got = serde_json::from_str::<Vec<RetentionKind>>(kinds).unwrap();
        let expected = vec![
            RetentionKind::Single(0),
            RetentionKind::Single(1),
            RetentionKind::Range(5, 7),
            RetentionKind::Range(40, 49),
        ];

        assert_eq!(got, expected, "got: {:?}, expected: {:?}", got, expected);
    }
}

================
File: src/nips/nip13.rs
================
// Copyright (c) 2021 Paul Miller
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP13: Proof of Work
//!
//! <https://github.com/nostr-protocol/nips/blob/master/13.md>

use alloc::string::String;
use alloc::vec::Vec;

/// Gets the number of leading zero bits. Result is between 0 and 255.
#[inline]
pub fn get_leading_zero_bits<T>(h: T) -> u8
where
    T: AsRef<[u8]>,
{
    let mut res: u8 = 0u8;
    for b in h.as_ref().iter() {
        if *b == 0 {
            res += 8;
        } else {
            res += b.leading_zeros() as u8;
            return res;
        }
    }
    res
}

/// Returns all possible ID prefixes (hex) that have the specified number of leading zero bits.
///
/// Possible values: 0-255
pub fn get_prefixes_for_difficulty(leading_zero_bits: u8) -> Vec<String> {
    let mut r = Vec::new();

    if leading_zero_bits == 0 {
        return r;
    }

    // Up to 64
    let prefix_hex_len = if leading_zero_bits % 4 == 0 {
        leading_zero_bits / 4
    } else {
        leading_zero_bits / 4 + 1
    };

    // Bitlength of relevant prefixes, from 4 (prefix has at least 1 hex char) to 256 (all 64 chars)
    let prefix_bits: u16 = prefix_hex_len as u16 * 4;

    // pow expects u32
    for i in 0..2_u8.pow((prefix_bits - leading_zero_bits as u16) as u32) {
        let p = format!("{:01$x}", i, prefix_hex_len as usize); // https://stackoverflow.com/a/26286238
        r.push(p);
    }

    r
}

#[cfg(test)]
pub mod tests {
    use core::str::FromStr;

    use bitcoin::hashes::sha256::Hash as Sha256Hash;

    use super::*;

    #[test]
    fn check_get_leading_zeroes() {
        assert_eq!(
            4,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            3,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "2fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            1,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "4fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            1,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "5fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            1,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "6fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            1,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );

        assert_eq!(
            0,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "8fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            0,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "9fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            0,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "afffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            0,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "bfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            0,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "cfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            0,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "dfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            0,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "efffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            0,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );

        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "20ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "21ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "22ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "23ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "24ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "25ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "26ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "27ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "28ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "29ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "2affffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "2bffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "2cffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "2dffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "2effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            2,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "2fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
                )
                .unwrap()
            )
        );

        assert_eq!(
            248,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "00000000000000000000000000000000000000000000000000000000000000ff"
                )
                .unwrap()
            )
        );
        assert_eq!(
            252,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "000000000000000000000000000000000000000000000000000000000000000f"
                )
                .unwrap()
            )
        );
        assert_eq!(
            255,
            get_leading_zero_bits(
                Sha256Hash::from_str(
                    "0000000000000000000000000000000000000000000000000000000000000001"
                )
                .unwrap()
            )
        );
    }

    #[test]
    fn check_find_prefixes_for_pow() {
        assert!(get_prefixes_for_difficulty(0).is_empty());

        assert_eq!(
            get_prefixes_for_difficulty(1),
            vec!["0", "1", "2", "3", "4", "5", "6", "7"]
        );
        assert_eq!(get_prefixes_for_difficulty(2), vec!["0", "1", "2", "3"]);
        assert_eq!(get_prefixes_for_difficulty(3), vec!["0", "1"]);
        assert_eq!(get_prefixes_for_difficulty(4), vec!["0"]);

        assert_eq!(
            get_prefixes_for_difficulty(5),
            vec!["00", "01", "02", "03", "04", "05", "06", "07"]
        );
        assert_eq!(get_prefixes_for_difficulty(6), vec!["00", "01", "02", "03"]);
        assert_eq!(get_prefixes_for_difficulty(7), vec!["00", "01"]);
        assert_eq!(get_prefixes_for_difficulty(8), vec!["00"]);

        assert_eq!(
            get_prefixes_for_difficulty(9),
            vec!["000", "001", "002", "003", "004", "005", "006", "007"]
        );
        assert_eq!(
            get_prefixes_for_difficulty(10),
            vec!["000", "001", "002", "003"]
        );
        assert_eq!(get_prefixes_for_difficulty(11), vec!["000", "001"]);
        assert_eq!(get_prefixes_for_difficulty(12), vec!["000"]);

        assert_eq!(
            get_prefixes_for_difficulty(254),
            vec![
                "0000000000000000000000000000000000000000000000000000000000000000",
                "0000000000000000000000000000000000000000000000000000000000000001",
                "0000000000000000000000000000000000000000000000000000000000000002",
                "0000000000000000000000000000000000000000000000000000000000000003"
            ]
        );
        assert_eq!(
            get_prefixes_for_difficulty(255),
            vec![
                "0000000000000000000000000000000000000000000000000000000000000000",
                "0000000000000000000000000000000000000000000000000000000000000001"
            ]
        );
    }
}

================
File: src/nips/nip15.rs
================
// Copyright (c) 2023 ProTom
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP15: Nostr Marketplace (for resilient marketplaces)
//!
//! <https:///github.com/nostr-protocol/nips/blob/master/15.md>

use alloc::string::String;
use alloc::vec::Vec;

use crate::{JsonUtil, PublicKey, Tag};

/// Payload for creating or updating stall
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StallData {
    /// UUID of the stall generated by merchant
    pub id: String,
    /// Stall name
    pub name: String,
    /// Stall description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Currency used
    pub currency: String,
    /// Available shipping methods
    pub shipping: Vec<ShippingMethod>,
}

impl StallData {
    /// Create a new stall
    pub fn new(id: &str, name: &str, currency: &str) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            description: None,
            currency: currency.into(),
            shipping: Vec::new(),
        }
    }

    /// Set the description of the stall
    pub fn description(self, description: &str) -> Self {
        Self {
            description: Some(description.into()),
            ..self
        }
    }

    /// Add a shipping method to the stall
    pub fn shipping(self, shipping: Vec<ShippingMethod>) -> Self {
        Self { shipping, ..self }
    }
}

impl From<StallData> for Vec<Tag> {
    fn from(value: StallData) -> Self {
        vec![Tag::identifier(value.id)]
    }
}

impl JsonUtil for StallData {
    type Err = serde_json::Error;
}

/// Payload for creating or updating product
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProductData {
    /// UUID of the product generated by merchant
    pub id: String,
    /// Id of the stall that this product belongs to
    pub stall_id: String,
    /// Product name
    pub name: String,
    /// Description of the product
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Image urls of the product
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<String>>,
    /// Currency used
    pub currency: String,
    /// Price of the product
    pub price: f64,
    /// Available items
    pub quantity: u64,
    /// Specifications of the product
    #[serde(skip_serializing_if = "Option::is_none")]
    pub specs: Option<Vec<Vec<String>>>,
    /// Shipping method costs
    pub shipping: Vec<ShippingCost>,
    /// Categories of the product (will be added to tags)
    #[serde(skip_serializing)]
    pub categories: Option<Vec<String>>,
}

impl ProductData {
    /// Create a new product
    pub fn new(id: &str, stall_id: &str, name: &str, currency: &str) -> Self {
        Self {
            id: id.into(),
            stall_id: stall_id.into(),
            name: name.into(),
            description: None,
            images: None,
            currency: currency.into(),
            price: 0.0,
            quantity: 1,
            specs: None,
            shipping: Vec::new(),
            categories: None,
        }
    }

    /// Set the description of the product
    pub fn description(self, description: &str) -> Self {
        Self {
            description: Some(description.into()),
            ..self
        }
    }

    /// Add images to the product
    pub fn images(self, images: Vec<String>) -> Self {
        Self {
            images: Some(images),
            ..self
        }
    }

    /// Set the price of the product
    pub fn price(self, price: f64) -> Self {
        Self { price, ..self }
    }

    /// Set the available quantity of the product
    pub fn quantity(self, quantity: u64) -> Self {
        Self { quantity, ..self }
    }

    /// Set the specifications of the product (e.g. size, color, etc.). Each inner vector should
    /// only contain 2 elements, the first being the name of the spec and the second being the value
    /// of the spec.
    pub fn specs(self, specs: Vec<Vec<String>>) -> Self {
        let valid = specs.into_iter().filter(|spec| spec.len() == 2).collect();
        Self {
            specs: Some(valid),
            ..self
        }
    }

    /// Add a shipping method to the product
    pub fn shipping(self, shipping: Vec<ShippingCost>) -> Self {
        Self { shipping, ..self }
    }

    /// Add categories to the product
    pub fn categories(self, categories: Vec<String>) -> Self {
        Self {
            categories: Some(categories),
            ..self
        }
    }
}

impl From<ProductData> for Vec<Tag> {
    fn from(value: ProductData) -> Self {
        let categories: Vec<String> = value.categories.unwrap_or_default();
        let mut tags: Vec<Tag> = Vec::with_capacity(1 + categories.len());
        tags.push(Tag::identifier(value.stall_id));
        categories.iter().for_each(|cat| {
            tags.push(Tag::hashtag(cat));
        });
        tags
    }
}

impl JsonUtil for ProductData {
    type Err = serde_json::Error;
}

/// A shipping method as defined by the merchant
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShippingMethod {
    /// Shipping method unique id by merchant
    pub id: String,
    /// Shipping method name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Shipping method cost (currency is the same as the stall)
    pub cost: f64,
    /// Covered regions
    pub regions: Vec<String>,
}

impl ShippingMethod {
    /// Create a new shipping method
    pub fn new<S>(id: S, cost: f64) -> Self
    where
        S: Into<String>,
    {
        Self {
            id: id.into(),
            name: None,
            cost,
            regions: Vec::new(),
        }
    }

    /// Set the name of the shipping method
    pub fn name<S>(self, name: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            name: Some(name.into()),
            ..self
        }
    }

    /// Add a region to the shipping method
    pub fn regions(self, regions: Vec<String>) -> Self {
        Self { regions, ..self }
    }

    /// Get the product shipping cost of the shipping method
    pub fn get_shipping_cost(&self) -> ShippingCost {
        ShippingCost {
            id: self.id.clone(),
            cost: self.cost,
        }
    }
}

impl JsonUtil for ShippingMethod {
    type Err = serde_json::Error;
}

/// Delivery cost for shipping method as defined by the merchant in the product
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShippingCost {
    /// Id of the shipping method
    pub id: String,
    /// Cost to use this shipping method
    pub cost: f64,
}

impl JsonUtil for ShippingCost {
    type Err = serde_json::Error;
}

/// Payload for customer creating an order
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomerOrder {
    /// Unique id of the order generated by customer
    pub id: String,
    /// Message type (0 in case of customer order)
    #[serde(rename = "type")]
    pub r#type: usize,
    /// Name of the customer
    pub name: Option<String>,
    /// Address of the customer if product is physical
    pub address: Option<String>,
    /// Message to the merchant
    pub message: Option<String>,
    /// Contact details of the customer
    pub contact: CustomerContact,
    /// Items ordered
    pub items: Vec<CustomerOrderItem>,
    /// Shipping method id
    pub shipping_id: String,
}

impl JsonUtil for CustomerOrder {
    type Err = serde_json::Error;
}

/// Payload for a merchant to create a payment request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MerchantPaymentRequest {
    /// Unique id of the order generated by customer
    pub id: String,
    /// Message type (1 in case of merchant payment request)
    #[serde(rename = "type")]
    pub r#type: usize,
    /// Available payment options
    pub payment_options: Vec<PaymentOption>,
}

impl JsonUtil for MerchantPaymentRequest {
    type Err = serde_json::Error;
}

/// Payload to notify a customer about the received payment and or shipping
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MerchantVerifyPayment {
    /// Unique id of the order generated by customer
    pub id: String,
    /// Type of the message (2 in case of merchant verify payment)
    #[serde(rename = "type")]
    pub r#type: usize,
    /// Payment successful
    pub paid: bool,
    /// Item shipped
    pub shipped: bool,
}

impl JsonUtil for MerchantVerifyPayment {
    type Err = serde_json::Error;
}

/// A customers contact options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomerContact {
    /// Nostr pub key of the customer (optional, as not decided yet if required)
    pub nostr: Option<PublicKey>,
    /// Phone number of the customer
    pub phone: Option<String>,
    /// Email of the customer
    pub email: Option<String>,
}

impl JsonUtil for CustomerContact {
    type Err = serde_json::Error;
}

/// An item in the order
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomerOrderItem {
    /// Id of the product
    pub id: String,
    /// Quantity of the product
    pub quantity: u64,
}

impl JsonUtil for CustomerOrderItem {
    type Err = serde_json::Error;
}

/// A payment option of an invoice
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentOption {
    /// Name of the payment option
    #[serde(rename = "type")]
    pub r#type: String,
    /// Payment link (url, ln invoice, etc.)
    pub link: String,
}

impl JsonUtil for PaymentOption {
    type Err = serde_json::Error;
}

#[cfg(test)]
mod tests {
    use alloc::string::String;
    use alloc::vec::Vec;

    use super::*;
    #[test]
    fn test_stall_data() {
        let stall = StallData::new("123", "Test Stall", "USD")
            .description("Test Description")
            .shipping(vec![ShippingMethod::new("123", 5.0).name("default")]);
        let tags: Vec<Tag> = stall.clone().into();
        assert_eq!(tags.len(), 1);
        assert_eq!(tags[0], Tag::identifier("123"), "tags contains stall id");

        let string: String = stall.as_json();
        assert_eq!(
            string,
            r#"{"id":"123","name":"Test Stall","description":"Test Description","currency":"USD","shipping":[{"id":"123","name":"default","cost":5.0,"regions":[]}]}"#
        );
    }

    #[test]
    fn test_product_data() {
        let product = ProductData::new("123", "456", "Test Product", "USD")
            .images(vec!["https://example.com/image.png".into()])
            .price(10.0)
            .quantity(10)
            .specs(vec![vec!["Size".into(), "M".into()]])
            .shipping(vec![ShippingCost {
                id: "123".into(),
                cost: 5.0,
            }])
            .categories(vec!["Test".into(), "Product".into()]);

        let tags: Vec<Tag> = product.clone().into();
        assert_eq!(tags.len(), 3);
        assert_eq!(tags[0], Tag::identifier("456"), "tags contains stall id");
        assert_eq!(tags[1], Tag::hashtag("Test"), "tags contains category");
        assert_eq!(tags[2], Tag::hashtag("Product"), "tags contains category");

        let string: String = product.as_json();
        assert_eq!(
            string,
            r#"{"id":"123","stall_id":"456","name":"Test Product","images":["https://example.com/image.png"],"currency":"USD","price":10.0,"quantity":10,"specs":[["Size","M"]],"shipping":[{"id":"123","cost":5.0}]}"#
        );
    }
}

================
File: src/nips/nip17.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP17: Private Direct Message
//!
//! <https://github.com/nostr-protocol/nips/blob/master/17.md>

use alloc::boxed::Box;
use core::iter;

use crate::{Event, Kind, RelayUrl, TagStandard};

/// Extracts the relay list
pub fn extract_relay_list<'a>(event: &'a Event) -> Box<dyn Iterator<Item = &'a RelayUrl> + 'a> {
    if event.kind != Kind::InboxRelays {
        return Box::new(iter::empty());
    }

    Box::new(event.tags.iter().filter_map(|tag| {
        if let Some(TagStandard::Relay(url)) = tag.as_standardized() {
            Some(url)
        } else {
            None
        }
    }))
}

/// Extracts the relay list
pub fn extract_owned_relay_list(event: Event) -> Box<dyn Iterator<Item = RelayUrl>> {
    if event.kind != Kind::InboxRelays {
        return Box::new(iter::empty());
    }

    Box::new(event.tags.into_iter().filter_map(|tag| {
        if let Some(TagStandard::Relay(url)) = tag.to_standardized() {
            Some(url)
        } else {
            None
        }
    }))
}

================
File: src/nips/nip19.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP19: bech32-encoded entities
//!
//! <https://github.com/nostr-protocol/nips/blob/master/19.md>

#![allow(missing_docs)]

use alloc::string::{FromUtf8Error, String, ToString};
use alloc::vec::Vec;
use core::fmt;
use core::str::{self, FromStr, Utf8Error};

use bech32::{self, Bech32, Hrp};

use super::nip01::Coordinate;
#[cfg(all(feature = "std", feature = "nip05"))]
use super::nip05::Nip05Profile;
#[cfg(feature = "nip49")]
use super::nip49::{self, EncryptedSecretKey};
use crate::event::id::{self, EventId};
use crate::types::url::{self, RelayUrl, TryIntoUrl};
use crate::{key, Kind, PublicKey, SecretKey};

pub const PREFIX_BECH32_SECRET_KEY: &str = "nsec";
pub const PREFIX_BECH32_SECRET_KEY_ENCRYPTED: &str = "ncryptsec";
pub const PREFIX_BECH32_PUBLIC_KEY: &str = "npub";
pub const PREFIX_BECH32_NOTE_ID: &str = "note";
pub const PREFIX_BECH32_PROFILE: &str = "nprofile";
pub const PREFIX_BECH32_EVENT: &str = "nevent";
pub const PREFIX_BECH32_COORDINATE: &str = "naddr";

const HRP_SECRET_KEY: Hrp = Hrp::parse_unchecked(PREFIX_BECH32_SECRET_KEY);
#[cfg(feature = "nip49")]
const HRP_SECRET_KEY_ENCRYPTED: Hrp = Hrp::parse_unchecked(PREFIX_BECH32_SECRET_KEY_ENCRYPTED);
const HRP_PUBLIC_KEY: Hrp = Hrp::parse_unchecked(PREFIX_BECH32_PUBLIC_KEY);
const HRP_NOTE_ID: Hrp = Hrp::parse_unchecked(PREFIX_BECH32_NOTE_ID);
const HRP_PROFILE: Hrp = Hrp::parse_unchecked(PREFIX_BECH32_PROFILE);
const HRP_EVENT: Hrp = Hrp::parse_unchecked(PREFIX_BECH32_EVENT);
const HRP_COORDINATE: Hrp = Hrp::parse_unchecked(PREFIX_BECH32_COORDINATE);

pub const SPECIAL: u8 = 0;
pub const RELAY: u8 = 1;
pub const AUTHOR: u8 = 2;
pub const KIND: u8 = 3;

/// 1 (type) + 1 (len) + 32 (value)
const FIXED_1_1_32_BYTES_TVL: usize = 1 + 1 + 32;

/// 1 (type) + 1 (len) + 4 (value - 32-bit unsigned number)
const FIXED_KIND_BYTES_TVL: usize = 1 + 1 + 4;

/// `NIP19` error
#[derive(Debug, Eq, PartialEq)]
pub enum Error {
    /// Fmt error.
    Fmt(fmt::Error),
    /// Relay Url parse error
    RelayUrl(url::Error),
    /// Bech32 decode error.
    Bech32Decode(bech32::DecodeError),
    /// Bech32 encode error
    Bech32Encode(bech32::EncodeError),
    /// UFT-8 error
    FromUTF8(FromUtf8Error),
    /// UFT-8 error
    UTF8(Utf8Error),
    /// Hash error
    Hash(bitcoin::hashes::FromSliceError),
    /// Keys error
    Keys(key::Error),
    /// EventId error
    EventId(id::Error),
    /// NIP49 error
    #[cfg(feature = "nip49")]
    NIP49(nip49::Error),
    /// Wrong prefix or variant
    WrongPrefixOrVariant,
    /// Field missing
    FieldMissing(String),
    /// TLV error
    TLV,
    /// From slice error
    TryFromSlice,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Fmt(e) => write!(f, "{e}"),
            Self::RelayUrl(e) => write!(f, "{e}"),
            Self::Bech32Decode(e) => write!(f, "{e}"),
            Self::Bech32Encode(e) => write!(f, "{e}"),
            Self::FromUTF8(e) => write!(f, "UTF8: {e}"),
            Self::UTF8(e) => write!(f, "UTF8: {e}"),
            Self::Hash(e) => write!(f, "Hash: {e}"),
            Self::Keys(e) => write!(f, "Keys: {e}"),
            Self::EventId(e) => write!(f, "Event ID: {e}"),
            #[cfg(feature = "nip49")]
            Self::NIP49(e) => write!(f, "{e}"),
            Self::WrongPrefixOrVariant => write!(f, "Wrong prefix or variant"),
            Self::FieldMissing(name) => write!(f, "Field missing: {name}"),
            Self::TLV => write!(f, "TLV (type-length-value) error"),
            Self::TryFromSlice => write!(f, "Impossible to perform conversion from slice"),
        }
    }
}

impl From<fmt::Error> for Error {
    fn from(e: fmt::Error) -> Self {
        Self::Fmt(e)
    }
}

impl From<url::Error> for Error {
    fn from(e: url::Error) -> Self {
        Self::RelayUrl(e)
    }
}

impl From<bech32::DecodeError> for Error {
    fn from(e: bech32::DecodeError) -> Self {
        Self::Bech32Decode(e)
    }
}

impl From<bech32::EncodeError> for Error {
    fn from(e: bech32::EncodeError) -> Self {
        Self::Bech32Encode(e)
    }
}

impl From<FromUtf8Error> for Error {
    fn from(e: FromUtf8Error) -> Self {
        Self::FromUTF8(e)
    }
}

impl From<Utf8Error> for Error {
    fn from(e: Utf8Error) -> Self {
        Self::UTF8(e)
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Keys(e)
    }
}

impl From<id::Error> for Error {
    fn from(e: id::Error) -> Self {
        Self::EventId(e)
    }
}

#[cfg(feature = "nip49")]
impl From<nip49::Error> for Error {
    fn from(e: nip49::Error) -> Self {
        Self::NIP49(e)
    }
}

/// To ensure total matching on prefixes when decoding a [`Nip19`] object
enum Nip19Prefix {
    /// Secret Key
    NSec,
    /// Encrypted Secret Key
    #[cfg(feature = "nip49")]
    NCryptSec,
    /// Public key
    NPub,
    /// note
    Note,
    /// nprofile
    NProfile,
    /// nevent
    NEvent,
    /// naddr
    NAddr,
}

impl FromStr for Nip19Prefix {
    type Err = Error;

    fn from_str(value: &str) -> Result<Self, Self::Err> {
        match value {
            PREFIX_BECH32_SECRET_KEY => Ok(Nip19Prefix::NSec),
            #[cfg(feature = "nip49")]
            PREFIX_BECH32_SECRET_KEY_ENCRYPTED => Ok(Nip19Prefix::NCryptSec),
            PREFIX_BECH32_PUBLIC_KEY => Ok(Nip19Prefix::NPub),
            PREFIX_BECH32_NOTE_ID => Ok(Nip19Prefix::Note),
            PREFIX_BECH32_PROFILE => Ok(Nip19Prefix::NProfile),
            PREFIX_BECH32_EVENT => Ok(Nip19Prefix::NEvent),
            PREFIX_BECH32_COORDINATE => Ok(Nip19Prefix::NAddr),
            _ => Err(Error::WrongPrefixOrVariant),
        }
    }
}

/// A representation any `NIP19` bech32 nostr object. Useful for decoding
/// `NIP19` bech32 strings without necessarily knowing what you're decoding
/// ahead of time.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Nip19 {
    /// nsec
    Secret(SecretKey),
    /// Encrypted Secret Key (ncryptsec)
    #[cfg(feature = "nip49")]
    EncryptedSecret(EncryptedSecretKey),
    /// npub
    Pubkey(PublicKey),
    /// nprofile
    Profile(Nip19Profile),
    /// note
    EventId(EventId),
    /// nevent
    Event(Nip19Event),
    /// naddr
    Coordinate(Coordinate),
}

pub trait FromBech32: Sized {
    type Err;
    fn from_bech32<S>(bech32: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>;
}

pub trait ToBech32 {
    type Err;
    fn to_bech32(&self) -> Result<String, Self::Err>;
}

impl FromBech32 for Nip19 {
    type Err = Error;

    fn from_bech32<S>(hash: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        let (hrp, data) = bech32::decode(hash.as_ref())?;
        let prefix: Nip19Prefix = Nip19Prefix::from_str(&hrp.to_string())?;

        match prefix {
            Nip19Prefix::NSec => Ok(Self::Secret(SecretKey::from_slice(data.as_slice())?)),
            #[cfg(feature = "nip49")]
            Nip19Prefix::NCryptSec => Ok(Self::EncryptedSecret(EncryptedSecretKey::from_slice(
                data.as_slice(),
            )?)),
            Nip19Prefix::NPub => Ok(Self::Pubkey(PublicKey::from_slice(data.as_slice())?)),
            Nip19Prefix::NProfile => Ok(Self::Profile(Nip19Profile::from_bech32_data(data)?)),
            Nip19Prefix::NEvent => Ok(Self::Event(Nip19Event::from_bech32_data(data)?)),
            Nip19Prefix::Note => Ok(Self::EventId(EventId::from_slice(data.as_slice())?)),
            Nip19Prefix::NAddr => Ok(Self::Coordinate(Coordinate::from_bech32_data(data)?)),
        }
    }
}

impl ToBech32 for Nip19 {
    type Err = Error;

    fn to_bech32(&self) -> Result<String, Self::Err> {
        match self {
            Nip19::Secret(sec) => sec.to_bech32(),
            #[cfg(feature = "nip49")]
            Nip19::EncryptedSecret(cryptsec) => cryptsec.to_bech32(),
            Nip19::Pubkey(pubkey) => pubkey.to_bech32(),
            Nip19::Event(event) => event.to_bech32(),
            Nip19::Profile(profile) => profile.to_bech32(),
            Nip19::EventId(event_id) => event_id.to_bech32(),
            Nip19::Coordinate(coordinate) => coordinate.to_bech32(),
        }
    }
}

impl FromBech32 for SecretKey {
    type Err = Error;

    fn from_bech32<S>(secret_key: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        let (hrp, data) = bech32::decode(secret_key.as_ref())?;

        if hrp != HRP_SECRET_KEY {
            return Err(Error::WrongPrefixOrVariant);
        }

        Ok(Self::from_slice(data.as_slice())?)
    }
}

impl ToBech32 for SecretKey {
    type Err = Error;

    #[inline]
    fn to_bech32(&self) -> Result<String, Self::Err> {
        Ok(bech32::encode::<Bech32>(
            HRP_SECRET_KEY,
            self.as_secret_bytes(),
        )?)
    }
}

#[cfg(feature = "nip49")]
impl FromBech32 for EncryptedSecretKey {
    type Err = Error;

    fn from_bech32<S>(secret_key: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        let (hrp, data) = bech32::decode(secret_key.as_ref())?;

        if hrp != HRP_SECRET_KEY_ENCRYPTED {
            return Err(Error::WrongPrefixOrVariant);
        }

        Ok(Self::from_slice(data.as_slice())?)
    }
}

#[cfg(feature = "nip49")]
impl ToBech32 for EncryptedSecretKey {
    type Err = Error;

    #[inline]
    fn to_bech32(&self) -> Result<String, Self::Err> {
        Ok(bech32::encode::<Bech32>(
            HRP_SECRET_KEY_ENCRYPTED,
            &self.as_vec(),
        )?)
    }
}

impl FromBech32 for PublicKey {
    type Err = Error;

    fn from_bech32<S>(public_key: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        let (hrp, data) = bech32::decode(public_key.as_ref())?;

        if hrp != HRP_PUBLIC_KEY {
            return Err(Error::WrongPrefixOrVariant);
        }

        Ok(Self::from_slice(data.as_slice())?)
    }
}

impl ToBech32 for PublicKey {
    type Err = Error;

    #[inline]
    fn to_bech32(&self) -> Result<String, Self::Err> {
        Ok(bech32::encode::<Bech32>(HRP_PUBLIC_KEY, &self.serialize())?)
    }
}

impl FromBech32 for EventId {
    type Err = Error;

    fn from_bech32<S>(hash: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        let (hrp, data) = bech32::decode(hash.as_ref())?;

        if hrp != HRP_NOTE_ID {
            return Err(Error::WrongPrefixOrVariant);
        }

        Ok(Self::from_slice(data.as_slice())?)
    }
}

impl ToBech32 for EventId {
    type Err = Error;

    #[inline]
    fn to_bech32(&self) -> Result<String, Self::Err> {
        Ok(bech32::encode::<Bech32>(HRP_NOTE_ID, self.as_bytes())?)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Nip19Event {
    pub event_id: EventId,
    pub author: Option<PublicKey>,
    pub kind: Option<Kind>,
    pub relays: Vec<String>,
}

impl Nip19Event {
    #[inline]
    pub fn new<I, S>(event_id: EventId, relays: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        Self {
            event_id,
            author: None,
            kind: None,
            relays: relays.into_iter().map(|u| u.into()).collect(),
        }
    }

    /// Add author
    #[inline]
    pub fn author(mut self, author: PublicKey) -> Self {
        self.author = Some(author);
        self
    }

    /// Add kind
    #[inline]
    pub fn kind(mut self, kind: Kind) -> Self {
        self.kind = Some(kind);
        self
    }

    fn from_bech32_data(mut data: Vec<u8>) -> Result<Self, Error> {
        let mut event_id: Option<EventId> = None;
        let mut author: Option<PublicKey> = None;
        let mut kind: Option<Kind> = None;
        let mut relays: Vec<String> = Vec::new();

        while !data.is_empty() {
            let t = data.first().ok_or(Error::TLV)?;
            let l = data.get(1).ok_or(Error::TLV)?;
            let l = *l as usize;

            let bytes = data.get(2..l + 2).ok_or(Error::TLV)?;

            match *t {
                SPECIAL => {
                    if event_id.is_none() {
                        event_id = Some(EventId::from_slice(bytes)?);
                    }
                }
                // from nip19: "for nevent, *optionally*, the 32 bytes of
                // the pubkey of the event"
                AUTHOR => {
                    if author.is_none() {
                        author = PublicKey::from_slice(bytes).ok(); // NOT propagate error if public key is invalid
                    }
                }
                RELAY => {
                    relays.push(String::from_utf8(bytes.to_vec())?);
                }
                KIND => {
                    if kind.is_none() {
                        // The kind value must be a 32-bit unsigned number according to
                        // https://github.com/nostr-protocol/nips/blob/37f6cbb775126b386414220f783ca0f5f85e7614/19.md#shareable-identifiers-with-extra-metadata
                        let k: u16 =
                            u32::from_be_bytes(bytes.try_into().map_err(|_| Error::TryFromSlice)?)
                                as u16;
                        kind = Some(Kind::from(k));
                    }
                }
                _ => (),
            };

            data.drain(..l + 2);
        }

        Ok(Self {
            event_id: event_id.ok_or_else(|| Error::FieldMissing("event id".to_string()))?,
            author,
            kind,
            relays,
        })
    }
}

impl FromBech32 for Nip19Event {
    type Err = Error;

    fn from_bech32<S>(s: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        let (hrp, data) = bech32::decode(s.as_ref())?;

        if hrp != HRP_EVENT {
            return Err(Error::WrongPrefixOrVariant);
        }

        Self::from_bech32_data(data)
    }
}

impl ToBech32 for Nip19Event {
    type Err = Error;

    fn to_bech32(&self) -> Result<String, Self::Err> {
        // Allocate capacity
        let relays_len: usize = self.relays.iter().map(|u| 2 + u.len()).sum();
        let author_len: usize = if self.author.is_some() {
            FIXED_1_1_32_BYTES_TVL
        } else {
            0
        };
        let mut bytes: Vec<u8> =
            Vec::with_capacity(FIXED_1_1_32_BYTES_TVL + author_len + relays_len);

        bytes.push(SPECIAL); // Type
        bytes.push(32); // Len
        bytes.extend(self.event_id.as_bytes()); // Value

        if let Some(author) = &self.author {
            bytes.push(AUTHOR); // Type
            bytes.push(32); // Len
            bytes.extend(author.to_bytes()); // Value
        }

        if let Some(kind) = &self.kind {
            bytes.push(KIND); // Type
            bytes.push(4); // Len
            bytes.extend((kind.as_u16() as u32).to_be_bytes()); // Value
        }

        for relay in self.relays.iter() {
            bytes.push(RELAY); // Type
            bytes.push(relay.len() as u8); // Len
            bytes.extend(relay.as_bytes()); // Value
        }

        Ok(bech32::encode::<Bech32>(HRP_EVENT, &bytes)?)
    }
}

#[cfg(all(feature = "std", feature = "nip05"))]
impl ToBech32 for Nip05Profile {
    type Err = Error;

    fn to_bech32(&self) -> Result<String, Self::Err> {
        // Convert to NIP19 profile
        let profile: Nip19Profile = Nip19Profile {
            public_key: self.public_key,
            relays: self.relays.clone(),
        };
        // Encode
        profile.to_bech32()
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Nip19Profile {
    pub public_key: PublicKey,
    pub relays: Vec<RelayUrl>,
}

impl Nip19Profile {
    #[inline]
    pub fn new<I, U>(public_key: PublicKey, relays: I) -> Result<Self, Error>
    where
        I: IntoIterator<Item = U>,
        U: TryIntoUrl,
        Error: From<<U as TryIntoUrl>::Err>,
    {
        Ok(Self {
            public_key,
            relays: relays
                .into_iter()
                .map(|u| u.try_into_url())
                .collect::<Result<_, _>>()?,
        })
    }

    fn from_bech32_data(mut data: Vec<u8>) -> Result<Self, Error> {
        let mut public_key: Option<PublicKey> = None;
        let mut relays: Vec<RelayUrl> = Vec::new();

        while !data.is_empty() {
            let t = data.first().ok_or(Error::TLV)?;
            let l = data.get(1).ok_or(Error::TLV)?;
            let l = *l as usize;

            let bytes = data.get(2..l + 2).ok_or(Error::TLV)?;

            match *t {
                SPECIAL => {
                    if public_key.is_none() {
                        public_key = Some(PublicKey::from_slice(bytes)?);
                    }
                }
                RELAY => {
                    let url: &str = str::from_utf8(bytes)?;
                    if let Ok(url) = RelayUrl::parse(url) {
                        relays.push(url);
                    }
                }
                _ => (),
            };

            data.drain(..l + 2);
        }

        Ok(Self {
            public_key: public_key.ok_or_else(|| Error::FieldMissing("pubkey".to_string()))?,
            relays,
        })
    }
}

impl ToBech32 for Nip19Profile {
    type Err = Error;

    fn to_bech32(&self) -> Result<String, Self::Err> {
        // Allocate capacity
        let relays_len: usize = self.relays.iter().map(|u| 2 + u.as_str().len()).sum();
        let mut bytes: Vec<u8> = Vec::with_capacity(FIXED_1_1_32_BYTES_TVL + relays_len);

        bytes.push(SPECIAL); // Type
        bytes.push(32); // Len
        bytes.extend(self.public_key.to_bytes()); // Value

        for relay in self.relays.iter() {
            let url: &[u8] = relay.as_str().as_bytes();
            bytes.push(RELAY); // Type
            bytes.push(url.len() as u8); // Len
            bytes.extend(url); // Value
        }

        Ok(bech32::encode::<Bech32>(HRP_PROFILE, &bytes)?)
    }
}

impl FromBech32 for Nip19Profile {
    type Err = Error;

    fn from_bech32<S>(s: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        let (hrp, data) = bech32::decode(s.as_ref())?;

        if hrp != HRP_PROFILE {
            return Err(Error::WrongPrefixOrVariant);
        }

        Self::from_bech32_data(data)
    }
}

impl Coordinate {
    fn from_bech32_data(mut data: Vec<u8>) -> Result<Self, Error> {
        let mut identifier: Option<String> = None;
        let mut pubkey: Option<PublicKey> = None;
        let mut kind: Option<Kind> = None;
        let mut relays: Vec<RelayUrl> = Vec::new();

        while !data.is_empty() {
            let t = data.first().ok_or(Error::TLV)?;
            let l = data.get(1).ok_or(Error::TLV)?;
            let l = *l as usize;

            let bytes: &[u8] = data.get(2..l + 2).ok_or(Error::TLV)?;

            match *t {
                SPECIAL => {
                    if identifier.is_none() {
                        identifier = Some(String::from_utf8(bytes.to_vec())?);
                    }
                }
                RELAY => {
                    let url: &str = str::from_utf8(bytes)?;
                    if let Ok(url) = RelayUrl::parse(url) {
                        relays.push(url);
                    }
                }
                AUTHOR => {
                    if pubkey.is_none() {
                        pubkey = Some(PublicKey::from_slice(bytes)?);
                    }
                }
                KIND => {
                    if kind.is_none() {
                        // The kind value must be a 32-bit unsigned number according to
                        // https://github.com/nostr-protocol/nips/blob/37f6cbb775126b386414220f783ca0f5f85e7614/19.md#shareable-identifiers-with-extra-metadata
                        let k: u16 =
                            u32::from_be_bytes(bytes.try_into().map_err(|_| Error::TryFromSlice)?)
                                as u16;
                        kind = Some(Kind::from(k));
                    }
                }
                _ => (),
            };

            data.drain(..l + 2);
        }

        Ok(Self {
            kind: kind.ok_or_else(|| Error::FieldMissing("kind".to_string()))?,
            public_key: pubkey.ok_or_else(|| Error::FieldMissing("pubkey".to_string()))?,
            identifier: identifier.ok_or_else(|| Error::FieldMissing("identifier".to_string()))?,
            relays,
        })
    }
}

impl FromBech32 for Coordinate {
    type Err = Error;

    fn from_bech32<S>(s: S) -> Result<Self, Self::Err>
    where
        S: AsRef<str>,
    {
        let (hrp, data) = bech32::decode(s.as_ref())?;

        if hrp != HRP_COORDINATE {
            return Err(Error::WrongPrefixOrVariant);
        }

        Self::from_bech32_data(data)
    }
}

impl ToBech32 for Coordinate {
    type Err = Error;

    fn to_bech32(&self) -> Result<String, Self::Err> {
        // Allocate capacity
        let identifier_len: usize = 2 + self.identifier.len();
        let relays_len: usize = self.relays.iter().map(|u| 2 + u.as_str().len()).sum();
        let mut bytes: Vec<u8> = Vec::with_capacity(
            identifier_len + FIXED_1_1_32_BYTES_TVL + FIXED_KIND_BYTES_TVL + relays_len,
        );

        // Identifier
        bytes.push(SPECIAL); // Type
        bytes.push(self.identifier.len() as u8); // Len
        bytes.extend(self.identifier.as_bytes()); // Value

        // Author
        bytes.push(AUTHOR); // Type
        bytes.push(32); // Len
        bytes.extend(self.public_key.to_bytes()); // Value

        // Kind
        bytes.push(KIND); // Type
        bytes.push(4); // Len
        bytes.extend((self.kind.as_u16() as u32).to_be_bytes()); // Value

        for relay in self.relays.iter() {
            bytes.push(RELAY); // Type
            bytes.push(relay.as_str().len() as u8); // Len
            bytes.extend(relay.as_str().as_bytes()); // Value
        }

        Ok(bech32::encode::<Bech32>(HRP_COORDINATE, &bytes)?)
    }
}

#[cfg(test)]
mod tests {
    use core::str::FromStr;

    use super::*;

    #[test]
    fn to_bech32_public_key() {
        let public_key =
            PublicKey::from_str("aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4")
                .unwrap();
        assert_eq!(
            "npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy".to_string(),
            public_key.to_bech32().unwrap()
        );
    }

    #[test]
    fn to_bech32_secret_key() {
        let secret_key =
            SecretKey::from_str("9571a568a42b9e05646a349c783159b906b498119390df9a5a02667155128028")
                .unwrap();
        assert_eq!(
            "nsec1j4c6269y9w0q2er2xjw8sv2ehyrtfxq3jwgdlxj6qfn8z4gjsq5qfvfk99".to_string(),
            secret_key.to_bech32().unwrap()
        );
    }

    #[test]
    fn to_bech32_note() {
        let event_id =
            EventId::from_hex("d94a3f4dd87b9a3b0bed183b32e916fa29c8020107845d1752d72697fe5309a5")
                .unwrap();
        assert_eq!(
            "note1m99r7nwc0wdrkzldrqan96gklg5usqspq7z9696j6unf0ljnpxjspqfw99".to_string(),
            event_id.to_bech32().unwrap()
        );
    }

    #[test]
    fn from_bech32_nip19_event() {
        let expected_event_id =
            EventId::from_hex("d94a3f4dd87b9a3b0bed183b32e916fa29c8020107845d1752d72697fe5309a5")
                .unwrap();

        let nip19 =
            Nip19::from_bech32("note1m99r7nwc0wdrkzldrqan96gklg5usqspq7z9696j6unf0ljnpxjspqfw99")
                .unwrap();

        assert_eq!(Nip19::EventId(expected_event_id), nip19);
    }

    #[test]
    fn from_bech32_nip19_profile() {
        let nprofile = "nprofile1qqsrhuxx8l9ex335q7he0f09aej04zpazpl0ne2cgukyawd24mayt8gppemhxue69uhhytnc9e3k7mf0qyt8wumn8ghj7er2vfshxtnnv9jxkc3wvdhk6tclr7lsh";
        let nip19 = Nip19::from_bech32(nprofile).unwrap();

        let expected_pubkey =
            PublicKey::from_str("3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d")
                .unwrap();

        assert_eq!(
            Nip19::Profile(
                Nip19Profile::new(
                    expected_pubkey,
                    ["wss://r.x.com/", "wss://djbas.sadkb.com/"]
                )
                .unwrap()
            ),
            nip19
        );

        assert_eq!(nip19.to_bech32().unwrap(), nprofile);
    }

    #[test]
    fn test_bech32_nevent() {
        let nevent = "nevent1qqsdhet4232flykq3048jzc9msmaa3hnxuesxy3lnc33vd0wt9xwk6szyqewrqnkx4zsaweutf739s0cu7et29zrntqs5elw70vlm8zudr3y24sqsgy";
        let nip19_event = Nip19Event::from_bech32(nevent).unwrap();

        let expected_pubkey =
            PublicKey::from_str("32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245")
                .unwrap();

        assert_eq!(nip19_event.author, Some(expected_pubkey));
        assert_eq!(nip19_event.kind, None);
        assert_eq!(nip19_event.to_bech32().unwrap(), nevent);

        // Test serialization and deserialization
        let event = Nip19Event {
            event_id: EventId::from_hex(
                "d94a3f4dd87b9a3b0bed183b32e916fa29c8020107845d1752d72697fe5309a5",
            )
            .unwrap(),
            author: None,
            kind: Some(Kind::TextNote),
            relays: Vec::new(),
        };
        let serialized = event.to_bech32().unwrap();
        assert_eq!(event, Nip19Event::from_bech32(serialized).unwrap());
    }

    #[test]
    fn from_bech32_naddr() {
        let coordinate: &str = "naddr1qqxnzd3exgersv33xymnsve3qgs8suecw4luyht9ekff89x4uacneapk8r5dyk0gmn6uwwurf6u9rusrqsqqqa282m3gxt";
        let coordinate: Coordinate = Coordinate::from_bech32(coordinate).unwrap();

        let expected_pubkey: PublicKey =
            PublicKey::from_hex("787338757fc25d65cd929394d5e7713cf43638e8d259e8dcf5c73b834eb851f2")
                .unwrap();
        let expected_kind: Kind = Kind::LongFormTextNote;
        let exected_identifier: &str = "1692282117831";

        assert_eq!(coordinate.public_key, expected_pubkey);
        assert_eq!(coordinate.kind, expected_kind);
        assert_eq!(coordinate.identifier, exected_identifier);
    }

    #[test]
    fn test_parse_nevent_with_malformed_public_key() {
        let event = Nip19Event::from_bech32("nevent1qqsqye53g5jg5pzw87q6a3nstkf2wu7jph87nala2nvfyw5u3ewlhfspr9mhxue69uhkymmnw3ezumr9vd682unfveujumn9wspyqve5xasnyvehxqunqvryxyukydr9xsmn2d3jxgcn2wf5v5uxyerpxucrvct9x43nwwp4v3jnqwt9x5uk2dpkxq6kvwf3vycrxe35893ska2ytu").unwrap();
        assert!(event.author.is_none());
    }
}

#[cfg(bench)]
mod benches {
    use super::*;
    use crate::test::{black_box, Bencher};

    #[bench]
    pub fn to_bech32_nevent(bh: &mut Bencher) {
        let event_id =
            EventId::from_hex("d94a3f4dd87b9a3b0bed183b32e916fa29c8020107845d1752d72697fe5309a5")
                .unwrap();
        let public_key =
            PublicKey::from_str("32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245")
                .unwrap();
        let nip19_event = Nip19Event::new(event_id, ["wss://r.x.com", "wss://djbas.sadkb.com"])
            .author(public_key);

        bh.iter(|| {
            black_box(nip19_event.to_bech32()).unwrap();
        });
    }
}

================
File: src/nips/nip21.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP21: `nostr:` URI scheme
//!
//! <https://github.com/nostr-protocol/nips/blob/master/21.md>

use alloc::string::String;
use core::fmt;

use super::nip01::Coordinate;
use super::nip19::{self, FromBech32, Nip19, Nip19Event, Nip19Profile, ToBech32};
use crate::{EventId, PublicKey};

/// URI scheme
pub const SCHEME: &str = "nostr";

/// Unsupported Bech32 Type
#[derive(Debug, PartialEq, Eq)]
pub enum UnsupportedBech32Type {
    /// Secret Key
    SecretKey,
}

impl fmt::Display for UnsupportedBech32Type {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::SecretKey => write!(f, "secret key"),
        }
    }
}

/// NIP21 error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// NIP19 error
    NIP19(nip19::Error),
    /// Invalid nostr URI
    InvalidURI,
    /// Unsupported bech32 type
    UnsupportedBech32Type(UnsupportedBech32Type),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::NIP19(e) => write!(f, "NIP19: {e}"),
            Self::InvalidURI => write!(f, "Invalid nostr URI"),
            Self::UnsupportedBech32Type(t) => write!(f, "Unsupported bech32 type: {t}"),
        }
    }
}

impl From<nip19::Error> for Error {
    fn from(e: nip19::Error) -> Self {
        Self::NIP19(e)
    }
}

fn split_uri(uri: &str) -> Result<&str, Error> {
    let mut splitted = uri.split(':');
    let prefix: &str = splitted.next().ok_or(Error::InvalidURI)?;

    if prefix != SCHEME {
        return Err(Error::InvalidURI);
    }

    splitted.next().ok_or(Error::InvalidURI)
}

/// Nostr URI trait
pub trait NostrURI: Sized + ToBech32 + FromBech32
where
    Error: From<<Self as ToBech32>::Err>,
    Error: From<<Self as FromBech32>::Err>,
{
    /// Get nostr URI
    #[inline]
    fn to_nostr_uri(&self) -> Result<String, Error> {
        Ok(format!("{SCHEME}:{}", self.to_bech32()?))
    }

    /// From `nostr` URI
    #[inline]
    fn from_nostr_uri<S>(uri: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let data: &str = split_uri(uri.as_ref())?;
        Ok(Self::from_bech32(data)?)
    }
}

impl NostrURI for PublicKey {}
impl NostrURI for EventId {}
impl NostrURI for Nip19Profile {}
impl NostrURI for Nip19Event {}
impl NostrURI for Coordinate {}

/// A representation any `NIP21` object. Useful for decoding
/// `NIP21` strings without necessarily knowing what you're decoding
/// ahead of time.
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Nip21 {
    /// nostr::npub
    Pubkey(PublicKey),
    /// nostr::nprofile
    Profile(Nip19Profile),
    /// nostr::note
    EventId(EventId),
    /// nostr::nevent
    Event(Nip19Event),
    /// nostr::naddr
    Coordinate(Coordinate),
}

impl From<Nip21> for Nip19 {
    fn from(value: Nip21) -> Self {
        match value {
            Nip21::Pubkey(val) => Self::Pubkey(val),
            Nip21::Profile(val) => Self::Profile(val),
            Nip21::EventId(val) => Self::EventId(val),
            Nip21::Event(val) => Self::Event(val),
            Nip21::Coordinate(val) => Self::Coordinate(val),
        }
    }
}

impl TryFrom<Nip19> for Nip21 {
    type Error = Error;

    fn try_from(value: Nip19) -> Result<Self, Self::Error> {
        match value {
            Nip19::Secret(..) => Err(Error::UnsupportedBech32Type(
                UnsupportedBech32Type::SecretKey,
            )),
            #[cfg(feature = "nip49")]
            Nip19::EncryptedSecret(..) => Err(Error::UnsupportedBech32Type(
                UnsupportedBech32Type::SecretKey,
            )),
            Nip19::Pubkey(val) => Ok(Self::Pubkey(val)),
            Nip19::Profile(val) => Ok(Self::Profile(val)),
            Nip19::EventId(val) => Ok(Self::EventId(val)),
            Nip19::Event(val) => Ok(Self::Event(val)),
            Nip19::Coordinate(val) => Ok(Self::Coordinate(val)),
        }
    }
}

impl Nip21 {
    /// Parse NIP21 string
    #[inline]
    pub fn parse<S>(uri: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let data: &str = split_uri(uri.as_ref())?;
        let nip19: Nip19 = Nip19::from_bech32(data)?;
        Self::try_from(nip19)
    }

    /// Serialize to NIP21 nostr URI
    pub fn to_nostr_uri(&self) -> Result<String, Error> {
        match self {
            Self::Pubkey(val) => Ok(val.to_nostr_uri()?),
            Self::Profile(val) => Ok(val.to_nostr_uri()?),
            Self::EventId(val) => Ok(val.to_nostr_uri()?),
            Self::Event(val) => Ok(val.to_nostr_uri()?),
            Self::Coordinate(val) => Ok(val.to_nostr_uri()?),
        }
    }

    /// Get [EventId] if exists
    pub fn event_id(&self) -> Option<EventId> {
        match self {
            Self::EventId(id) => Some(*id),
            Self::Event(e) => Some(e.event_id),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use core::str::FromStr;

    use super::*;

    #[test]
    fn test_to_nostr_uri() {
        let pubkey =
            PublicKey::from_str("aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4")
                .unwrap();
        assert_eq!(
            pubkey.to_nostr_uri().unwrap(),
            String::from("nostr:npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy")
        );

        let generic = Nip21::Pubkey(pubkey);
        assert_eq!(
            generic.to_nostr_uri().unwrap(),
            String::from("nostr:npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy")
        );
    }

    #[test]
    fn test_from_nostr_uri() {
        let pubkey =
            PublicKey::from_str("aa4fc8665f5696e33db7e1a572e3b0f5b3d615837b0f362dcb1c8068b098c7b4")
                .unwrap();
        assert_eq!(
            PublicKey::from_nostr_uri(
                "nostr:npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy"
            )
            .unwrap(),
            pubkey
        );

        assert_eq!(
            Nip21::parse("nostr:npub14f8usejl26twx0dhuxjh9cas7keav9vr0v8nvtwtrjqx3vycc76qqh9nsy")
                .unwrap(),
            Nip21::Pubkey(pubkey),
        );

        assert_eq!(
            Nip21::parse("nostr:nprofile1qqsr9cvzwc652r4m83d86ykplrnm9dg5gwdvzzn8ameanlvut35wy3gpz4mhxue69uhhyetvv9ujuerpd46hxtnfduhsz4nxck").unwrap(),
            Nip21::Profile(Nip19Profile::new(
                PublicKey::from_str(
                    "32e1827635450ebb3c5a7d12c1f8e7b2b514439ac10a67eef3d9fd9c5c68e245",
                )
                .unwrap(),
                ["wss://relay.damus.io/"]
            ).unwrap()),
        );
    }

    #[test]
    fn test_unsupported_from_nostr_uri() {
        assert_eq!(
            Nip21::parse("nostr:nsec1j4c6269y9w0q2er2xjw8sv2ehyrtfxq3jwgdlxj6qfn8z4gjsq5qfvfk99")
                .unwrap_err(),
            Error::UnsupportedBech32Type(UnsupportedBech32Type::SecretKey)
        );
    }
}

================
File: src/nips/nip26.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP26: Delegated Event Signing
//!
//! <https://github.com/nostr-protocol/nips/blob/master/26.md>

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;
use core::num::ParseIntError;
use core::str::FromStr;

use bitcoin::hashes::sha256::Hash as Sha256Hash;
use bitcoin::hashes::Hash;
#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::{CryptoRng, Rng};
use bitcoin::secp256k1::schnorr::Signature;
use bitcoin::secp256k1::{self, Message, Secp256k1, Signing, Verification};
use serde::de::Error as DeserializerError;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json::{json, Value};

use super::nip21;
use crate::event::Event;
use crate::key::{self, Keys};
use crate::PublicKey;
#[cfg(feature = "std")]
use crate::SECP256K1;

const DELEGATION_KEYWORD: &str = "delegation";

/// `NIP26` error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Key error
    Key(key::Error),
    /// Secp256k1 error
    Secp256k1(secp256k1::Error),
    /// Invalid condition, cannot parse expected number
    ConditionsParseNumeric(ParseIntError),
    /// Conditions not satisfied
    ConditionsValidation(ValidationError),
    /// Invalid condition in conditions string
    ConditionsParseInvalidCondition,
    /// Delegation tag parse error
    DelegationTagParse,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Key(e) => write!(f, "Key: {e}"),
            Self::Secp256k1(e) => write!(f, "Secp256k1: {e}"),
            Self::ConditionsParseNumeric(_) => {
                write!(f, "Invalid condition, cannot parse expected number")
            }
            Self::ConditionsValidation(_) => write!(f, "Conditions not satisfied"),
            Self::ConditionsParseInvalidCondition => {
                write!(f, "Invalid condition in conditions string")
            }
            Self::DelegationTagParse => write!(f, "Delegation tag parse error"),
        }
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Key(e)
    }
}

impl From<secp256k1::Error> for Error {
    fn from(e: secp256k1::Error) -> Self {
        Self::Secp256k1(e)
    }
}

impl From<ParseIntError> for Error {
    fn from(e: ParseIntError) -> Self {
        Self::ConditionsParseNumeric(e)
    }
}

impl From<ValidationError> for Error {
    fn from(e: ValidationError) -> Self {
        Self::ConditionsValidation(e)
    }
}

/// Tag validation errors
#[derive(Debug, PartialEq, Eq)]
pub enum ValidationError {
    /// Signature does not match
    InvalidSignature,
    /// Event kind does not match
    InvalidKind,
    /// Creation time is earlier than validity period
    CreatedTooEarly,
    /// Creation time is later than validity period
    CreatedTooLate,
}

#[cfg(feature = "std")]
impl std::error::Error for ValidationError {}

impl fmt::Display for ValidationError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidSignature => write!(f, "Signature does not match"),
            Self::InvalidKind => write!(f, "Event kind does not match"),
            Self::CreatedTooEarly => write!(f, "Creation time is earlier than validity period"),
            Self::CreatedTooLate => write!(f, "Creation time is later than validity period"),
        }
    }
}

/// Sign delegation.
/// See `create_delegation_tag` for more complete functionality.
#[inline]
#[cfg(feature = "std")]
pub fn sign_delegation(
    delegator_keys: &Keys,
    delegatee_pk: &PublicKey,
    conditions: &Conditions,
) -> Signature {
    sign_delegation_with_ctx(
        &SECP256K1,
        &mut OsRng,
        delegator_keys,
        delegatee_pk,
        conditions,
    )
}

/// Sign delegation.
/// See `create_delegation_tag` for more complete functionality.
pub fn sign_delegation_with_ctx<C, R>(
    secp: &Secp256k1<C>,
    rng: &mut R,
    delegator_keys: &Keys,
    delegatee_pk: &PublicKey,
    conditions: &Conditions,
) -> Signature
where
    C: Signing,
    R: Rng + CryptoRng,
{
    let unhashed_token = DelegationToken::new(delegatee_pk, conditions);
    let hashed_token = Sha256Hash::hash(unhashed_token.as_bytes());
    let message: Message = Message::from_digest(hashed_token.to_byte_array());
    delegator_keys.sign_schnorr_with_ctx(secp, &message, rng)
}

/// Verify delegation signature
#[inline]
#[cfg(feature = "std")]
pub fn verify_delegation_signature(
    delegator_public_key: &PublicKey,
    signature: Signature,
    delegatee_public_key: &PublicKey,
    conditions: &Conditions,
) -> Result<(), Error> {
    verify_delegation_signature_with_ctx(
        &SECP256K1,
        delegator_public_key,
        signature,
        delegatee_public_key,
        conditions,
    )
}

/// Verify delegation signature
pub fn verify_delegation_signature_with_ctx<C>(
    secp: &Secp256k1<C>,
    delegator_public_key: &PublicKey,
    signature: Signature,
    delegatee_public_key: &PublicKey,
    conditions: &Conditions,
) -> Result<(), Error>
where
    C: Verification,
{
    let unhashed_token = DelegationToken::new(delegatee_public_key, conditions);
    let hashed_token = Sha256Hash::hash(unhashed_token.as_bytes());
    let message = Message::from_digest(hashed_token.to_byte_array());
    secp.verify_schnorr(&signature, &message, delegator_public_key)?;
    Ok(())
}

/// Delegation token
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct DelegationToken(String);

impl DelegationToken {
    /// Generate [`DelegationToken`]
    #[inline]
    pub fn new(delegatee_pk: &PublicKey, conditions: &Conditions) -> Self {
        Self(format!(
            "{}:{DELEGATION_KEYWORD}:{delegatee_pk}:{conditions}",
            nip21::SCHEME
        ))
    }

    /// Get as bytes
    #[inline]
    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_bytes()
    }
}

impl fmt::Display for DelegationToken {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Delegation tag, as defined in NIP26
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct DelegationTag {
    delegator_pubkey: PublicKey,
    conditions: Conditions,
    signature: Signature,
}

impl DelegationTag {
    /// Create a delegation tag (including the signature).
    #[inline]
    #[cfg(feature = "std")]
    pub fn new(
        delegator_keys: &Keys,
        delegatee_pubkey: &PublicKey,
        conditions: Conditions,
    ) -> Self {
        Self::new_with_ctx(
            &SECP256K1,
            &mut OsRng,
            delegator_keys,
            delegatee_pubkey,
            conditions,
        )
    }

    /// Create a delegation tag (including the signature).
    pub fn new_with_ctx<C, R>(
        secp: &Secp256k1<C>,
        rng: &mut R,
        delegator_keys: &Keys,
        delegatee_pubkey: &PublicKey,
        conditions: Conditions,
    ) -> Self
    where
        C: Signing,
        R: Rng + CryptoRng,
    {
        let signature: Signature =
            sign_delegation_with_ctx(secp, rng, delegator_keys, delegatee_pubkey, &conditions);
        Self {
            delegator_pubkey: delegator_keys.public_key(),
            conditions,
            signature,
        }
    }

    /// Get delegator public key
    #[inline]
    pub fn delegator_pubkey(&self) -> PublicKey {
        self.delegator_pubkey
    }

    /// Get conditions
    #[inline]
    pub fn conditions(&self) -> Conditions {
        self.conditions.clone()
    }

    /// Get signature
    #[inline]
    pub fn signature(&self) -> Signature {
        self.signature
    }

    /// Validate a delegation tag, check signature and conditions.
    #[inline]
    #[cfg(feature = "std")]
    pub fn validate(
        &self,
        delegatee_pubkey: &PublicKey,
        event_properties: &EventProperties,
    ) -> Result<(), Error> {
        self.validate_with_ctx(&SECP256K1, delegatee_pubkey, event_properties)
    }

    /// Validate a delegation tag, check signature and conditions.
    pub fn validate_with_ctx<C>(
        &self,
        secp: &Secp256k1<C>,
        delegatee_pubkey: &PublicKey,
        event_properties: &EventProperties,
    ) -> Result<(), Error>
    where
        C: Verification,
    {
        // Verify signature
        verify_delegation_signature_with_ctx(
            secp,
            &self.delegator_pubkey,
            self.signature,
            delegatee_pubkey,
            &self.conditions,
        )
        .map_err(|_| Error::ConditionsValidation(ValidationError::InvalidSignature))?;

        // Validate conditions
        self.conditions.evaluate(event_properties)?;

        Ok(())
    }

    /// Convert to JSON string.
    pub fn as_json(&self) -> String {
        let tag = json!([
            DELEGATION_KEYWORD,
            self.delegator_pubkey.to_string(),
            self.conditions.to_string(),
            self.signature.to_string(),
        ]);
        tag.to_string()
    }

    /// Parse from a JSON string
    pub fn from_json(s: &str) -> Result<Self, Error> {
        let tag: Vec<String> = serde_json::from_str(s).map_err(|_| Error::DelegationTagParse)?;
        Self::try_from(tag)
    }
}

impl TryFrom<Vec<String>> for DelegationTag {
    type Error = Error;

    fn try_from(tag: Vec<String>) -> Result<Self, Self::Error> {
        if tag.len() != 4 {
            return Err(Error::DelegationTagParse);
        }
        if tag[0] != DELEGATION_KEYWORD {
            return Err(Error::DelegationTagParse);
        }
        Ok(Self {
            delegator_pubkey: PublicKey::from_str(&tag[1])?,
            conditions: Conditions::from_str(&tag[2])?,
            signature: Signature::from_str(&tag[3])?,
        })
    }
}

impl fmt::Display for DelegationTag {
    /// Return tag in JSON string format
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.as_json())
    }
}

impl FromStr for DelegationTag {
    type Err = Error;

    #[inline]
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::from_json(s)
    }
}

/// A condition from the delegation conditions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Condition {
    /// Event kind, e.g. kind=1
    Kind(u16),
    /// Creation time before, e.g. created_at<1679000000
    CreatedBefore(u64),
    /// Creation time after, e.g. created_at>1676000000
    CreatedAfter(u64),
}

/// Represents properties of an event, relevant for delegation
pub struct EventProperties {
    /// Event kind. For simplicity/flexibility, numeric type is used.
    kind: u16,
    /// Creation time, as unix timestamp
    created_time: u64,
}

impl Condition {
    /// Evaluate whether an event satisfies this condition
    pub(crate) fn evaluate(&self, ep: &EventProperties) -> Result<(), ValidationError> {
        match self {
            Self::Kind(k) => {
                if ep.kind != *k {
                    return Err(ValidationError::InvalidKind);
                }
            }
            Self::CreatedBefore(t) => {
                if ep.created_time >= *t {
                    return Err(ValidationError::CreatedTooLate);
                }
            }
            Self::CreatedAfter(t) => {
                if ep.created_time <= *t {
                    return Err(ValidationError::CreatedTooEarly);
                }
            }
        }
        Ok(())
    }
}

impl fmt::Display for Condition {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Kind(k) => write!(f, "kind={k}"),
            Self::CreatedBefore(t) => write!(f, "created_at<{t}"),
            Self::CreatedAfter(t) => write!(f, "created_at>{t}"),
        }
    }
}

impl FromStr for Condition {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some(kind) = s.strip_prefix("kind=") {
            let n = u16::from_str(kind)?;
            return Ok(Self::Kind(n));
        }
        if let Some(created_before) = s.strip_prefix("created_at<") {
            let n = u64::from_str(created_before)?;
            return Ok(Self::CreatedBefore(n));
        }
        if let Some(created_after) = s.strip_prefix("created_at>") {
            let n = u64::from_str(created_after)?;
            return Ok(Self::CreatedAfter(n));
        }
        Err(Error::ConditionsParseInvalidCondition)
    }
}

/// Set of conditions of a delegation.
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Conditions(Vec<Condition>);

impl Conditions {
    /// New empty [`Conditions`]
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Add [`Condition`]
    #[inline]
    pub fn add(&mut self, cond: Condition) {
        self.0.push(cond);
    }

    /// Evaluate whether an event satisfies all these conditions
    fn evaluate(&self, ep: &EventProperties) -> Result<(), ValidationError> {
        for c in &self.0 {
            c.evaluate(ep)?;
        }
        Ok(())
    }

    /// Get [`Vec<Condition>`]
    #[inline]
    pub fn inner(&self) -> Vec<Condition> {
        self.0.clone()
    }
}

impl fmt::Display for Conditions {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Convert parts, join
        let conditions: String = self
            .0
            .iter()
            .map(|c| c.to_string())
            .collect::<Vec<String>>()
            .join("&");
        write!(f, "{conditions}")
    }
}

impl FromStr for Conditions {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.is_empty() {
            return Ok(Self::new());
        }
        let cond = s
            .split('&')
            .map(Condition::from_str)
            .collect::<Result<Vec<Condition>, Self::Err>>()?;
        Ok(Self(cond))
    }
}

impl Serialize for Conditions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for Conditions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let json_value = Value::deserialize(deserializer)?;
        let conditions: String =
            serde_json::from_value(json_value).map_err(DeserializerError::custom)?;
        Self::from_str(&conditions).map_err(DeserializerError::custom)
    }
}

impl EventProperties {
    /// Create new with values
    #[inline]
    pub fn new(event_kind: u16, created_time: u64) -> Self {
        Self {
            kind: event_kind,
            created_time,
        }
    }

    /// Create from an Event
    pub fn from_event(event: &Event) -> Self {
        Self {
            kind: event.kind.as_u16(),
            created_time: event.created_at.as_u64(),
        }
    }
}

#[cfg(test)]
mod tests {
    use core::str::FromStr;

    use bitcoin::secp256k1::Secp256k1;

    use super::*;
    use crate::SecretKey;

    #[test]
    fn test_serialize_conditions() {
        let mut conditions = Conditions::new();
        conditions.add(Condition::Kind(1));
        conditions.add(Condition::CreatedAfter(1676067553));
        conditions.add(Condition::CreatedBefore(1678659553));

        assert_eq!(
            json!(conditions).as_str().unwrap(),
            "kind=1&created_at>1676067553&created_at<1678659553"
        );
    }

    #[test]
    fn test_deserialize_conditions() {
        let mut conditions = Conditions::new();
        conditions.add(Condition::Kind(1));
        conditions.add(Condition::CreatedAfter(1676067553));
        conditions.add(Condition::CreatedBefore(1678659553));

        let value = json!("kind=1&created_at>1676067553&created_at<1678659553");
        assert_eq!(
            serde_json::from_value::<Conditions>(value).unwrap(),
            conditions
        );

        let value = "\"kind=1&created_at>1676067553&created_at<1678659553\"";
        assert_eq!(
            serde_json::from_str::<Conditions>(value).unwrap(),
            conditions
        );
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_create_delegation_tag() {
        let delegator_secret_key =
            SecretKey::from_hex("b2f3673ee3a659283e6599080e0ab0e669a3c2640914375a9b0b357faae08b17")
                .unwrap();
        let delegator_keys = Keys::new(delegator_secret_key);
        let delegatee_pubkey =
            PublicKey::from_str("bea8aeb6c1657e33db5ac75a83910f77e8ec6145157e476b5b88c6e85b1fab34")
                .unwrap();
        let conditions =
            Conditions::from_str("kind=1&created_at>1676067553&created_at<1678659553").unwrap();

        let tag = DelegationTag::new(&delegator_keys, &delegatee_pubkey, conditions.clone());

        // Verify signature (it's variable)
        let verify_result = verify_delegation_signature(
            &delegator_keys.public_key(),
            tag.signature(),
            &delegatee_pubkey,
            &conditions,
        );
        assert!(verify_result.is_ok());

        // Signature changes, cannot compare to expected constant, use signature from result
        let expected = format!(
            "[\"delegation\",\"1a459a8a6aa6441d480ba665fb8fb21a4cfe8bcacb7d87300f8046a558a3fce4\",\"kind=1&created_at>1676067553&created_at<1678659553\",\"{}\"]",
            &tag.signature.to_string());
        assert_eq!(tag.to_string(), expected);
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_validate_delegation_tag() {
        let delegator_secret_key =
            SecretKey::from_hex("b2f3673ee3a659283e6599080e0ab0e669a3c2640914375a9b0b357faae08b17")
                .unwrap();
        let delegator_keys = Keys::new(delegator_secret_key);
        let delegatee_pubkey =
            PublicKey::from_str("bea8aeb6c1657e33db5ac75a83910f77e8ec6145157e476b5b88c6e85b1fab34")
                .unwrap();
        let conditions =
            Conditions::from_str("kind=1&created_at>1676067553&created_at<1678659553").unwrap();

        let tag = DelegationTag::new(&delegator_keys, &delegatee_pubkey, conditions);

        assert!(tag
            .validate(&delegatee_pubkey, &EventProperties::new(1, 1677000000))
            .is_ok());
    }

    #[test]
    fn test_delegation_tag_parse_and_validate() {
        let secp = Secp256k1::new();

        let tag_str = "[\"delegation\",\"1a459a8a6aa6441d480ba665fb8fb21a4cfe8bcacb7d87300f8046a558a3fce4\",\"kind=1&created_at>1676067553&created_at<1678659553\",\"369aed09c1ad52fceb77ecd6c16f2433eac4a3803fc41c58876a5b60f4f36b9493d5115e5ec5a0ce6c3668ffe5b58d47f2cbc97233833bb7e908f66dbbbd9d36\"]";
        let delegatee_pubkey =
            PublicKey::from_str("bea8aeb6c1657e33db5ac75a83910f77e8ec6145157e476b5b88c6e85b1fab34")
                .unwrap();

        let tag = DelegationTag::from_str(tag_str).unwrap();

        assert!(tag
            .validate_with_ctx(
                &secp,
                &delegatee_pubkey,
                &EventProperties::new(1, 1677000000)
            )
            .is_ok());

        // Additional test: verify a value from inside the tag
        assert_eq!(
            tag.conditions().to_string(),
            "kind=1&created_at>1676067553&created_at<1678659553"
        );

        // Additional test: try validation with invalid values, invalid event kind
        match tag
            .validate_with_ctx(
                &secp,
                &delegatee_pubkey,
                &EventProperties::new(5, 1677000000),
            )
            .err()
            .unwrap()
        {
            Error::ConditionsValidation(e) => assert_eq!(e, ValidationError::InvalidKind),
            _ => panic!("Expected ConditionsValidation"),
        };
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_sign_delegation_verify_delegation_signature() {
        let delegator_secret_key =
            SecretKey::from_hex("ee35e8bb71131c02c1d7e73231daa48e9953d329a4b701f7133c8f46dd21139c")
                .unwrap();
        let delegator_keys = Keys::new(delegator_secret_key);
        let delegatee_public_key =
            PublicKey::from_str("477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396")
                .unwrap();
        let conditions =
            Conditions::from_str("kind=1&created_at>1674834236&created_at<1677426236").unwrap();

        let signature = sign_delegation(&delegator_keys, &delegatee_public_key, &conditions);

        // Signature is changing, validate by verify method
        let verify_result = verify_delegation_signature(
            &delegator_keys.public_key(),
            signature,
            &delegatee_public_key,
            &conditions,
        );
        assert!(verify_result.is_ok());
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_sign_delegation_verify_lowlevel() {
        let delegator_secret_key =
            SecretKey::from_hex("ee35e8bb71131c02c1d7e73231daa48e9953d329a4b701f7133c8f46dd21139c")
                .unwrap();
        let delegator_keys = Keys::new(delegator_secret_key);
        let delegatee_public_key =
            PublicKey::from_hex("477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396")
                .unwrap();
        let conditions =
            Conditions::from_str("kind=1&created_at>1674834236&created_at<1677426236").unwrap();

        let signature = sign_delegation(&delegator_keys, &delegatee_public_key, &conditions);

        // Signature is changing, validate by lowlevel verify
        let unhashed_token: String =
            format!("nostr:delegation:{delegatee_public_key}:{conditions}");
        let hashed_token = Sha256Hash::hash(unhashed_token.as_bytes());
        let message = Message::from_digest_slice(hashed_token.as_byte_array()).unwrap();

        let verify_result =
            SECP256K1.verify_schnorr(&signature, &message, &delegator_keys.public_key());
        assert!(verify_result.is_ok());
    }

    #[test]
    fn test_verify_delegation_signature() {
        let secp = Secp256k1::new();

        let delegator_secret_key =
            SecretKey::from_hex("ee35e8bb71131c02c1d7e73231daa48e9953d329a4b701f7133c8f46dd21139c")
                .unwrap();
        let delegator_keys = Keys::new_with_ctx(&secp, delegator_secret_key);

        // Use one concrete signature
        let signature = Signature::from_str("f9f00fcf8480686d9da6dfde1187d4ba19c54f6ace4c73361a14db429c4b96eb30b29283d6ea1f06ba9e18e06e408244c689039ddadbacffc56060f3da5b04b8").unwrap();
        let delegatee_pk =
            PublicKey::from_str("477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396")
                .unwrap();
        let conditions =
            Conditions::from_str("kind=1&created_at>1674834236&created_at<1677426236").unwrap();

        let verify_result = verify_delegation_signature_with_ctx(
            &secp,
            &delegator_keys.public_key(),
            signature,
            &delegatee_pk,
            &conditions,
        );
        assert!(verify_result.is_ok());
    }

    #[test]
    fn test_delegation_token() {
        let delegatee_pk =
            PublicKey::from_str("477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396")
                .unwrap();
        let conditions =
            Conditions::from_str("kind=1&created_at>1674834236&created_at<1677426236").unwrap();
        let unhashed_token = DelegationToken::new(&delegatee_pk, &conditions);
        assert_eq!(
            unhashed_token.to_string().as_str(),
            "nostr:delegation:477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396:kind=1&created_at>1674834236&created_at<1677426236"
        );
    }

    #[test]
    fn test_delegation_tag_to_json() {
        let secp = Secp256k1::new();

        let delegator_sk =
            SecretKey::from_hex("b2f3673ee3a659283e6599080e0ab0e669a3c2640914375a9b0b357faae08b17")
                .unwrap();
        let delegator_pubkey = Keys::new_with_ctx(&secp, delegator_sk).public_key();
        let conditions = Conditions::from_str("kind=1&created_at<1678659553").unwrap();
        let signature = Signature::from_str("435091ab4c4a11e594b1a05e0fa6c2f6e3b6eaa87c53f2981a3d6980858c40fdcaffde9a4c461f352a109402a4278ff4dbf90f9ebd05f96dac5ae36a6364a976").unwrap();
        let d = DelegationTag {
            delegator_pubkey,
            conditions,
            signature,
        };
        let tag = d.as_json();
        assert_eq!(tag, "[\"delegation\",\"1a459a8a6aa6441d480ba665fb8fb21a4cfe8bcacb7d87300f8046a558a3fce4\",\"kind=1&created_at<1678659553\",\"435091ab4c4a11e594b1a05e0fa6c2f6e3b6eaa87c53f2981a3d6980858c40fdcaffde9a4c461f352a109402a4278ff4dbf90f9ebd05f96dac5ae36a6364a976\"]");
    }

    #[test]
    fn test_delegation_tag_from_str() {
        let tag_str = "[\"delegation\",\"1a459a8a6aa6441d480ba665fb8fb21a4cfe8bcacb7d87300f8046a558a3fce4\",\"kind=1&created_at>1676067553&created_at<1678659553\",\"369aed09c1ad52fceb77ecd6c16f2433eac4a3803fc41c58876a5b60f4f36b9493d5115e5ec5a0ce6c3668ffe5b58d47f2cbc97233833bb7e908f66dbbbd9d36\"]";

        let tag = DelegationTag::from_str(tag_str).unwrap();

        assert_eq!(tag.to_string(), tag_str);
        assert_eq!(
            tag.conditions().to_string(),
            "kind=1&created_at>1676067553&created_at<1678659553"
        );
        assert_eq!(
            tag.delegator_pubkey().to_string().as_str(),
            "1a459a8a6aa6441d480ba665fb8fb21a4cfe8bcacb7d87300f8046a558a3fce4"
        );
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_validate_delegation_tag_negative() {
        let delegator_secret_key =
            SecretKey::from_hex("b2f3673ee3a659283e6599080e0ab0e669a3c2640914375a9b0b357faae08b17")
                .unwrap();
        let delegator_keys = Keys::new(delegator_secret_key);
        let delegatee_pubkey =
            PublicKey::from_str("bea8aeb6c1657e33db5ac75a83910f77e8ec6145157e476b5b88c6e85b1fab34")
                .unwrap();
        let conditions =
            Conditions::from_str("kind=1&created_at>1676067553&created_at<1678659553").unwrap();

        let tag = DelegationTag::new(&delegator_keys, &delegatee_pubkey, conditions);

        // Positive
        assert!(tag
            .validate(&delegatee_pubkey, &EventProperties::new(1, 1677000000))
            .is_ok());

        // Signature verification fails if wrong delegatee key is given
        let wrong_pubkey =
            PublicKey::from_str("14b91c20c0287495615210ef7772192d43eca6d2a34342e723bd237035e7955b")
                .unwrap();

        // Note: Error cannot be tested simply  using equality
        match tag
            .validate(&wrong_pubkey, &EventProperties::new(1, 1677000000))
            .err()
            .unwrap()
        {
            Error::ConditionsValidation(e) => assert_eq!(e, ValidationError::InvalidSignature),
            _ => panic!("Expected ConditionsValidation"),
        }

        // Wrong event kind
        match tag
            .validate(&delegatee_pubkey, &EventProperties::new(9, 1677000000))
            .err()
            .unwrap()
        {
            Error::ConditionsValidation(e) => assert_eq!(e, ValidationError::InvalidKind),
            _ => panic!("Expected ConditionsValidation"),
        };

        // Wrong creation time
        match tag
            .validate(&delegatee_pubkey, &EventProperties::new(1, 1679000000))
            .err()
            .unwrap()
        {
            Error::ConditionsValidation(e) => assert_eq!(e, ValidationError::CreatedTooLate),
            _ => panic!("Expected ConditionsValidation"),
        };
    }

    #[test]
    fn test_conditions_to_string() {
        let mut c = Conditions::new();
        c.add(Condition::Kind(1));
        assert_eq!(c.to_string(), "kind=1");
        c.add(Condition::CreatedAfter(1674834236));
        c.add(Condition::CreatedBefore(1677426236));
        assert_eq!(
            c.to_string(),
            "kind=1&created_at>1674834236&created_at<1677426236"
        );
    }

    #[test]
    fn test_conditions_parse() {
        let c = Conditions::from_str("kind=1&created_at>1674834236&created_at<1677426236").unwrap();
        assert_eq!(
            c.to_string(),
            "kind=1&created_at>1674834236&created_at<1677426236"
        );

        // Special: empty string
        let c_empty = Conditions::from_str("").unwrap();
        assert_eq!(c_empty.to_string(), "");

        // One condition
        let c_one = Conditions::from_str("created_at<10000").unwrap();
        assert_eq!(c_one.to_string(), "created_at<10000");
    }

    #[test]
    fn test_conditions_parse_negative() {
        match Conditions::from_str("__invalid_condition__&kind=1")
            .err()
            .unwrap()
        {
            Error::ConditionsParseInvalidCondition => {}
            _ => panic!("Expected ConditionsParseInvalidCondition"),
        }
        match Conditions::from_str("kind=__invalid_number__")
            .err()
            .unwrap()
        {
            Error::ConditionsParseNumeric(_) => {}
            _ => panic!("Expected ConditionsParseNumeric"),
        }
    }

    #[test]
    fn test_conditions_evaluate() {
        let c_kind = Conditions::from_str("kind=3").unwrap();
        assert!(c_kind.evaluate(&EventProperties::new(3, 0)).is_ok());
        assert_eq!(
            c_kind.evaluate(&EventProperties::new(5, 0)).err().unwrap(),
            ValidationError::InvalidKind
        );

        let c_impossible = Conditions::from_str("kind=3&kind=4").unwrap();
        assert_eq!(
            c_impossible
                .evaluate(&EventProperties::new(3, 0))
                .err()
                .unwrap(),
            ValidationError::InvalidKind
        );

        let c_before = Conditions::from_str("created_at<1000").unwrap();
        assert!(c_before.evaluate(&EventProperties::new(3, 500)).is_ok());
        assert_eq!(
            c_before
                .evaluate(&EventProperties::new(3, 2000))
                .err()
                .unwrap(),
            ValidationError::CreatedTooLate
        );

        let c_after = Conditions::from_str("created_at>1000").unwrap();
        assert!(c_after.evaluate(&EventProperties::new(3, 2000)).is_ok());
        assert_eq!(
            c_after
                .evaluate(&EventProperties::new(3, 500))
                .err()
                .unwrap(),
            ValidationError::CreatedTooEarly
        );

        let c_complex =
            Conditions::from_str("kind=1&created_at>1676067553&created_at<1678659553").unwrap();
        assert!(c_complex
            .evaluate(&EventProperties::new(1, 1677000000))
            .is_ok());
        assert_eq!(
            c_complex
                .evaluate(&EventProperties::new(5, 1677000000))
                .err()
                .unwrap(),
            ValidationError::InvalidKind
        );
        assert_eq!(
            c_complex
                .evaluate(&EventProperties::new(1, 1674000000))
                .err()
                .unwrap(),
            ValidationError::CreatedTooEarly
        );
        assert_eq!(
            c_complex
                .evaluate(&EventProperties::new(1, 1699000000))
                .err()
                .unwrap(),
            ValidationError::CreatedTooLate
        );
    }
}

================
File: src/nips/nip34.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP34: git stuff
//!
//! <https://github.com/nostr-protocol/nips/blob/master/34.md>

#![allow(clippy::wrong_self_convention)]

use alloc::borrow::Cow;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;

use bitcoin::hashes::sha1::Hash as Sha1Hash;

use crate::nips::nip01::Coordinate;
use crate::nips::nip10::Marker;
use crate::types::url::Url;
use crate::{EventBuilder, EventId, Kind, PublicKey, Tag, TagKind, TagStandard, Timestamp};

/// Earlier unique commit ID
pub const EUC: &str = "euc";

const GIT_REPO_ANNOUNCEMENT_ALT: &str = "git repository";
const GIT_ISSUE_ALT: &str = "git issue";
const GIT_PATCH_ALT: &str = "git patch";
const GIT_PATCH_COVER_LETTER_ALT: &str = "git patch cover letter";

/// Git Repository Announcement
///
/// Git repositories are hosted in Git-enabled servers, but their existence can be announced using Nostr events,
/// as well as their willingness to receive patches, bug reports and comments in general.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GitRepositoryAnnouncement {
    /// Repository ID (usually kebab-case short name)
    pub id: String,
    /// Human-readable project name
    pub name: Option<String>,
    /// Brief human-readable project description
    pub description: Option<String>,
    /// Webpage urls, if the git server being used provides such a thing
    pub web: Vec<Url>,
    /// Urls for git-cloning
    pub clone: Vec<Url>,
    /// Relays that this repository will monitor for patches and issues
    pub relays: Vec<Url>,
    /// Earliest unique commit ID
    ///
    /// `euc` marker should be the commit ID of the earliest unique commit of this repo,
    /// made to identify it among forks and group it with other repositories hosted elsewhere that may represent essentially the same project.
    /// In most cases it will be the root commit of a repository.
    /// In case of a permanent fork between two projects, then the first commit after the fork should be used.
    pub euc: Option<String>,
    /// Other recognized maintainers
    pub maintainers: Vec<PublicKey>,
}

impl GitRepositoryAnnouncement {
    pub(crate) fn to_event_builder(self) -> EventBuilder {
        let mut tags: Vec<Tag> = Vec::with_capacity(1);

        // Add repo ID
        tags.push(Tag::identifier(self.id));

        // Add name
        if let Some(name) = self.name {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Name(name)));
        }

        // Add description
        if let Some(description) = self.description {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::Description(description),
            ));
        }

        // Add web
        if !self.web.is_empty() {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Web(
                self.web,
            )));
        }

        // Add clone
        if !self.clone.is_empty() {
            tags.push(Tag::from_standardized_without_cell(TagStandard::GitClone(
                self.clone,
            )));
        }

        // Add relays
        if !self.relays.is_empty() {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Relays(
                self.relays,
            )));
        }

        // Add EUC
        if let Some(euc) = self.euc {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::GitEarliestUniqueCommitId(euc),
            ));
        }

        // Add maintainers
        if !self.maintainers.is_empty() {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::GitMaintainers(self.maintainers),
            ));
        }

        // Add alt tag
        tags.push(Tag::alt(GIT_REPO_ANNOUNCEMENT_ALT));

        // Build
        EventBuilder::new(Kind::GitRepoAnnouncement, "").tags(tags)
    }
}

/// Git Issue
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GitIssue {
    /// The issue content (markdown)
    pub content: String,
    /// The repository address
    pub repository: Coordinate,
    /// Public keys (owners or other users)
    pub public_keys: Vec<PublicKey>,
    /// Subject
    pub subject: Option<String>,
    /// Labels
    pub labels: Vec<String>,
}

impl GitIssue {
    pub(crate) fn to_event_builder(self) -> EventBuilder {
        let mut tags: Vec<Tag> = Vec::with_capacity(1);

        // Add coordinate
        tags.push(Tag::coordinate(self.repository));

        // Add public keys
        tags.extend(self.public_keys.into_iter().map(Tag::public_key));

        // Add subject
        if let Some(subject) = self.subject {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Subject(
                subject,
            )));
        }

        // Add labels
        tags.extend(self.labels.into_iter().map(Tag::hashtag));

        // Add alt tag
        tags.push(Tag::alt(GIT_ISSUE_ALT));

        // Build
        EventBuilder::new(Kind::GitIssue, self.content).tags(tags)
    }
}

/// Git Patch Committer
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GitPatchCommitter {
    /// Name
    pub name: Option<String>,
    /// Email
    pub email: Option<String>,
    /// Timestamp
    pub timestamp: Timestamp,
    /// Timezone offset in minutes
    pub offset_minutes: i32,
}

/// Git Patch Content
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum GitPatchContent {
    /// Cover letter
    CoverLetter {
        /// Title
        title: String,
        /// Description
        description: String,
        /// Last commit
        last_commit: Sha1Hash,
        /// Number of commits
        commits_len: usize,
    },
    /// Patch
    Patch {
        /// Patch content
        content: String,
        /// Commit hash
        commit: Sha1Hash,
        /// Parent commit
        parent_commit: Sha1Hash,
        /// PGP signature of commit
        commit_pgp_sig: Option<String>,
        /// Committer
        committer: GitPatchCommitter,
    },
}

impl fmt::Display for GitPatchContent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::CoverLetter {
                title,
                description,
                last_commit,
                commits_len,
            } => {
                write!(f, "From {last_commit} Mon Sep 17 00:00:00 2001\nSubject: [PATCH 0/{commits_len}] {title}\n\n{description}")
            }
            Self::Patch { content, .. } => write!(f, "{content}"),
        }
    }
}

/// Git Patch
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct GitPatch {
    /// Repository ID
    pub repo_id: String,
    /// Patch
    pub content: GitPatchContent,
    /// Maintainers
    pub maintainers: Vec<PublicKey>,
    /// Earliest unique commit ID of repo
    pub euc: String,
    /// Root proposal ID
    pub root_proposal_id: Option<EventId>,
}

impl GitPatch {
    pub(crate) fn to_event_builder(self) -> EventBuilder {
        let content: String = self.content.to_string();

        let mut tags: Vec<Tag> = Vec::with_capacity(2);

        // Add coordinate
        tags.reserve_exact(self.maintainers.len());
        tags.extend(self.maintainers.iter().copied().map(|p| {
            Tag::coordinate(
                Coordinate::new(Kind::GitRepoAnnouncement, p).identifier(self.repo_id.clone()),
            )
        }));

        // Add EUC (as reference, not with `euc` marker)
        tags.push(Tag::reference(self.euc));

        // Handle patch content
        match self.content {
            GitPatchContent::CoverLetter { title, .. } => {
                // Add cover letter tags
                tags.reserve_exact(2);
                tags.push(Tag::hashtag("cover-letter"));
                tags.push(Tag::alt(format!("{GIT_PATCH_COVER_LETTER_ALT}: {title}")));
            }
            GitPatchContent::Patch {
                commit,
                parent_commit,
                commit_pgp_sig,
                committer,
                ..
            } => {
                tags.reserve_exact(6);
                tags.push(Tag::reference(commit.to_string()));
                tags.push(Tag::from_standardized_without_cell(TagStandard::GitCommit(
                    commit,
                )));
                tags.push(Tag::custom(
                    TagKind::Custom(Cow::Borrowed("parent-commit")),
                    vec![parent_commit.to_string()],
                ));
                tags.push(Tag::custom(
                    TagKind::Custom(Cow::Borrowed("commit-pgp-sig")),
                    vec![commit_pgp_sig.unwrap_or_default()],
                ));
                tags.push(Tag::custom(
                    TagKind::Custom(Cow::Borrowed("committer")),
                    vec![
                        committer.name.unwrap_or_default(),
                        committer.email.unwrap_or_default(),
                        committer.timestamp.to_string(),
                        committer.offset_minutes.to_string(),
                    ],
                ));
                tags.push(Tag::alt(GIT_PATCH_ALT));
            }
        }

        // Handle root proposal ID
        match self.root_proposal_id {
            Some(root_proposal_id) => {
                tags.reserve_exact(3);
                tags.push(Tag::hashtag("root"));
                tags.push(Tag::hashtag("revision-root"));
                tags.push(Tag::from_standardized_without_cell(TagStandard::Event {
                    event_id: root_proposal_id,
                    relay_url: None,
                    marker: Some(Marker::Reply),
                    public_key: None,
                    uppercase: false,
                }));
            }
            None => tags.push(Tag::hashtag("root")),
        }

        // Add public keys
        tags.reserve_exact(self.maintainers.len());
        tags.extend(self.maintainers.into_iter().map(Tag::public_key));

        // Build
        EventBuilder::new(Kind::GitPatch, content).tags(tags)
    }
}

================
File: src/nips/nip39.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP39: External Identities in Profiles
//!
//! <https://github.com/nostr-protocol/nips/blob/master/39.md>

use alloc::string::{String, ToString};
use core::fmt;
use core::str::FromStr;

/// NIP56 error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Invalid identity
    InvalidIdentity,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidIdentity => write!(f, "Invalid identity tag"),
        }
    }
}

/// Supported external identity providers
///
/// <https://github.com/nostr-protocol/nips/blob/master/39.md>
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum ExternalIdentity {
    /// github.com
    GitHub,
    /// twitter.com
    Twitter,
    /// mastodon.social
    Mastodon,
    /// telegram.org
    Telegram,
}

impl fmt::Display for ExternalIdentity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::GitHub => write!(f, "github"),
            Self::Twitter => write!(f, "twitter"),
            Self::Mastodon => write!(f, "mastodon"),
            Self::Telegram => write!(f, "telegram"),
        }
    }
}

impl FromStr for ExternalIdentity {
    type Err = Error;

    fn from_str(identity: &str) -> Result<Self, Self::Err> {
        match identity {
            "github" => Ok(Self::GitHub),
            "twitter" => Ok(Self::Twitter),
            "mastodon" => Ok(Self::Mastodon),
            "telegram" => Ok(Self::Telegram),
            _ => Err(Error::InvalidIdentity),
        }
    }
}

/// External identity
///
/// <https://github.com/nostr-protocol/nips/blob/master/39.md>
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Identity {
    /// The external identity provider
    pub platform: ExternalIdentity,
    /// The user's identity (username) on the provider
    pub ident: String,
    /// The user's proof on the provider
    pub proof: String,
}

impl Identity {
    /// Construct new identity
    pub fn new<S1, S2>(platform_iden: S1, proof: S2) -> Result<Self, Error>
    where
        S1: AsRef<str>,
        S2: Into<String>,
    {
        let i: &str = platform_iden.as_ref();
        let (platform, ident) = i.rsplit_once(':').ok_or(Error::InvalidIdentity)?;

        Ok(Self {
            platform: ExternalIdentity::from_str(platform)?,
            ident: ident.to_string(),
            proof: proof.into(),
        })
    }

    #[inline]
    pub(crate) fn tag_platform_identity(&self) -> String {
        format!("{}:{}", self.platform, self.ident)
    }
}

================
File: src/nips/nip46.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP46: Nostr Connect
//!
//! <https://github.com/nostr-protocol/nips/blob/master/46.md>

use alloc::borrow::{Cow, ToOwned};
use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;
use core::str::FromStr;
use std::collections::HashMap;

#[cfg(feature = "std")]
use bitcoin::secp256k1::rand;
use bitcoin::secp256k1::rand::RngCore;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json::json;

use crate::event::unsigned::{self, UnsignedEvent};
use crate::types::url::{self, ParseError, RelayUrl, Url};
use crate::{key, Event, JsonUtil, PublicKey};

/// NIP46 URI Scheme
pub const NOSTR_CONNECT_URI_SCHEME: &str = "nostrconnect";
/// NIP46 bunker URI Scheme
pub const NOSTR_CONNECT_BUNKER_URI_SCHEME: &str = "bunker";

/// NIP46 error
#[derive(Debug)]
pub enum Error {
    /// Key error
    Key(key::Error),
    /// JSON error
    Json(serde_json::Error),
    /// Relay Url parse error
    RelayUrl(url::Error),
    /// Url parse error
    Url(ParseError),
    /// Unsigned event error
    Unsigned(unsigned::Error),
    /// Invalid request
    InvalidRequest,
    /// Too many/few params
    InvalidParamsLength,
    /// Unsupported method
    UnsupportedMethod(String),
    /// Invalid URI
    InvalidURI,
    /// Invalid URI scheme
    InvalidURIScheme,
    /// Not request
    NotRequest,
    /// Unexpected result
    UnexpectedResult,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Key(e) => write!(f, "Key: {e}"),
            Self::Json(e) => write!(f, "Json: {e}"),
            Self::RelayUrl(e) => write!(f, "{e}"),
            Self::Url(e) => write!(f, "{e}"),
            Self::Unsigned(e) => write!(f, "Unsigned event: {e}"),
            Self::InvalidRequest => write!(f, "Invalid request"),
            Self::InvalidParamsLength => write!(f, "Too many/few params"),
            Self::UnsupportedMethod(name) => write!(f, "Unsupported method: {name}"),
            Self::InvalidURI => write!(f, "Invalid uri"),
            Self::InvalidURIScheme => write!(f, "Invalid uri scheme"),
            Self::NotRequest => write!(f, "This message is not a request"),
            Self::UnexpectedResult => write!(f, "Unexpected result"),
        }
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Key(e)
    }
}

impl From<serde_json::Error> for Error {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e)
    }
}

impl From<url::Error> for Error {
    fn from(e: url::Error) -> Self {
        Self::RelayUrl(e)
    }
}

impl From<ParseError> for Error {
    fn from(e: ParseError) -> Self {
        Self::Url(e)
    }
}

impl From<unsigned::Error> for Error {
    fn from(e: unsigned::Error) -> Self {
        Self::Unsigned(e)
    }
}

/// NIP46 method
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Method {
    /// Connect
    Connect,
    /// Get public key
    GetPublicKey,
    /// Sign event
    SignEvent,
    /// Get relays
    GetRelays,
    /// Encrypt text (NIP04)
    Nip04Encrypt,
    /// Decrypt (NIP04)
    Nip04Decrypt,
    /// Encrypt text (NIP44)
    Nip44Encrypt,
    /// Decrypt (NIP44)
    Nip44Decrypt,
    /// Ping
    Ping,
}

impl fmt::Display for Method {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Connect => write!(f, "connect"),
            Self::GetPublicKey => write!(f, "get_public_key"),
            Self::SignEvent => write!(f, "sign_event"),
            Self::GetRelays => write!(f, "get_relays"),
            Self::Nip04Encrypt => write!(f, "nip04_encrypt"),
            Self::Nip04Decrypt => write!(f, "nip04_decrypt"),
            Self::Nip44Encrypt => write!(f, "nip44_encrypt"),
            Self::Nip44Decrypt => write!(f, "nip44_decrypt"),
            Self::Ping => write!(f, "ping"),
        }
    }
}

impl FromStr for Method {
    type Err = Error;

    fn from_str(method: &str) -> Result<Self, Self::Err> {
        match method {
            "connect" => Ok(Self::Connect),
            "get_public_key" => Ok(Self::GetPublicKey),
            "sign_event" => Ok(Self::SignEvent),
            "get_relays" => Ok(Self::GetRelays),
            "nip04_encrypt" => Ok(Self::Nip04Encrypt),
            "nip04_decrypt" => Ok(Self::Nip04Decrypt),
            "nip44_encrypt" => Ok(Self::Nip44Encrypt),
            "nip44_decrypt" => Ok(Self::Nip44Decrypt),
            "ping" => Ok(Self::Ping),
            other => Err(Error::UnsupportedMethod(other.to_string())),
        }
    }
}

impl Serialize for Method {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for Method {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let method: String = String::deserialize(deserializer)?;
        Self::from_str(&method).map_err(serde::de::Error::custom)
    }
}

/// Request
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Request {
    /// Connect
    Connect {
        /// Remote public key
        public_key: PublicKey,
        /// Optional secret
        secret: Option<String>,
    },
    /// Get public key
    GetPublicKey,
    /// Sign [`UnsignedEvent`]
    SignEvent(UnsignedEvent),
    /// Get relays
    GetRelays,
    /// Encrypt text (NIP04)
    Nip04Encrypt {
        /// Pubkey
        public_key: PublicKey,
        /// Plain text
        text: String,
    },
    /// Decrypt (NIP04)
    Nip04Decrypt {
        /// Pubkey
        public_key: PublicKey,
        /// Ciphertext
        ciphertext: String,
    },
    /// Encrypt text (NIP44)
    Nip44Encrypt {
        /// Pubkey
        public_key: PublicKey,
        /// Plain text
        text: String,
    },
    /// Decrypt (NIP44)
    Nip44Decrypt {
        /// Pubkey
        public_key: PublicKey,
        /// Ciphertext
        ciphertext: String,
    },
    /// Ping
    Ping,
}

impl Request {
    /// Compose [Request] from message details
    pub fn from_message(method: Method, params: Vec<String>) -> Result<Self, Error> {
        match method {
            Method::Connect => {
                let public_key = params.first().ok_or(Error::InvalidRequest)?;
                let public_key: PublicKey = PublicKey::from_hex(public_key)?;
                let secret: Option<String> = params.get(1).cloned();
                Ok(Self::Connect { public_key, secret })
            }
            Method::GetPublicKey => Ok(Self::GetPublicKey),
            Method::SignEvent => {
                let unsigned: &String = params.first().ok_or(Error::InvalidRequest)?;
                let unsigned_event: UnsignedEvent = UnsignedEvent::from_json(unsigned)?;
                Ok(Self::SignEvent(unsigned_event))
            }
            Method::GetRelays => Ok(Self::GetRelays),
            Method::Nip04Encrypt => {
                if params.len() != 2 {
                    return Err(Error::InvalidParamsLength);
                }

                Ok(Self::Nip04Encrypt {
                    public_key: PublicKey::from_hex(&params[0])?,
                    text: params[1].to_owned(),
                })
            }
            Method::Nip04Decrypt => {
                if params.len() != 2 {
                    return Err(Error::InvalidParamsLength);
                }

                Ok(Self::Nip04Decrypt {
                    public_key: PublicKey::from_hex(&params[0])?,
                    ciphertext: params[1].to_owned(),
                })
            }
            Method::Nip44Encrypt => {
                if params.len() != 2 {
                    return Err(Error::InvalidParamsLength);
                }

                Ok(Self::Nip44Encrypt {
                    public_key: PublicKey::from_hex(&params[0])?,
                    text: params[1].to_owned(),
                })
            }
            Method::Nip44Decrypt => {
                if params.len() != 2 {
                    return Err(Error::InvalidParamsLength);
                }

                Ok(Self::Nip44Decrypt {
                    public_key: PublicKey::from_hex(&params[0])?,
                    ciphertext: params[1].to_owned(),
                })
            }
            Method::Ping => Ok(Self::Ping),
        }
    }

    /// Get req method
    pub fn method(&self) -> Method {
        match self {
            Self::Connect { .. } => Method::Connect,
            Self::GetPublicKey => Method::GetPublicKey,
            Self::SignEvent(_) => Method::SignEvent,
            Self::GetRelays => Method::GetRelays,
            Self::Nip04Encrypt { .. } => Method::Nip04Encrypt,
            Self::Nip04Decrypt { .. } => Method::Nip04Decrypt,
            Self::Nip44Encrypt { .. } => Method::Nip44Encrypt,
            Self::Nip44Decrypt { .. } => Method::Nip44Decrypt,
            Self::Ping => Method::Ping,
        }
    }

    /// Get req params
    pub fn params(&self) -> Vec<String> {
        match self {
            Self::Connect { public_key, secret } => {
                let mut params = vec![public_key.to_hex()];
                if let Some(secret) = secret {
                    params.push(secret.to_owned());
                }
                params
            }
            Self::GetPublicKey => Vec::new(),
            Self::SignEvent(event) => vec![event.as_json()],
            Self::GetRelays => Vec::new(),
            Self::Nip04Encrypt { public_key, text } | Self::Nip44Encrypt { public_key, text } => {
                vec![public_key.to_hex(), text.to_owned()]
            }
            Self::Nip04Decrypt {
                public_key,
                ciphertext,
            }
            | Self::Nip44Decrypt {
                public_key,
                ciphertext,
            } => vec![public_key.to_hex(), ciphertext.to_owned()],
            Self::Ping => Vec::new(),
        }
    }
}

/// Relay permission
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct RelayPermissions {
    /// Read
    pub read: bool,
    /// Write
    pub write: bool,
}

/// Response
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ResponseResult {
    /// Connect ACK
    Connect,
    /// Get public key
    GetPublicKey(PublicKey),
    /// Sign event
    SignEvent(Box<Event>),
    /// Get relays
    GetRelays(HashMap<RelayUrl, RelayPermissions>),
    /// NIP04/NIP44 encryption/decryption
    EncryptionDecryption(String),
    /// Pong
    Pong,
    /// Auth Challenges
    AuthUrl,
    /// Error
    Error,
}

impl fmt::Display for ResponseResult {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Connect => write!(f, "ack"),
            Self::Pong => write!(f, "pong"),
            Self::AuthUrl => write!(f, "auth_url"),
            Self::Error => write!(f, "error"),
            Self::GetPublicKey(public_key) => write!(f, "{public_key}"),
            Self::SignEvent(event) => write!(f, "{}", event.as_json()),
            Self::GetRelays(map) => write!(f, "{}", json!(map)),
            Self::EncryptionDecryption(val) => write!(f, "{val}"),
        }
    }
}

#[allow(missing_docs)]
impl ResponseResult {
    pub fn parse(res: &str) -> Result<Self, Error> {
        match res {
            "ack" => Ok(Self::Connect),
            "pong" => Ok(Self::Pong),
            "auth_url" => Ok(Self::AuthUrl),
            "error" => Ok(Self::Error),
            other => {
                if let Ok(public_key) = PublicKey::from_hex(other) {
                    Ok(Self::GetPublicKey(public_key))
                } else if let Ok(event) = Event::from_json(other) {
                    Ok(Self::SignEvent(Box::new(event)))
                } else if let Ok(map) = serde_json::from_str(other) {
                    Ok(Self::GetRelays(map))
                } else {
                    Ok(Self::EncryptionDecryption(other.to_string()))
                }
            }
        }
    }
    #[inline]
    pub fn is_auth_url(&self) -> bool {
        matches!(self, Self::AuthUrl)
    }

    #[inline]
    pub fn is_error(&self) -> bool {
        matches!(self, Self::Error)
    }

    #[inline]
    pub fn to_connect(self) -> Result<(), Error> {
        if let Self::Connect = self {
            Ok(())
        } else {
            Err(Error::UnexpectedResult)
        }
    }

    #[inline]
    pub fn to_get_public_key(self) -> Result<PublicKey, Error> {
        if let Self::GetPublicKey(val) = self {
            Ok(val)
        } else {
            Err(Error::UnexpectedResult)
        }
    }

    #[inline]
    pub fn to_get_relays(self) -> Result<HashMap<RelayUrl, RelayPermissions>, Error> {
        if let Self::GetRelays(val) = self {
            Ok(val)
        } else {
            Err(Error::UnexpectedResult)
        }
    }

    #[inline]
    pub fn to_sign_event(self) -> Result<Event, Error> {
        if let Self::SignEvent(val) = self {
            Ok(*val)
        } else {
            Err(Error::UnexpectedResult)
        }
    }

    #[inline]
    pub fn to_pong(self) -> Result<(), Error> {
        if let Self::Pong = self {
            Ok(())
        } else {
            Err(Error::UnexpectedResult)
        }
    }

    #[inline]
    pub fn to_encrypt_decrypt(self) -> Result<String, Error> {
        if let Self::EncryptionDecryption(val) = self {
            Ok(val)
        } else {
            Err(Error::UnexpectedResult)
        }
    }
}

#[derive(Serialize, Deserialize)]
#[serde(untagged)]
enum MessageIntermediate {
    Request {
        id: String,
        method: Method,
        params: Vec<String>,
    },
    Response {
        id: String,
        result: Option<String>,
        error: Option<String>,
    },
}

/// Message
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Message {
    /// Request
    Request {
        /// Request id
        id: String,
        /// Request
        req: Request,
    },
    /// Response
    Response {
        /// Request id
        id: String,
        /// Result
        result: Option<ResponseResult>,
        /// Reason, if failed
        error: Option<String>,
    },
}

impl fmt::Display for Message {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_json())
    }
}

impl Message {
    /// Compose [`Request`] message
    #[inline]
    #[cfg(feature = "std")]
    pub fn request(req: Request) -> Self {
        Self::request_with_rng(&mut rand::thread_rng(), req)
    }

    /// Compose [`Request`] message
    #[inline]
    pub fn request_with_rng<R>(rng: &mut R, req: Request) -> Self
    where
        R: RngCore,
    {
        Self::Request {
            id: rng.next_u32().to_string(),
            req,
        }
    }

    /// Compose `Response` message
    #[inline]
    pub fn response<S>(req_id: S, result: Option<ResponseResult>, error: Option<S>) -> Self
    where
        S: Into<String>,
    {
        Self::Response {
            id: req_id.into(),
            result,
            error: error.map(|e| e.into()),
        }
    }

    /// Check if current [`Message`] is a request
    #[inline]
    pub fn is_request(&self) -> bool {
        match self {
            Message::Request { .. } => true,
            Message::Response { .. } => false,
        }
    }

    /* pub fn as_request(&self) -> Result<&Request, Error> {
        match self {
            Self::Request { req, .. } => Ok(req),
            _ => Err(Error::NotRequest)
        }
    } */

    /// Consume [Message] and return [Request]
    #[inline]
    pub fn to_request(self) -> Result<Request, Error> {
        match self {
            Self::Request { req, .. } => Ok(req),
            _ => Err(Error::NotRequest),
        }
    }

    /// Get [`Message`] id
    #[inline]
    pub fn id(&self) -> &str {
        match self {
            Self::Request { id, .. } => id,
            Self::Response { id, .. } => id,
        }
    }

    /// Generate response error message for a request
    pub fn generate_error_response<S>(&self, error: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        // Check if Message is a Request
        if self.is_request() {
            let error: &str = error.as_ref();
            Ok(Self::response(self.id(), None, Some(error)))
        } else {
            Err(Error::NotRequest)
        }
    }

    /// Check if result response is `auth_url`
    pub fn is_auth_url(&self) -> bool {
        match self {
            Self::Request { .. } => false,
            Self::Response { result, .. } => match result {
                Some(result) => result.is_auth_url(),
                None => false,
            },
        }
    }
}

impl Serialize for Message {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let intermediate: MessageIntermediate = match self {
            Self::Request { id, req } => MessageIntermediate::Request {
                id: id.to_owned(),
                method: req.method(),
                params: req.params(),
            },
            Self::Response { id, result, error } => MessageIntermediate::Response {
                id: id.to_owned(),
                result: result.as_ref().map(|res| res.to_string()),
                error: error.clone(),
            },
        };
        intermediate.serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for Message {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let intermediate: MessageIntermediate = MessageIntermediate::deserialize(deserializer)?;
        match intermediate {
            MessageIntermediate::Request { id, method, params } => Ok(Self::Request {
                id,
                req: Request::from_message(method, params).map_err(serde::de::Error::custom)?,
            }),
            MessageIntermediate::Response { id, result, error } => {
                let result: Option<ResponseResult> = match result {
                    Some(res) => {
                        // Deserialize response
                        let res: ResponseResult =
                            ResponseResult::parse(&res).map_err(serde::de::Error::custom)?;

                        // Check if is error
                        if res.is_error() {
                            None
                        } else {
                            Some(res)
                        }
                    }
                    None => None,
                };
                Ok(Self::Response { id, result, error })
            }
        }
    }
}

impl JsonUtil for Message {
    type Err = Error;
}

/// Nostr Connect Metadata
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct NostrConnectMetadata {
    /// Human-readable name of the `App`
    pub name: String,
    /// URL of the website requesting the connection
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<Url>,
    /// Description of the `App`
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Array of URLs for icons of the `App`
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icons: Option<Vec<Url>>,
}

impl NostrConnectMetadata {
    /// New Nostr Connect Metadata
    #[inline]
    pub fn new<S>(name: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            name: name.into(),
            url: None,
            description: None,
            icons: None,
        }
    }

    /// Set url
    pub fn url(self, url: Url) -> Self {
        Self {
            url: Some(url),
            ..self
        }
    }

    /// Set description
    pub fn description<S>(self, description: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            description: Some(description.into()),
            ..self
        }
    }

    /// Set icons
    pub fn icons(self, icons: Vec<Url>) -> Self {
        Self {
            icons: Some(icons),
            ..self
        }
    }
}

impl JsonUtil for NostrConnectMetadata {
    type Err = Error;
}

/// Nostr Connect URI
#[derive(Debug, Clone, Eq, PartialEq, PartialOrd, Ord, Hash)]
pub enum NostrConnectURI {
    /// Direct connection initiated by remote signer
    Bunker {
        /// Remote signer public key
        remote_signer_public_key: PublicKey,
        /// List of relays to use
        relays: Vec<RelayUrl>,
        /// Optional secret
        secret: Option<String>,
    },
    /// Direct connection initiated by the client
    Client {
        /// App Pubkey
        public_key: PublicKey,
        /// URLs of the relays of choice where the `App` is connected and the `Signer` must send and listen for messages.
        relays: Vec<RelayUrl>,
        /// Metadata
        metadata: NostrConnectMetadata,
    },
}

impl NostrConnectURI {
    /// Construct [NostrConnectURI] initiated by the client
    #[inline]
    pub fn client<I, S>(public_key: PublicKey, relays: I, app_name: S) -> Self
    where
        I: IntoIterator<Item = RelayUrl>,
        S: Into<String>,
    {
        Self::Client {
            public_key,
            relays: relays.into_iter().collect(),
            metadata: NostrConnectMetadata::new(app_name),
        }
    }

    /// Parse Nostr Connect URI
    pub fn parse<S>(uri: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let uri: &str = uri.as_ref();
        let uri: Url = Url::parse(uri)?;

        match uri.scheme() {
            NOSTR_CONNECT_BUNKER_URI_SCHEME => {
                if let Some(pubkey) = uri.domain() {
                    let public_key = PublicKey::from_hex(pubkey)?;

                    let mut relays: Vec<RelayUrl> = Vec::new();
                    let mut secret: Option<String> = None;

                    for (key, value) in uri.query_pairs() {
                        match key {
                            Cow::Borrowed("relay") => {
                                let value = value.to_string();
                                relays.push(RelayUrl::parse(&value)?);
                            }
                            Cow::Borrowed("secret") => {
                                secret = Some(value.to_string());
                            }
                            _ => (),
                        }
                    }

                    return Ok(Self::Bunker {
                        remote_signer_public_key: public_key,
                        relays,
                        secret,
                    });
                }

                Err(Error::InvalidURI)
            }
            NOSTR_CONNECT_URI_SCHEME => {
                if let Some(pubkey) = uri.domain() {
                    let public_key = PublicKey::from_hex(pubkey)?;

                    let mut relays: Vec<RelayUrl> = Vec::new();
                    let mut metadata: Option<NostrConnectMetadata> = None;

                    for (key, value) in uri.query_pairs() {
                        match key {
                            Cow::Borrowed("relay") => {
                                let value = value.to_string();
                                relays.push(RelayUrl::parse(&value)?);
                            }
                            Cow::Borrowed("metadata") => {
                                let value = value.to_string();
                                metadata = Some(serde_json::from_str(&value)?);
                            }
                            _ => (),
                        }
                    }

                    if let Some(metadata) = metadata {
                        return Ok(Self::Client {
                            public_key,
                            relays,
                            metadata,
                        });
                    }
                }

                Err(Error::InvalidURI)
            }
            _ => Err(Error::InvalidURIScheme),
        }
    }

    /// Check if is `bunker` URI
    #[inline]
    pub fn is_bunker(&self) -> bool {
        matches!(self, Self::Bunker { .. })
    }

    /// Get remote signer public key (exists only for `bunker` URIs)
    ///
    /// This public key MAY be same as the user one, but not necessarily.
    #[inline]
    pub fn remote_signer_public_key(&self) -> Option<&PublicKey> {
        match self {
            Self::Bunker {
                remote_signer_public_key,
                ..
            } => Some(remote_signer_public_key),
            Self::Client { .. } => None,
        }
    }

    /// Get relays
    #[inline]
    pub fn relays(&self) -> &[RelayUrl] {
        match self {
            Self::Bunker { relays, .. } => relays.as_slice(),
            Self::Client { relays, .. } => relays.as_slice(),
        }
    }

    /// Get secret
    #[inline]
    pub fn secret(&self) -> Option<&str> {
        match self {
            Self::Bunker { secret, .. } => secret.as_deref(),
            Self::Client { .. } => None,
        }
    }
}

impl FromStr for NostrConnectURI {
    type Err = Error;

    #[inline]
    fn from_str(uri: &str) -> Result<Self, Self::Err> {
        Self::parse(uri)
    }
}

impl fmt::Display for NostrConnectURI {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Bunker {
                remote_signer_public_key,
                relays,
                secret,
            } => {
                let mut query: String = String::new();

                for relay_url in relays.iter() {
                    let relay_url = relay_url.to_string();
                    let relay_url = relay_url.strip_suffix('/').unwrap_or(&relay_url);

                    if !query.is_empty() {
                        query.push('&');
                    }

                    query.push_str("relay=");
                    query.push_str(relay_url);
                }

                if let Some(secret) = secret {
                    if !query.is_empty() {
                        query.push('&');
                    }

                    query.push_str("secret=");
                    query.push_str(secret);
                }

                if query.is_empty() {
                    write!(
                        f,
                        "{NOSTR_CONNECT_BUNKER_URI_SCHEME}://{remote_signer_public_key}"
                    )
                } else {
                    write!(
                        f,
                        "{NOSTR_CONNECT_BUNKER_URI_SCHEME}://{remote_signer_public_key}?{query}"
                    )
                }
            }
            Self::Client {
                public_key,
                relays,
                metadata,
            } => {
                let mut relays_str: String = String::new();

                for relay_url in relays.iter() {
                    let relay_url = relay_url.to_string();
                    let relay_url = relay_url.strip_suffix('/').unwrap_or(&relay_url);

                    relays_str.push_str("&relay=");
                    relays_str.push_str(relay_url);
                }

                write!(
                    f,
                    "{NOSTR_CONNECT_URI_SCHEME}://{}?metadata={}{relays_str}",
                    public_key,
                    metadata.as_json()
                )
            }
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_parse_bunker_uri() {
        let uri = "bunker://79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3?relay=wss://relay.nsec.app";
        let uri = NostrConnectURI::parse(uri).unwrap();

        let remote_signer_public_key =
            PublicKey::parse("79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3")
                .unwrap();
        let relay_url = RelayUrl::parse("wss://relay.nsec.app").unwrap();
        assert_eq!(uri.relays(), vec![relay_url.clone()]);
        assert_eq!(
            uri,
            NostrConnectURI::Bunker {
                remote_signer_public_key,
                relays: vec![relay_url],
                secret: None
            }
        );
    }

    #[test]
    fn test_parse_client_uri() {
        let uri = r#"nostrconnect://b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4?metadata={"name":"Example"}&relay=wss://relay.damus.io"#;
        let uri = NostrConnectURI::parse(uri).unwrap();

        let pubkey =
            PublicKey::parse("b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4")
                .unwrap();
        let relay_url = RelayUrl::parse("wss://relay.damus.io").unwrap();
        let app_name = "Example";
        assert_eq!(uri, NostrConnectURI::client(pubkey, [relay_url], app_name));
    }

    #[test]
    fn test_bunker_uri_serialization() {
        let uri = "bunker://79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3?relay=wss://relay.nsec.app&secret=abcd";

        let remote_signer_public_key =
            PublicKey::parse("79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3")
                .unwrap();
        let relay_url = RelayUrl::parse("wss://relay.nsec.app").unwrap();
        assert_eq!(
            NostrConnectURI::Bunker {
                remote_signer_public_key,
                relays: vec![relay_url],
                secret: Some(String::from("abcd"))
            }
            .to_string(),
            uri
        );
    }

    #[test]
    fn test_client_uri_serialization() {
        let uri = r#"nostrconnect://b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4?metadata={"name":"Example"}&relay=wss://relay.damus.io"#;

        let pubkey =
            PublicKey::parse("b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4")
                .unwrap();
        let relay_url = RelayUrl::parse("wss://relay.damus.io").unwrap();
        let app_name = "Example";
        assert_eq!(
            NostrConnectURI::client(pubkey, [relay_url], app_name).to_string(),
            uri
        );
    }

    #[test]
    fn test_parse_response_result() {
        let res: ResponseResult = ResponseResult::parse("ack").unwrap();
        assert_eq!(res, ResponseResult::Connect);

        let pubkey =
            PublicKey::parse("b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4")
                .unwrap();
        let res: ResponseResult = ResponseResult::parse(
            "b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4",
        )
        .unwrap();
        assert_eq!(res, ResponseResult::GetPublicKey(pubkey));

        let json = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;
        let event = Event::from_json(json).unwrap();
        let res: ResponseResult = ResponseResult::parse(json).unwrap();
        assert_eq!(res, ResponseResult::SignEvent(Box::new(event)));

        let res: ResponseResult = ResponseResult::parse("pong").unwrap();
        assert_eq!(res, ResponseResult::Pong);
    }

    #[test]
    fn test_message_serialization() {
        // Error
        let message = Message::response(
            "2581081643",
            Some(ResponseResult::Error),
            Some("Empty response"),
        );
        let json = r#"{"id":"2581081643","result":"error","error":"Empty response"}"#;
        assert_eq!(message.as_json(), json);

        // Sign event
        let unsigned = UnsignedEvent::from_json(r#"{"created_at":1710854115,"content":"Testing rust-nostr NIP46 signer [bunker]","tags":[],"kind":1,"pubkey":"79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3","id":"236ad3390704e1bf435f40143fb3de163723aeaa8f25c3bf12a0ac4d9a4b56a7"}"#).unwrap();
        let json = r#"{"id":"3047714669","method":"sign_event","params":["{\"id\":\"236ad3390704e1bf435f40143fb3de163723aeaa8f25c3bf12a0ac4d9a4b56a7\",\"pubkey\":\"79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3\",\"created_at\":1710854115,\"kind\":1,\"tags\":[],\"content\":\"Testing rust-nostr NIP46 signer [bunker]\"}"]}"#;
        let message = Message::Request {
            id: String::from("3047714669"),
            req: Request::SignEvent(unsigned),
        };
        assert_eq!(message.as_json(), json);
    }

    #[test]
    fn test_message_deserialization() {
        // Connect
        let json = r#"{"id":"2845841889","method":"connect","params":["79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3"]}"#;
        let message = Message::from_json(json).unwrap();
        assert_eq!(
            message,
            Message::Request {
                id: String::from("2845841889"),
                req: Request::Connect {
                    public_key: PublicKey::from_hex(
                        "79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3"
                    )
                    .unwrap(),
                    secret: None
                }
            }
        );

        // Connect ACK
        let json = r#"{"id":"2581081643","result":"ack","error":null}"#;
        let message = Message::from_json(json).unwrap();
        assert_eq!(
            message,
            Message::response("2581081643", Some(ResponseResult::Connect), None)
        );

        // Error
        let json = r#"{"id":"2581081643","result":"error","error":"Empty response"}"#;
        let message = Message::from_json(json).unwrap();
        assert_eq!(
            message,
            Message::response("2581081643", None, Some("Empty response"))
        );

        // Sign event
        let event = Event::from_json(r#"{"created_at":1710854115,"content":"Testing rust-nostr NIP46 signer [bunker]","tags":[],"kind":1,"pubkey":"79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3","id":"236ad3390704e1bf435f40143fb3de163723aeaa8f25c3bf12a0ac4d9a4b56a7","sig":"509b8fe51c1e4c4cc55a0b2032b70bfb683f1da6c62e4e5b0da7175eab99b18c67862deaaea80cf31acedb9ad3022ebf54fd0cb6c9d1297a96541848d2035d92"}"#).unwrap();
        let json = r#"{"id":"3047714669","result":"{\"created_at\":1710854115,\"content\":\"Testing rust-nostr NIP46 signer [bunker]\",\"tags\":[],\"kind\":1,\"pubkey\":\"79dff8f82963424e0bb02708a22e44b4980893e3a4be0fa3cb60a43b946764e3\",\"id\":\"236ad3390704e1bf435f40143fb3de163723aeaa8f25c3bf12a0ac4d9a4b56a7\",\"sig\":\"509b8fe51c1e4c4cc55a0b2032b70bfb683f1da6c62e4e5b0da7175eab99b18c67862deaaea80cf31acedb9ad3022ebf54fd0cb6c9d1297a96541848d2035d92\"}","error":null}"#;
        let message = Message::from_json(json).unwrap();
        assert_eq!(
            message,
            Message::response(
                "3047714669",
                Some(ResponseResult::SignEvent(Box::new(event))),
                None
            )
        );

        // Encryption
        let ciphertext = "ArY1I2xC2yDwIbuNHN/1ynXdGgzHLqdCrXUPMwELJPc7s7JqlCMJBAIIjfkpHReBPXeoMCyuClwgbT419jUWU1PwaNl4FEQYKCDKVJz+97Mp3K+Q2YGa77B6gpxB/lr1QgoqpDf7wDVrDmOqGoiPjWDqy8KzLueKDcm9BVP8xeTJIxs=";
        let json = r#"{"id":"3047714669","result":"ArY1I2xC2yDwIbuNHN/1ynXdGgzHLqdCrXUPMwELJPc7s7JqlCMJBAIIjfkpHReBPXeoMCyuClwgbT419jUWU1PwaNl4FEQYKCDKVJz+97Mp3K+Q2YGa77B6gpxB/lr1QgoqpDf7wDVrDmOqGoiPjWDqy8KzLueKDcm9BVP8xeTJIxs=","error":null}"#;
        let message = Message::from_json(json).unwrap();
        assert_eq!(
            message,
            Message::response(
                "3047714669",
                Some(ResponseResult::EncryptionDecryption(ciphertext.to_string())),
                None
            )
        );

        // Decryption
        let plaintext = "Hello world!";
        let json = r#"{"id":"3047714669","result":"Hello world!","error":null}"#;
        let message = Message::from_json(json).unwrap();
        assert_eq!(
            message,
            Message::response(
                "3047714669",
                Some(ResponseResult::EncryptionDecryption(plaintext.to_string())),
                None
            )
        );
    }
}

================
File: src/nips/nip47.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP47: Wallet Connect
//!
//! <https://github.com/nostr-protocol/nips/blob/master/47.md>

use alloc::borrow::Cow;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;
use core::str::FromStr;

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json::Value;

use super::nip04;
use crate::types::url::form_urlencoded::byte_serialize;
use crate::types::url::{self, ParseError, RelayUrl, Url};
use crate::{key, Event, JsonUtil, PublicKey, SecretKey, Timestamp};
#[cfg(feature = "std")]
use crate::{EventBuilder, Keys, Kind, Tag};

/// NIP47 error
#[derive(Debug)]
pub enum Error {
    /// JSON error
    JSON(serde_json::Error),
    /// Relay Url parse error
    RelayUrl(url::Error),
    /// Url parse error
    Url(ParseError),
    /// Keys error
    Keys(key::Error),
    /// NIP04 error
    NIP04(nip04::Error),
    /// Event Builder error
    #[cfg(feature = "std")]
    EventBuilder(crate::event::builder::Error),
    /// Unsigned event error
    UnsignedEvent(crate::event::unsigned::Error),
    /// Error code
    ErrorCode(NIP47Error),
    /// NIP47 Error Code
    UnexpectedResult(String),
    /// Invalid request
    InvalidRequest,
    /// Too many/few params
    InvalidParamsLength,
    /// Unsupported method
    UnsupportedMethod(String),
    /// Invalid URI
    InvalidURI,
    /// Invalid URI scheme
    InvalidURIScheme,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::JSON(e) => write!(f, "Json: {e}"),
            Self::RelayUrl(e) => write!(f, "{e}"),
            Self::Url(e) => write!(f, "{e}"),
            Self::Keys(e) => write!(f, "Keys: {e}"),
            Self::NIP04(e) => write!(f, "NIP04: {e}"),
            #[cfg(feature = "std")]
            Self::EventBuilder(e) => write!(f, "Event Builder: {e}"),
            Self::UnsignedEvent(e) => write!(f, "Unsigned event: {e}"),
            Self::ErrorCode(e) => write!(f, "{e}"),
            Self::UnexpectedResult(json) => write!(f, "Unexpected NIP47 result: {json}"),
            Self::InvalidRequest => write!(f, "Invalid NIP47 Request"),
            Self::InvalidParamsLength => write!(f, "Invalid NIP47 Params length"),
            Self::UnsupportedMethod(e) => write!(f, "Unsupported method: {e}"),
            Self::InvalidURI => write!(f, "Invalid NIP47 URI"),
            Self::InvalidURIScheme => write!(f, "Invalid NIP47 URI Scheme"),
        }
    }
}

impl From<serde_json::Error> for Error {
    fn from(e: serde_json::Error) -> Self {
        Self::JSON(e)
    }
}

impl From<url::Error> for Error {
    fn from(e: url::Error) -> Self {
        Self::RelayUrl(e)
    }
}

impl From<ParseError> for Error {
    fn from(e: ParseError) -> Self {
        Self::Url(e)
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Keys(e)
    }
}

impl From<nip04::Error> for Error {
    fn from(e: nip04::Error) -> Self {
        Self::NIP04(e)
    }
}

#[cfg(feature = "std")]
impl From<crate::event::builder::Error> for Error {
    fn from(e: crate::event::builder::Error) -> Self {
        Self::EventBuilder(e)
    }
}

/// NIP47 Response Error codes
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum ErrorCode {
    ///  The client is sending commands too fast.
    #[serde(rename = "RATE_LIMITED")]
    RateLimited,
    /// The command is not known of is intentionally not implemented
    #[serde(rename = "NOT_IMPLEMENTED")]
    NotImplemented,
    /// The wallet does not have enough funds to cover a fee reserve or the payment amount
    #[serde(rename = "INSUFFICIENT_BALANCE")]
    InsufficientBalance,
    /// The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
    #[serde(rename = "PAYMENT_FAILED")]
    PaymentFailed,
    /// The invoice could not be found by the given parameters.
    #[serde(rename = "NOT_FOUND")]
    NotFound,
    /// The wallet has exceeded its spending quota
    #[serde(rename = "QUOTA_EXCEEDED")]
    QuotaExceeded,
    /// This public key is not allowed to do this operation
    #[serde(rename = "RESTRICTED")]
    Restricted,
    /// This public key has no wallet connected
    #[serde(rename = "UNAUTHORIZED")]
    Unauthorized,
    /// An internal error
    #[serde(rename = "INTERNAL")]
    Internal,
    /// Other error
    #[serde(rename = "OTHER")]
    Other,
}

impl fmt::Display for Method {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Method::PayInvoice => write!(f, "pay_invoice"),
            Method::MultiPayInvoice => write!(f, "multi_pay_invoice"),
            Method::PayKeysend => write!(f, "pay_keysend"),
            Method::MultiPayKeysend => write!(f, "multi_pay_keysend"),
            Method::MakeInvoice => write!(f, "make_invoice"),
            Method::LookupInvoice => write!(f, "lookup_invoice"),
            Method::ListTransactions => write!(f, "list_transactions"),
            Method::GetBalance => write!(f, "get_balance"),
            Method::GetInfo => write!(f, "get_info"),
        }
    }
}

impl FromStr for Method {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "pay_invoice" => Ok(Method::PayInvoice),
            "multi_pay_invoice" => Ok(Method::MultiPayInvoice),
            "pay_keysend" => Ok(Method::PayKeysend),
            "multi_pay_keysend" => Ok(Method::MultiPayKeysend),
            "make_invoice" => Ok(Method::MakeInvoice),
            "lookup_invoice" => Ok(Method::LookupInvoice),
            "list_transactions" => Ok(Method::ListTransactions),
            "get_balance" => Ok(Method::GetBalance),
            "get_info" => Ok(Method::GetInfo),
            _ => Err(Error::InvalidURI),
        }
    }
}

/// NIP47 Error message
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct NIP47Error {
    /// Error Code
    pub code: ErrorCode,
    /// Human Readable error message
    pub message: String,
}

impl fmt::Display for NIP47Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} [{:?}]", self.message, self.code)
    }
}

/// Method
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub enum Method {
    /// Pay Invoice
    #[serde(rename = "pay_invoice")]
    PayInvoice,
    /// Multi Pay Invoice
    #[serde(rename = "multi_pay_invoice")]
    MultiPayInvoice,
    /// Pay Keysend
    #[serde(rename = "pay_keysend")]
    PayKeysend,
    /// Multi Pay Keysend
    #[serde(rename = "multi_pay_keysend")]
    MultiPayKeysend,
    /// Make Invoice
    #[serde(rename = "make_invoice")]
    MakeInvoice,
    /// Lookup Invoice
    #[serde(rename = "lookup_invoice")]
    LookupInvoice,
    /// List transactions
    #[serde(rename = "list_transactions")]
    ListTransactions,
    /// Get Balance
    #[serde(rename = "get_balance")]
    GetBalance,
    /// Get Info
    #[serde(rename = "get_info")]
    GetInfo,
}

/// Nostr Wallet Connect Request
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RequestParams {
    /// Pay Invoice
    PayInvoice(PayInvoiceRequest),
    /// Multiple Pay Invoice
    MultiPayInvoice(MultiPayInvoiceRequest),
    /// Pay Keysend
    PayKeysend(PayKeysendRequest),
    /// Multiple Pay Keysend
    MultiPayKeysend(MultiPayKeysendRequest),
    /// Make Invoice
    MakeInvoice(MakeInvoiceRequest),
    /// Lookup Invoice
    LookupInvoice(LookupInvoiceRequest),
    /// List Transactions
    ListTransactions(ListTransactionsRequest),
    /// Get Balance
    GetBalance,
    /// Get Info
    GetInfo,
}

impl Serialize for RequestParams {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            RequestParams::PayInvoice(p) => p.serialize(serializer),
            RequestParams::MultiPayInvoice(p) => p.serialize(serializer),
            RequestParams::PayKeysend(p) => p.serialize(serializer),
            RequestParams::MultiPayKeysend(p) => p.serialize(serializer),
            RequestParams::MakeInvoice(p) => p.serialize(serializer),
            RequestParams::LookupInvoice(p) => p.serialize(serializer),
            RequestParams::ListTransactions(p) => p.serialize(serializer),
            RequestParams::GetBalance => serializer.serialize_none(),
            RequestParams::GetInfo => serializer.serialize_none(),
        }
    }
}

/// Pay Invoice Request
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct PayInvoiceRequest {
    /// Optional id
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Request invoice
    pub invoice: String,
    /// Optional amount in millisatoshis
    #[serde(skip_serializing_if = "Option::is_none")]
    pub amount: Option<u64>,
}

impl PayInvoiceRequest {
    /// New pay invoice request
    #[inline]
    pub fn new<S>(invoice: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            id: None,
            invoice: invoice.into(),
            amount: None,
        }
    }
}

/// Multiple Pay Invoice Request
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct MultiPayInvoiceRequest {
    /// Requested invoices
    pub invoices: Vec<PayInvoiceRequest>,
}

/// TLVs to be added to the keysend payment
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct KeysendTLVRecord {
    /// TLV type
    #[serde(rename = "type")]
    pub tlv_type: u64,
    /// TLV value
    pub value: String,
}

/// Pay Invoice Request
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct PayKeysendRequest {
    /// Optional id
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// Amount in millisatoshis
    pub amount: u64,
    /// Receiver's node id
    pub pubkey: String,
    /// Optional preimage
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preimage: Option<String>,
    /// Optional TLVs to be added to the keysend payment
    #[serde(default)]
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub tlv_records: Vec<KeysendTLVRecord>,
}

/// Multiple Pay Keysend Request
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct MultiPayKeysendRequest {
    /// Requested keysends
    pub keysends: Vec<PayKeysendRequest>,
}

/// Make Invoice Request
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct MakeInvoiceRequest {
    /// Amount in millisatoshis
    pub amount: u64,
    /// Invoice description
    pub description: Option<String>,
    /// Invoice description hash
    pub description_hash: Option<String>,
    /// Invoice expiry in seconds
    pub expiry: Option<u64>,
}

/// Lookup Invoice Request
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct LookupInvoiceRequest {
    /// Payment hash of invoice
    pub payment_hash: Option<String>,
    /// Bolt11 invoice
    pub invoice: Option<String>,
}

/// Transaction Type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TransactionType {
    /// Incoming payments
    #[serde(rename = "incoming")]
    Incoming,
    /// Outgoing payments
    #[serde(rename = "outgoing")]
    Outgoing,
}

/// List Transactions Request
#[derive(Debug, Clone, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ListTransactionsRequest {
    /// Starting timestamp in seconds since epoch
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from: Option<Timestamp>,
    /// Ending timestamp in seconds since epoch
    #[serde(skip_serializing_if = "Option::is_none")]
    pub until: Option<Timestamp>,
    /// Number of invoices to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<u64>,
    /// Offset of the first invoice to return
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset: Option<u64>,
    /// If true, include unpaid invoices
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unpaid: Option<bool>,
    /// [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transaction_type: Option<TransactionType>,
}

/// NIP47 Request
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize)]
pub struct Request {
    /// Request method
    pub method: Method,
    /// Params
    pub params: RequestParams,
}

#[derive(Serialize, Deserialize)]
struct RequestTemplate {
    /// Request method
    method: Method,
    /// Params
    #[serde(default)] // handle no params as `Value::Null`
    params: Value,
}

impl Request {
    /// Compose `pay_invoice` request
    #[inline]
    pub fn pay_invoice(params: PayInvoiceRequest) -> Self {
        Self {
            method: Method::PayInvoice,
            params: RequestParams::PayInvoice(params),
        }
    }

    /// Compose `multi_pay_invoice` request
    #[inline]
    pub fn multi_pay_invoice(params: MultiPayInvoiceRequest) -> Self {
        Self {
            method: Method::MultiPayInvoice,
            params: RequestParams::MultiPayInvoice(params),
        }
    }

    /// Compose `pay_keysend` request
    #[inline]
    pub fn pay_keysend(params: PayKeysendRequest) -> Self {
        Self {
            method: Method::PayKeysend,
            params: RequestParams::PayKeysend(params),
        }
    }

    /// Compose `make_invoice` request
    #[inline]
    pub fn make_invoice(params: MakeInvoiceRequest) -> Self {
        Self {
            method: Method::MakeInvoice,
            params: RequestParams::MakeInvoice(params),
        }
    }

    /// Compose `lookup_invoice` request
    #[inline]
    pub fn lookup_invoice(params: LookupInvoiceRequest) -> Self {
        Self {
            method: Method::LookupInvoice,
            params: RequestParams::LookupInvoice(params),
        }
    }

    /// Compose `list_transactions` request
    #[inline]
    pub fn list_transactions(params: ListTransactionsRequest) -> Self {
        Self {
            method: Method::ListTransactions,
            params: RequestParams::ListTransactions(params),
        }
    }

    /// Compose `get_balance` request
    #[inline]
    pub fn get_balance() -> Self {
        Self {
            method: Method::GetBalance,
            params: RequestParams::GetBalance,
        }
    }

    /// Compose `get_info` request
    #[inline]
    pub fn get_info() -> Self {
        Self {
            method: Method::GetInfo,
            params: RequestParams::GetInfo,
        }
    }

    /// Deserialize from [`Value`]
    pub fn from_value(value: Value) -> Result<Self, Error> {
        let template: RequestTemplate = serde_json::from_value(value)?;

        let params = match template.method {
            Method::PayInvoice => {
                let params: PayInvoiceRequest = serde_json::from_value(template.params)?;
                RequestParams::PayInvoice(params)
            }
            Method::MultiPayInvoice => {
                let params: MultiPayInvoiceRequest = serde_json::from_value(template.params)?;
                RequestParams::MultiPayInvoice(params)
            }
            Method::PayKeysend => {
                let params: PayKeysendRequest = serde_json::from_value(template.params)?;
                RequestParams::PayKeysend(params)
            }
            Method::MultiPayKeysend => {
                let params: MultiPayKeysendRequest = serde_json::from_value(template.params)?;
                RequestParams::MultiPayKeysend(params)
            }
            Method::MakeInvoice => {
                let params: MakeInvoiceRequest = serde_json::from_value(template.params)?;
                RequestParams::MakeInvoice(params)
            }
            Method::LookupInvoice => {
                let params: LookupInvoiceRequest = serde_json::from_value(template.params)?;
                RequestParams::LookupInvoice(params)
            }
            Method::ListTransactions => {
                let params: ListTransactionsRequest = serde_json::from_value(template.params)?;
                RequestParams::ListTransactions(params)
            }
            Method::GetBalance => RequestParams::GetBalance,
            Method::GetInfo => RequestParams::GetInfo,
        };

        Ok(Self {
            method: template.method,
            params,
        })
    }

    /// Create request [Event]
    #[cfg(feature = "std")]
    pub fn to_event(self, uri: &NostrWalletConnectURI) -> Result<Event, Error> {
        let encrypted = nip04::encrypt(&uri.secret, &uri.public_key, self.as_json())?;
        let keys: Keys = Keys::new(uri.secret.clone());
        Ok(EventBuilder::new(Kind::WalletConnectRequest, encrypted)
            .tag(Tag::public_key(uri.public_key))
            .sign_with_keys(&keys)?)
    }
}

impl JsonUtil for Request {
    type Err = Error;
}

impl<'de> Deserialize<'de> for Request {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value: Value = Value::deserialize(deserializer).map_err(serde::de::Error::custom)?;
        Self::from_value(value).map_err(serde::de::Error::custom)
    }
}

/// NIP47 Response Result
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct PayInvoiceResponse {
    /// Response preimage
    pub preimage: String,
}

/// NIP47 Response Result
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct PayKeysendResponse {
    /// Response preimage
    pub preimage: String,
}

/// Make Invoice Response
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct MakeInvoiceResponse {
    /// Bolt 11 invoice
    pub invoice: String,
    /// Invoice's payment hash
    pub payment_hash: String,
}

/// Lookup Invoice Response
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct LookupInvoiceResponse {
    /// Transaction type
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transaction_type: Option<TransactionType>,
    /// Bolt11 invoice
    #[serde(skip_serializing_if = "Option::is_none")]
    pub invoice: Option<String>,
    /// Invoice's description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Invoice's description hash
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description_hash: Option<String>,
    /// Payment preimage
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preimage: Option<String>,
    /// Payment hash
    pub payment_hash: String,
    /// Amount in millisatoshis
    pub amount: u64,
    /// Fees paid in millisatoshis
    pub fees_paid: u64,
    /// Creation timestamp in seconds since epoch
    pub created_at: Timestamp,
    /// Expiration timestamp in seconds since epoch
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_at: Option<Timestamp>,
    /// Settled timestamp in seconds since epoch
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settled_at: Option<Timestamp>,
    /// Optional metadata about the payment
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Value>,
}

/// Get Balance Response
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct GetBalanceResponse {
    /// Balance amount in msats
    pub balance: u64,
}

/// Get Info Response
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub struct GetInfoResponse {
    /// The alias of the lightning node
    pub alias: String,
    /// The color of the current node in hex code format
    pub color: String,
    /// Lightning Node's public key
    pub pubkey: String,
    /// Active network
    pub network: String,
    /// Current block height
    pub block_height: u32,
    /// Most Recent Block Hash
    pub block_hash: String,
    /// Available methods for this connection
    pub methods: Vec<String>,
}

/// NIP47 Response Result
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ResponseResult {
    /// Pay Invoice
    PayInvoice(PayInvoiceResponse),
    /// Multiple Pay Invoice
    MultiPayInvoice(PayInvoiceResponse),
    /// Pay Keysend
    PayKeysend(PayKeysendResponse),
    /// Multiple Pay Keysend
    MultiPayKeysend(PayKeysendResponse),
    /// Make Invoice
    MakeInvoice(MakeInvoiceResponse),
    /// Lookup Invoice
    LookupInvoice(LookupInvoiceResponse),
    /// List Invoices
    ListTransactions(Vec<LookupInvoiceResponse>),
    /// Get Balance
    GetBalance(GetBalanceResponse),
    /// Get Info
    GetInfo(GetInfoResponse),
}

impl Serialize for ResponseResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            ResponseResult::PayInvoice(p) => p.serialize(serializer),
            ResponseResult::MultiPayInvoice(p) => p.serialize(serializer),
            ResponseResult::PayKeysend(p) => p.serialize(serializer),
            ResponseResult::MultiPayKeysend(p) => p.serialize(serializer),
            ResponseResult::MakeInvoice(p) => p.serialize(serializer),
            ResponseResult::LookupInvoice(p) => p.serialize(serializer),
            ResponseResult::ListTransactions(p) => p.serialize(serializer),
            ResponseResult::GetBalance(p) => p.serialize(serializer),
            ResponseResult::GetInfo(p) => p.serialize(serializer),
        }
    }
}

/// NIP47 Response
#[derive(Debug, Clone, PartialEq, Eq, Serialize)]
pub struct Response {
    /// Request Method
    pub result_type: Method,
    /// NIP47 Error
    pub error: Option<NIP47Error>,
    /// NIP47 Result
    pub result: Option<ResponseResult>,
}

/// NIP47 Response
#[derive(Debug, Clone, Deserialize)]
struct ResponseTemplate {
    /// Request Method
    pub result_type: Method,
    /// NIP47 Error
    pub error: Option<NIP47Error>,
    /// NIP47 Result
    pub result: Option<Value>,
}

impl Response {
    /// Deserialize from [Event]
    #[inline]
    pub fn from_event(uri: &NostrWalletConnectURI, event: &Event) -> Result<Self, Error> {
        let decrypt_res: String = nip04::decrypt(&uri.secret, &event.pubkey, &event.content)?;
        Self::from_json(decrypt_res)
    }

    /// Deserialize from JSON string
    pub fn from_value(value: Value) -> Result<Self, Error> {
        let template: ResponseTemplate = serde_json::from_value(value)?;

        if let Some(result) = template.result {
            let result = match template.result_type {
                Method::PayInvoice => {
                    let result: PayInvoiceResponse = serde_json::from_value(result)?;
                    ResponseResult::PayInvoice(result)
                }
                Method::MultiPayInvoice => {
                    let result: PayInvoiceResponse = serde_json::from_value(result)?;
                    ResponseResult::MultiPayInvoice(result)
                }
                Method::PayKeysend => {
                    let result: PayKeysendResponse = serde_json::from_value(result)?;
                    ResponseResult::PayKeysend(result)
                }
                Method::MultiPayKeysend => {
                    let result: PayKeysendResponse = serde_json::from_value(result)?;
                    ResponseResult::MultiPayKeysend(result)
                }
                Method::MakeInvoice => {
                    let result: MakeInvoiceResponse = serde_json::from_value(result)?;
                    ResponseResult::MakeInvoice(result)
                }
                Method::LookupInvoice => {
                    let result: LookupInvoiceResponse = serde_json::from_value(result)?;
                    ResponseResult::LookupInvoice(result)
                }
                Method::ListTransactions => {
                    let transactions: Value =
                        result.get("transactions").cloned().ok_or_else(|| {
                            Error::UnexpectedResult(String::from("Missing 'transactions' field"))
                        })?;
                    let result: Vec<LookupInvoiceResponse> = serde_json::from_value(transactions)?;
                    ResponseResult::ListTransactions(result)
                }
                Method::GetBalance => {
                    let result: GetBalanceResponse = serde_json::from_value(result)?;
                    ResponseResult::GetBalance(result)
                }
                Method::GetInfo => {
                    let result: GetInfoResponse = serde_json::from_value(result)?;
                    ResponseResult::GetInfo(result)
                }
            };

            Ok(Self {
                result_type: template.result_type,
                error: template.error,
                result: Some(result),
            })
        } else {
            Ok(Self {
                result_type: template.result_type,
                error: template.error,
                result: None,
            })
        }
    }

    /// Covert [Response] to [PayInvoiceResponse]
    pub fn to_pay_invoice(self) -> Result<PayInvoiceResponse, Error> {
        if let Some(e) = self.error {
            return Err(Error::ErrorCode(e));
        }

        if let Some(ResponseResult::PayInvoice(result)) = self.result {
            return Ok(result);
        }

        Err(Error::UnexpectedResult(self.as_json()))
    }

    /// Covert [Response] to [PayKeysendResponse]
    pub fn to_pay_keysend(self) -> Result<PayKeysendResponse, Error> {
        if let Some(e) = self.error {
            return Err(Error::ErrorCode(e));
        }

        if let Some(ResponseResult::PayKeysend(result)) = self.result {
            return Ok(result);
        }

        Err(Error::UnexpectedResult(self.as_json()))
    }

    /// Covert [Response] to [MakeInvoiceResponse]
    pub fn to_make_invoice(self) -> Result<MakeInvoiceResponse, Error> {
        if let Some(e) = self.error {
            return Err(Error::ErrorCode(e));
        }

        if let Some(ResponseResult::MakeInvoice(result)) = self.result {
            return Ok(result);
        }

        Err(Error::UnexpectedResult(self.as_json()))
    }

    /// Covert [Response] to [LookupInvoiceResponse]
    pub fn to_lookup_invoice(self) -> Result<LookupInvoiceResponse, Error> {
        if let Some(e) = self.error {
            return Err(Error::ErrorCode(e));
        }

        if let Some(ResponseResult::LookupInvoice(result)) = self.result {
            return Ok(result);
        }

        Err(Error::UnexpectedResult(self.as_json()))
    }

    /// Covert [Response] to list of [LookupInvoiceResponse]
    pub fn to_list_transactions(self) -> Result<Vec<LookupInvoiceResponse>, Error> {
        if let Some(e) = self.error {
            return Err(Error::ErrorCode(e));
        }

        if let Some(ResponseResult::ListTransactions(result)) = self.result {
            return Ok(result);
        }

        Err(Error::UnexpectedResult(self.as_json()))
    }

    /// Covert [Response] to [GetBalanceResponse]
    pub fn to_get_balance(self) -> Result<GetBalanceResponse, Error> {
        if let Some(e) = self.error {
            return Err(Error::ErrorCode(e));
        }

        if let Some(ResponseResult::GetBalance(result)) = self.result {
            return Ok(result);
        }

        Err(Error::UnexpectedResult(self.as_json()))
    }

    /// Covert [Response] to [GetInfoResponse]
    pub fn to_get_info(self) -> Result<GetInfoResponse, Error> {
        if let Some(e) = self.error {
            return Err(Error::ErrorCode(e));
        }

        if let Some(ResponseResult::GetInfo(result)) = self.result {
            return Ok(result);
        }

        Err(Error::UnexpectedResult(self.as_json()))
    }
}

impl JsonUtil for Response {
    type Err = Error;
}

impl<'de> Deserialize<'de> for Response {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value: Value = Value::deserialize(deserializer).map_err(serde::de::Error::custom)?;
        Self::from_value(value).map_err(serde::de::Error::custom)
    }
}

#[inline]
fn url_encode<T>(data: T) -> String
where
    T: AsRef<[u8]>,
{
    byte_serialize(data.as_ref()).collect()
}

/// NIP47 URI Scheme
pub const NOSTR_WALLET_CONNECT_URI_SCHEME: &str = "nostr+walletconnect";

/// Nostr Connect URI
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct NostrWalletConnectURI {
    /// App Pubkey
    pub public_key: PublicKey,
    /// URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
    pub relay_url: RelayUrl,
    /// 32-byte randomly generated hex encoded string
    pub secret: SecretKey,
    /// A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
    pub lud16: Option<String>,
}

impl NostrWalletConnectURI {
    /// Create new [`NostrWalletConnectURI`]
    #[inline]
    pub fn new(
        public_key: PublicKey,
        relay_url: RelayUrl,
        random_secret_key: SecretKey,
        lud16: Option<String>,
    ) -> Self {
        Self {
            public_key,
            relay_url,
            secret: random_secret_key,
            lud16,
        }
    }

    /// Parse NWC URI
    pub fn parse<S>(uri: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let url: Url = Url::parse(uri.as_ref())?;

        if url.scheme() != NOSTR_WALLET_CONNECT_URI_SCHEME {
            return Err(Error::InvalidURIScheme);
        }

        if let Some(pubkey) = url.domain() {
            let public_key = PublicKey::from_hex(pubkey)?;

            let mut relay_url: Option<RelayUrl> = None;
            let mut secret: Option<SecretKey> = None;
            let mut lud16: Option<String> = None;

            for (key, value) in url.query_pairs() {
                match key {
                    Cow::Borrowed("relay") => {
                        relay_url = Some(RelayUrl::parse(value.as_ref())?);
                    }
                    Cow::Borrowed("secret") => {
                        secret = Some(SecretKey::from_hex(value.as_ref())?);
                    }
                    Cow::Borrowed("lud16") => {
                        lud16 = Some(value.to_string());
                    }
                    _ => (),
                }
            }

            if let (Some(relay_url), Some(secret)) = (relay_url, secret) {
                return Ok(Self {
                    public_key,
                    relay_url,
                    secret,
                    lud16,
                });
            }
        }

        Err(Error::InvalidURI)
    }
}

impl FromStr for NostrWalletConnectURI {
    type Err = Error;

    fn from_str(uri: &str) -> Result<Self, Self::Err> {
        Self::parse(uri)
    }
}

impl fmt::Display for NostrWalletConnectURI {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // trailing slash is removed, this breaks some clients
        let relay_url: &str = self.relay_url.as_str_without_trailing_slash();
        write!(
            f,
            "{NOSTR_WALLET_CONNECT_URI_SCHEME}://{}?relay={}&secret={}",
            self.public_key,
            url_encode(relay_url),
            url_encode(self.secret.to_secret_hex())
        )?;
        if let Some(lud16) = &self.lud16 {
            write!(f, "&lud16={}", url_encode(lud16))?;
        }
        Ok(())
    }
}

impl Serialize for NostrWalletConnectURI {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'a> Deserialize<'a> for NostrWalletConnectURI {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'a>,
    {
        let uri = String::deserialize(deserializer)?;
        NostrWalletConnectURI::from_str(&uri).map_err(serde::de::Error::custom)
    }
}

#[cfg(test)]
mod tests {
    use core::str::FromStr;

    use super::*;

    #[test]
    fn test_uri() {
        let pubkey =
            PublicKey::from_str("b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4")
                .unwrap();
        let relay_url = RelayUrl::parse("wss://relay.damus.io").unwrap();
        let secret =
            SecretKey::from_str("71a8c14c1407c113601079c4302dab36460f0ccd0ad506f1f2dc73b5100e4f3c")
                .unwrap();
        let uri = NostrWalletConnectURI::new(
            pubkey,
            relay_url,
            secret,
            Some("nostr@nostr.com".to_string()),
        );
        assert_eq!(
            uri.to_string(),
            "nostr+walletconnect://b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4?relay=wss%3A%2F%2Frelay.damus.io&secret=71a8c14c1407c113601079c4302dab36460f0ccd0ad506f1f2dc73b5100e4f3c&lud16=nostr%40nostr.com".to_string()
        );
    }

    #[test]
    fn test_parse_uri() {
        let uri = "nostr+walletconnect://b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4?relay=wss%3A%2F%2Frelay.damus.io&secret=71a8c14c1407c113601079c4302dab36460f0ccd0ad506f1f2dc73b5100e4f3c&lud16=nostr%40nostr.com";
        let uri = NostrWalletConnectURI::from_str(uri).unwrap();

        let pubkey =
            PublicKey::from_str("b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4")
                .unwrap();
        let relay_url = RelayUrl::parse("wss://relay.damus.io").unwrap();
        let secret =
            SecretKey::from_str("71a8c14c1407c113601079c4302dab36460f0ccd0ad506f1f2dc73b5100e4f3c")
                .unwrap();
        assert_eq!(
            uri,
            NostrWalletConnectURI::new(
                pubkey,
                relay_url,
                secret,
                Some("nostr@nostr.com".to_string())
            )
        );
    }

    #[test]
    fn serialize_request() {
        let request = Request {
            method: Method::PayInvoice,
            params: RequestParams::PayInvoice(PayInvoiceRequest { id: None, invoice: "lnbc210n1pj99rx0pp5ehevgz9nf7d97h05fgkdeqxzytm6yuxd7048axru03fpzxxvzt7shp5gv7ef0s26pw5gy5dpwvsh6qgc8se8x2lmz2ev90l9vjqzcns6u6scqzzsxqyz5vqsp".to_string(), amount: None }),
        };

        assert_eq!(Request::from_json(request.as_json()).unwrap(), request);

        assert_eq!(request.as_json(), "{\"method\":\"pay_invoice\",\"params\":{\"invoice\":\"lnbc210n1pj99rx0pp5ehevgz9nf7d97h05fgkdeqxzytm6yuxd7048axru03fpzxxvzt7shp5gv7ef0s26pw5gy5dpwvsh6qgc8se8x2lmz2ev90l9vjqzcns6u6scqzzsxqyz5vqsp\"}}");
    }

    #[test]
    fn test_parse_request() {
        let request = "{\"params\":{\"invoice\":\"lnbc210n1pj99rx0pp5ehevgz9nf7d97h05fgkdeqxzytm6yuxd7048axru03fpzxxvzt7shp5gv7ef0s26pw5gy5dpwvsh6qgc8se8x2lmz2ev90l9vjqzcns6u6scqzzsxqyz5vqsp5rdjyt9jr2avv2runy330766avkweqp30ndnyt9x6dp5juzn7q0nq9qyyssq2mykpgu04q0hlga228kx9v95meaqzk8a9cnvya305l4c353u3h04azuh9hsmd503x6jlzjrsqzark5dxx30s46vuatwzjhzmkt3j4tgqu35rms\"},\"method\":\"pay_invoice\"}";

        let request = Request::from_json(request).unwrap();

        assert_eq!(request.method, Method::PayInvoice);

        if let RequestParams::PayInvoice(pay) = request.params {
            assert_eq!(pay.invoice, "lnbc210n1pj99rx0pp5ehevgz9nf7d97h05fgkdeqxzytm6yuxd7048axru03fpzxxvzt7shp5gv7ef0s26pw5gy5dpwvsh6qgc8se8x2lmz2ev90l9vjqzcns6u6scqzzsxqyz5vqsp5rdjyt9jr2avv2runy330766avkweqp30ndnyt9x6dp5juzn7q0nq9qyyssq2mykpgu04q0hlga228kx9v95meaqzk8a9cnvya305l4c353u3h04azuh9hsmd503x6jlzjrsqzark5dxx30s46vuatwzjhzmkt3j4tgqu35rms".to_string());
        } else {
            panic!("Invalid request params");
        }
    }

    #[test]
    fn test_parse_list_transactions_result() {
        let json = r#"{
            "result_type": "list_transactions",
            "result": {
                "transactions": [
                    {
                       "type": "incoming",
                       "invoice": "abcd",
                       "description": "string",
                       "payment_hash": "",
                       "amount": 123,
                       "fees_paid": 1,
                       "created_at": 123456,
                       "expires_at": 1234567
                   }
                ]
            }
        }"#;
        let result = Response::from_json(json).unwrap();
        assert_eq!(result.result_type, Method::ListTransactions);
        assert!(result.error.is_none());
        assert_eq!(
            result.result,
            Some(ResponseResult::ListTransactions(vec![
                LookupInvoiceResponse {
                    transaction_type: Some(TransactionType::Incoming),
                    invoice: Some(String::from("abcd")),
                    description: Some(String::from("string")),
                    amount: 123,
                    fees_paid: 1,
                    created_at: Timestamp::from(123456),
                    expires_at: Some(Timestamp::from(1234567)),
                    description_hash: None,
                    payment_hash: String::new(),
                    metadata: None,
                    settled_at: None,
                    preimage: None
                }
            ]))
        )
    }
}

================
File: src/nips/nip48.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP48: Proxy Tags
//!
//! <https://github.com/nostr-protocol/nips/blob/master/48.md>

use alloc::string::{String, ToString};
use core::fmt;

/// NIP48 Proxy Protocol
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Protocol {
    /// ActivityPub
    ActivityPub,
    /// AT Protocol
    ATProto,
    /// Rss
    Rss,
    /// Web
    Web,
    /// Custom
    Custom(String),
}

impl fmt::Display for Protocol {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::ActivityPub => write!(f, "activitypub"),
            Self::ATProto => write!(f, "atproto"),
            Self::Rss => write!(f, "rss"),
            Self::Web => write!(f, "web"),
            Self::Custom(m) => write!(f, "{m}"),
        }
    }
}

impl<S> From<S> for Protocol
where
    S: AsRef<str>,
{
    fn from(s: S) -> Self {
        match s.as_ref() {
            "activitypub" => Self::ActivityPub,
            "atproto" => Self::ATProto,
            "rss" => Self::Rss,
            "web" => Self::Web,
            s => Self::Custom(s.to_string()),
        }
    }
}

================
File: src/nips/nip49.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP49: Private Key Encryption
//!
//! <https://github.com/nostr-protocol/nips/blob/master/49.md>

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::array::TryFromSliceError;
use core::fmt;

#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::{CryptoRng, RngCore};
use chacha20poly1305::aead::{Aead, AeadCore, KeyInit, Payload};
use chacha20poly1305::XChaCha20Poly1305;
use scrypt::errors::{InvalidOutputLen, InvalidParams};
use scrypt::Params as ScryptParams;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use unicode_normalization::UnicodeNormalization;

use super::nip19::{FromBech32, ToBech32};
use crate::{key, SecretKey};

const SALT_SIZE: usize = 16;
const NONCE_SIZE: usize = 24;
const CIPHERTEXT_SIZE: usize = 48;
const KEY_SIZE: usize = 32;

/// NIP49 error
#[derive(Debug, Eq, PartialEq)]
pub enum Error {
    /// Try from slice
    TryFromSlice(String),
    /// ChaCha20Poly1305 error
    ChaCha20Poly1305(chacha20poly1305::Error),
    /// Invalid scrypt params
    InvalidScryptParams(InvalidParams),
    /// Invalid scrypt output len
    InvalidScryptOutputLen(InvalidOutputLen),
    /// Keys error
    Keys(key::Error),
    /// Invalid len
    InvalidLength {
        /// Expected bytes len
        expected: usize,
        /// Found bytes len
        found: usize,
    },
    /// Unsupported version
    UnsupportedVersion(u8),
    /// Unknown version
    UnknownVersion(u8),
    /// Unknown Key Security
    UnknownKeySecurity(u8),
    /// Version not found
    VersionNotFound,
    /// Log2 round not found
    Log2RoundNotFound,
    /// Salt not found
    SaltNotFound,
    /// Nonce not found
    NonceNotFound,
    /// Key security not found
    KeySecurityNotFound,
    /// Cipthertext not found
    CipherTextNotFound,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::TryFromSlice(e) => write!(f, "{e}"),
            Self::ChaCha20Poly1305(e) => write!(f, "ChaCha20Poly1305: {e}"),
            Self::InvalidScryptParams(e) => write!(f, "Invalid scrypt params: {e}"),
            Self::InvalidScryptOutputLen(e) => write!(f, "Invalid scrypt output len: {e}"),
            Self::Keys(e) => write!(f, "Keys: {e}"),
            Self::InvalidLength { expected, found } => write!(
                f,
                "Invalid encrypted secret key bytes len: expected={expected}, found={found}"
            ),
            Self::UnsupportedVersion(v) => write!(
                f,
                "Unsupported encrypted secret key version: {v} (deprecated)"
            ),
            Self::UnknownVersion(v) => write!(f, "Unknown encrypted secret key version: {v}"),
            Self::UnknownKeySecurity(v) => write!(f, "Unknown encrypted secret key security: {v}"),
            Self::VersionNotFound => write!(f, "Encrypted secret key version not found"),
            Self::Log2RoundNotFound => write!(f, "Encrypted secret key `log N` not found"),
            Self::SaltNotFound => write!(f, "Encrypted secret key salt not found"),
            Self::NonceNotFound => write!(f, "Encrypted secret key nonce not found"),
            Self::KeySecurityNotFound => write!(f, "Encrypted secret key security not found"),
            Self::CipherTextNotFound => write!(f, "Encrypted secret key ciphertext not found"),
        }
    }
}

impl From<TryFromSliceError> for Error {
    fn from(e: TryFromSliceError) -> Self {
        Self::TryFromSlice(e.to_string())
    }
}

impl From<chacha20poly1305::Error> for Error {
    fn from(e: chacha20poly1305::Error) -> Self {
        Self::ChaCha20Poly1305(e)
    }
}

impl From<InvalidParams> for Error {
    fn from(e: InvalidParams) -> Self {
        Self::InvalidScryptParams(e)
    }
}

impl From<InvalidOutputLen> for Error {
    fn from(e: InvalidOutputLen) -> Self {
        Self::InvalidScryptOutputLen(e)
    }
}

impl From<key::Error> for Error {
    fn from(e: key::Error) -> Self {
        Self::Keys(e)
    }
}

/// Encrypted Secret Key version (NIP49)
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Version {
    /// V2
    #[default]
    V2 = 0x02,
}

impl TryFrom<u8> for Version {
    type Error = Error;

    fn try_from(version: u8) -> Result<Self, Self::Error> {
        match version {
            0x01 => Err(Error::UnsupportedVersion(version)),
            0x02 => Ok(Self::V2),
            v => Err(Error::UnknownVersion(v)),
        }
    }
}

/// Key security
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum KeySecurity {
    /// The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
    Weak = 0x00,
    /// The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
    Medium = 0x01,
    /// The client does not track this data
    #[default]
    Unknown = 0x02,
}

impl TryFrom<u8> for KeySecurity {
    type Error = Error;

    fn try_from(key_security: u8) -> Result<Self, Self::Error> {
        match key_security {
            0x00 => Ok(Self::Weak),
            0x01 => Ok(Self::Medium),
            0x02 => Ok(Self::Unknown),
            v => Err(Error::UnknownKeySecurity(v)),
        }
    }
}

/// Encrypted Secret Key
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct EncryptedSecretKey {
    version: Version,
    log_n: u8,
    salt: [u8; SALT_SIZE],
    nonce: [u8; NONCE_SIZE],
    key_security: KeySecurity,
    ciphertext: [u8; CIPHERTEXT_SIZE],
}

impl EncryptedSecretKey {
    /// Encrypted Secret Key len
    pub const LEN: usize = 1 + 1 + SALT_SIZE + NONCE_SIZE + 1 + CIPHERTEXT_SIZE; // 91;

    /// Encrypt [SecretKey]
    #[inline]
    #[cfg(feature = "std")]
    pub fn new<S>(
        secret_key: &SecretKey,
        password: S,
        log_n: u8,
        key_security: KeySecurity,
    ) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        Self::new_with_rng(&mut OsRng, secret_key, password, log_n, key_security)
    }

    /// Encrypt [SecretKey]
    pub fn new_with_rng<R, S>(
        rng: &mut R,
        secret_key: &SecretKey,
        password: S,
        log_n: u8,
        key_security: KeySecurity,
    ) -> Result<Self, Error>
    where
        R: RngCore + CryptoRng,
        S: AsRef<str>,
    {
        // Generate salt
        let salt: [u8; SALT_SIZE] = {
            let mut salt: [u8; SALT_SIZE] = [0u8; SALT_SIZE];
            rng.fill_bytes(&mut salt);
            salt
        };

        // Generate nonce
        let nonce = XChaCha20Poly1305::generate_nonce(rng);

        // Derive key
        let key: [u8; KEY_SIZE] = derive_key(password, &salt, log_n)?;

        // Compose cipher
        let cipher = XChaCha20Poly1305::new(&key.into());

        // Compose payload
        let payload = Payload {
            msg: &secret_key.to_secret_bytes(),
            aad: &[key_security as u8],
        };

        // Encrypt
        let ciphertext: Vec<u8> = cipher.encrypt(&nonce, payload)?;
        let ciphertext: [u8; CIPHERTEXT_SIZE] = ciphertext.as_slice().try_into()?;

        Ok(Self {
            version: Version::default(),
            log_n,
            salt,
            nonce: nonce.into(),
            key_security,
            ciphertext,
        })
    }

    /// Parse encrypted secret key from bytes
    pub fn from_slice(slice: &[u8]) -> Result<Self, Error> {
        if slice.len() != Self::LEN {
            return Err(Error::InvalidLength {
                expected: Self::LEN,
                found: slice.len(),
            });
        }

        // Version
        let version: u8 = slice.first().copied().ok_or(Error::VersionNotFound)?;
        let version: Version = Version::try_from(version)?;

        // Log 2 rounds
        let log_n: u8 = slice.get(1).copied().ok_or(Error::Log2RoundNotFound)?;

        // Salt
        let salt: &[u8] = slice.get(2..2 + SALT_SIZE).ok_or(Error::SaltNotFound)?;
        let salt: [u8; SALT_SIZE] = salt.try_into()?;

        // Nonce
        let nonce: &[u8] = slice
            .get(2 + SALT_SIZE..2 + SALT_SIZE + NONCE_SIZE)
            .ok_or(Error::NonceNotFound)?;
        let nonce: [u8; NONCE_SIZE] = nonce.try_into()?;

        // Key security
        let key_security: u8 = slice
            .get(2 + SALT_SIZE + NONCE_SIZE)
            .copied()
            .ok_or(Error::KeySecurityNotFound)?;
        let key_security: KeySecurity = KeySecurity::try_from(key_security)?;

        // Ciphertext
        let ciphertext: &[u8] = slice
            .get(2 + SALT_SIZE + NONCE_SIZE + 1..)
            .ok_or(Error::CipherTextNotFound)?;
        let ciphertext: [u8; CIPHERTEXT_SIZE] = ciphertext.try_into()?;

        Ok(Self {
            version,
            log_n,
            salt,
            nonce,
            key_security,
            ciphertext,
        })
    }

    /// Get encrypted secret key as bytes
    pub fn as_vec(&self) -> Vec<u8> {
        let mut bytes: Vec<u8> = Vec::with_capacity(Self::LEN);
        bytes.push(self.version as u8);
        bytes.push(self.log_n);
        bytes.extend_from_slice(&self.salt);
        bytes.extend_from_slice(&self.nonce);
        bytes.push(self.key_security as u8);
        bytes.extend_from_slice(&self.ciphertext);
        bytes
    }

    /// Get encrypted secret key version
    #[inline]
    pub fn version(&self) -> Version {
        self.version
    }

    /// Get encryption log_n value
    #[inline]
    pub fn log_n(&self) -> u8 {
        self.log_n
    }

    /// Get encrypted secret key security
    #[inline]
    pub fn key_security(&self) -> KeySecurity {
        self.key_security
    }

    /// Decrypt secret key
    pub fn to_secret_key<S>(self, password: S) -> Result<SecretKey, Error>
    where
        S: AsRef<str>,
    {
        // Derive key
        let key: [u8; KEY_SIZE] = derive_key(password, &self.salt, self.log_n)?;

        // Compose cipher
        let cipher = XChaCha20Poly1305::new(&key.into());

        // Compose payload
        let payload = Payload {
            msg: &self.ciphertext,
            aad: &[self.key_security as u8],
        };

        // Decrypt
        let bytes: Vec<u8> = cipher.decrypt(&self.nonce.into(), payload)?;

        Ok(SecretKey::from_slice(&bytes)?)
    }
}

impl Serialize for EncryptedSecretKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let cryptsec: String = self.to_bech32().map_err(serde::ser::Error::custom)?;
        serializer.serialize_str(&cryptsec)
    }
}

impl<'de> Deserialize<'de> for EncryptedSecretKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let cryptsec: String = String::deserialize(deserializer)?;
        Self::from_bech32(cryptsec).map_err(serde::de::Error::custom)
    }
}

fn derive_key<S>(password: S, salt: &[u8; SALT_SIZE], log_n: u8) -> Result<[u8; KEY_SIZE], Error>
where
    S: AsRef<str>,
{
    // Unicode Normalization
    let password: &str = password.as_ref();
    let password: String = password.nfkc().collect();

    // Compose params
    let params: ScryptParams = ScryptParams::new(log_n, 8, 1, KEY_SIZE)?;

    // Derive key
    let mut key: [u8; KEY_SIZE] = [0u8; KEY_SIZE];
    scrypt::scrypt(password.as_bytes(), salt, &params, &mut key)?;
    Ok(key)
}

#[cfg(test)]
mod tests {
    use super::*;

    const CRYPTSEC: &str = "ncryptsec1qgg9947rlpvqu76pj5ecreduf9jxhselq2nae2kghhvd5g7dgjtcxfqtd67p9m0w57lspw8gsq6yphnm8623nsl8xn9j4jdzz84zm3frztj3z7s35vpzmqf6ksu8r89qk5z2zxfmu5gv8th8wclt0h4p";
    const SECRET_KEY: &str = "3501454135014541350145413501453fefb02227e449e57cf4d3a3ce05378683";

    #[test]
    fn test_encrypted_secret_key_decryption() {
        let encrypted_secret_key = EncryptedSecretKey::from_bech32(CRYPTSEC).unwrap();
        let secret_key: SecretKey = encrypted_secret_key.to_secret_key("nostr").unwrap();
        assert_eq!(secret_key.to_secret_hex(), SECRET_KEY)
    }

    #[test]
    fn test_encrypted_secret_key_serialization() {
        let encrypted_secret_key = EncryptedSecretKey::from_bech32(CRYPTSEC).unwrap();
        assert_eq!(encrypted_secret_key.to_bech32().unwrap(), CRYPTSEC)
    }

    #[test]
    #[cfg(feature = "std")]
    fn test_encrypted_secret_key_encryption_decryption() {
        let original_secret_key = SecretKey::from_hex(SECRET_KEY).unwrap();
        let encrypted_secret_key =
            EncryptedSecretKey::new(&original_secret_key, "test", 16, KeySecurity::Medium).unwrap();
        let secret_key: SecretKey = encrypted_secret_key.to_secret_key("test").unwrap();
        assert_eq!(original_secret_key, secret_key);
        assert_eq!(encrypted_secret_key.version(), Version::default());
        assert_eq!(encrypted_secret_key.key_security(), KeySecurity::Medium);
    }
}

================
File: src/nips/nip51.rs
================
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP51: Lists
//!
//! <https://github.com/nostr-protocol/nips/blob/master/51.md>

use alloc::string::String;
use alloc::vec::Vec;

use super::nip01::Coordinate;
use crate::{EventId, PublicKey, Tag, TagStandard, Url};

/// Things the user doesn't want to see in their feeds
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MuteList {
    /// Public Keys
    pub public_keys: Vec<PublicKey>,
    /// Hashtags
    pub hashtags: Vec<String>,
    /// Event IDs
    pub event_ids: Vec<EventId>,
    /// Words
    pub words: Vec<String>,
}

impl From<MuteList> for Vec<Tag> {
    fn from(
        MuteList {
            public_keys,
            hashtags,
            event_ids,
            words,
        }: MuteList,
    ) -> Self {
        let mut tags =
            Vec::with_capacity(public_keys.len() + hashtags.len() + event_ids.len() + words.len());

        tags.extend(public_keys.into_iter().map(Tag::public_key));
        tags.extend(hashtags.into_iter().map(Tag::hashtag));
        tags.extend(event_ids.into_iter().map(Tag::event));
        tags.extend(
            words
                .into_iter()
                .map(TagStandard::Word)
                .map(Tag::from_standardized),
        );

        tags
    }
}

/// Uncategorized, "global" list of things a user wants to save
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Bookmarks {
    /// Event IDs
    pub event_ids: Vec<EventId>,
    /// Coordinates
    pub coordinate: Vec<Coordinate>,
    /// Hashtags
    pub hashtags: Vec<String>,
    /// Urls
    pub urls: Vec<Url>,
}

impl From<Bookmarks> for Vec<Tag> {
    fn from(
        Bookmarks {
            event_ids,
            coordinate,
            hashtags,
            urls,
        }: Bookmarks,
    ) -> Self {
        let mut tags =
            Vec::with_capacity(event_ids.len() + coordinate.len() + hashtags.len() + urls.len());

        tags.extend(event_ids.into_iter().map(Tag::event));
        tags.extend(coordinate.into_iter().map(Tag::from));
        tags.extend(hashtags.into_iter().map(Tag::hashtag));
        tags.extend(
            urls.into_iter()
                .map(TagStandard::Url)
                .map(Tag::from_standardized),
        );

        tags
    }
}

/// Topics a user may be interested in and pointers
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Interests {
    /// Hashtags
    pub hashtags: Vec<String>,
    /// Coordinates
    pub coordinate: Vec<Coordinate>,
}

impl From<Interests> for Vec<Tag> {
    fn from(
        Interests {
            hashtags,
            coordinate,
        }: Interests,
    ) -> Self {
        let mut tags = Vec::with_capacity(hashtags.len() + coordinate.len());

        tags.extend(hashtags.into_iter().map(Tag::hashtag));
        tags.extend(coordinate.into_iter().map(Tag::from));

        tags
    }
}

/// User preferred emojis and pointers to emoji sets
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Emojis {
    /// Emojis
    pub emojis: Vec<(String, Url)>,
    /// Coordinates
    pub coordinate: Vec<Coordinate>,
}

impl From<Emojis> for Vec<Tag> {
    fn from(Emojis { emojis, coordinate }: Emojis) -> Self {
        let mut tags = Vec::with_capacity(emojis.len() + coordinate.len());

        tags.extend(emojis.into_iter().map(|(s, url)| {
            Tag::from_standardized_without_cell(TagStandard::Emoji { shortcode: s, url })
        }));
        tags.extend(coordinate.into_iter().map(Tag::from));

        tags
    }
}

/// Groups of articles picked by users as interesting and/or belonging to the same category
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ArticlesCuration {
    /// Coordinates
    pub coordinate: Vec<Coordinate>,
    /// Event IDs
    pub event_ids: Vec<EventId>,
}

impl From<ArticlesCuration> for Vec<Tag> {
    fn from(
        ArticlesCuration {
            coordinate,
            event_ids,
        }: ArticlesCuration,
    ) -> Self {
        let mut tags = Vec::with_capacity(coordinate.len() + event_ids.len());

        tags.extend(coordinate.into_iter().map(Tag::from));
        tags.extend(event_ids.into_iter().map(Tag::event));

        tags
    }
}

================
File: src/nips/nip53.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP53: Live Activities
//!
//! <https://github.com/nostr-protocol/nips/blob/master/53.md>

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;
use core::str::FromStr;

use bitcoin::secp256k1::schnorr::Signature;

use crate::types::{RelayUrl, Url};
use crate::{
    Alphabet, ImageDimensions, PublicKey, SingleLetterTag, Tag, TagKind, TagStandard, Timestamp,
};

/// NIP53 Error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Unknown [`LiveEventMarker`]
    UnknownLiveEventMarker(String),
    /// Description missing from event
    DescriptionMissing,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::UnknownLiveEventMarker(u) => write!(f, "Unknown live event marker: {u}"),
            Self::DescriptionMissing => write!(f, "Event missing a description"),
        }
    }
}

/// Live Event Marker
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum LiveEventMarker {
    /// Host
    Host,
    /// Speaker
    Speaker,
    /// Participant
    Participant,
}

impl fmt::Display for LiveEventMarker {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Host => write!(f, "Host"),
            Self::Speaker => write!(f, "Speaker"),
            Self::Participant => write!(f, "Participant"),
        }
    }
}

impl FromStr for LiveEventMarker {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Host" => Ok(Self::Host),
            "Speaker" => Ok(Self::Speaker),
            "Participant" => Ok(Self::Participant),
            s => Err(Error::UnknownLiveEventMarker(s.to_string())),
        }
    }
}

/// Live Event Status
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum LiveEventStatus {
    /// Planned
    Planned,
    /// Live
    Live,
    /// Ended
    Ended,
    /// Custom
    Custom(String),
}

impl fmt::Display for LiveEventStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Planned => write!(f, "planned"),
            Self::Live => write!(f, "live"),
            Self::Ended => write!(f, "ended"),
            Self::Custom(s) => write!(f, "{s}"),
        }
    }
}

impl<S> From<S> for LiveEventStatus
where
    S: Into<String>,
{
    fn from(s: S) -> Self {
        let s: String = s.into();
        match s.as_str() {
            "planned" => Self::Planned,
            "live" => Self::Live,
            "ended" => Self::Ended,
            _ => Self::Custom(s),
        }
    }
}

/// Live Event Host
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LiveEventHost {
    /// Host public key
    pub public_key: PublicKey,
    /// Host relay URL
    pub relay_url: Option<RelayUrl>,
    /// Host proof
    pub proof: Option<Signature>,
}

/// Live Event
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LiveEvent {
    /// Unique event ID
    pub id: String,
    /// Event title
    pub title: Option<String>,
    /// Event summary
    pub summary: Option<String>,
    /// Event image
    pub image: Option<(Url, Option<ImageDimensions>)>,
    /// Hashtags
    pub hashtags: Vec<String>,
    /// Steaming URL
    pub streaming: Option<Url>,
    /// Recording URL
    pub recording: Option<Url>,
    /// Starts at
    pub starts: Option<Timestamp>,
    /// Ends at
    pub ends: Option<Timestamp>,
    /// Current status
    pub status: Option<LiveEventStatus>,
    /// Current participants
    pub current_participants: Option<u64>,
    /// Total participants
    pub total_participants: Option<u64>,
    /// Relays
    pub relays: Vec<Url>,
    /// Host
    pub host: Option<LiveEventHost>,
    /// Speakers
    pub speakers: Vec<(PublicKey, Option<RelayUrl>)>,
    /// Participants
    pub participants: Vec<(PublicKey, Option<RelayUrl>)>,
}

impl LiveEvent {
    /// Create a new LiveEvent
    pub fn new<S>(id: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            id: id.into(),
            title: None,
            summary: None,
            image: None,
            hashtags: Vec::new(),
            streaming: None,
            recording: None,
            starts: None,
            ends: None,
            status: None,
            current_participants: None,
            total_participants: None,
            relays: Vec::new(),
            host: None,
            speakers: Vec::new(),
            participants: Vec::new(),
        }
    }
}

impl From<LiveEvent> for Vec<Tag> {
    fn from(live_event: LiveEvent) -> Self {
        let LiveEvent {
            id,
            title,
            summary,
            image,
            hashtags,
            streaming,
            recording,
            starts,
            ends,
            status,
            current_participants,
            total_participants,
            relays,
            host,
            speakers,
            participants,
        } = live_event;

        let mut tags = Vec::with_capacity(1);

        tags.push(Tag::identifier(id));

        if let Some(title) = title {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Title(
                title,
            )));
        }

        if let Some(summary) = summary {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Summary(
                summary,
            )));
        }

        if let Some(streaming) = streaming {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Streaming(
                streaming,
            )));
        }

        if let Some(status) = status {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::LiveEventStatus(status),
            ));
        }

        if let Some(LiveEventHost {
            public_key,
            relay_url,
            proof,
        }) = host
        {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::PublicKeyLiveEvent {
                    public_key,
                    relay_url,
                    marker: LiveEventMarker::Host,
                    proof,
                },
            ));
        }

        for (public_key, relay_url) in speakers.into_iter() {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::PublicKeyLiveEvent {
                    public_key,
                    relay_url,
                    marker: LiveEventMarker::Speaker,
                    proof: None,
                },
            ));
        }

        for (public_key, relay_url) in participants.into_iter() {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::PublicKeyLiveEvent {
                    public_key,
                    relay_url,
                    marker: LiveEventMarker::Participant,
                    proof: None,
                },
            ));
        }

        if let Some((image, dim)) = image {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Image(
                image, dim,
            )));
        }

        for hashtag in hashtags.into_iter() {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Hashtag(
                hashtag,
            )));
        }

        if let Some(recording) = recording {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Recording(
                recording,
            )));
        }

        if let Some(starts) = starts {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Starts(
                starts,
            )));
        }

        if let Some(ends) = ends {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Ends(ends)));
        }

        if let Some(current_participants) = current_participants {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::CurrentParticipants(current_participants),
            ));
        }

        if let Some(total_participants) = total_participants {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::TotalParticipants(total_participants),
            ));
        }

        if !relays.is_empty() {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Relays(
                relays,
            )));
        }

        tags
    }
}

impl TryFrom<Vec<Tag>> for LiveEvent {
    type Error = Error;

    fn try_from(tags: Vec<Tag>) -> Result<Self, Self::Error> {
        // Extract content of `d` tag
        let id: &str = tags
            .iter()
            .find(|t| t.kind() == TagKind::SingleLetter(SingleLetterTag::lowercase(Alphabet::D)))
            .and_then(|t| t.content())
            .ok_or(Error::DescriptionMissing)?;

        let mut live_event = LiveEvent::new(id);

        for tag in tags.into_iter() {
            let Some(tag) = tag.to_standardized() else {
                continue;
            };

            match tag {
                TagStandard::Title(title) => live_event.title = Some(title),
                TagStandard::Summary(summary) => live_event.summary = Some(summary),
                TagStandard::Streaming(url) => live_event.streaming = Some(url),
                TagStandard::LiveEventStatus(status) => live_event.status = Some(status),
                TagStandard::PublicKeyLiveEvent {
                    public_key,
                    relay_url,
                    marker,
                    proof,
                } => match marker {
                    LiveEventMarker::Host => {
                        live_event.host = Some(LiveEventHost {
                            public_key,
                            relay_url,
                            proof,
                        })
                    }
                    LiveEventMarker::Speaker => live_event.speakers.push((public_key, relay_url)),
                    LiveEventMarker::Participant => {
                        live_event.participants.push((public_key, relay_url))
                    }
                },
                TagStandard::Image(image, dim) => live_event.image = Some((image, dim)),
                TagStandard::Hashtag(hashtag) => live_event.hashtags.push(hashtag),
                TagStandard::Recording(url) => live_event.recording = Some(url),
                TagStandard::Starts(starts) => live_event.starts = Some(starts),
                TagStandard::Ends(ends) => live_event.ends = Some(ends),
                TagStandard::CurrentParticipants(n) => live_event.current_participants = Some(n),
                TagStandard::TotalParticipants(n) => live_event.total_participants = Some(n),
                TagStandard::Relays(mut relays) => live_event.relays.append(&mut relays),
                _ => {}
            }
        }

        Ok(live_event)
    }
}

================
File: src/nips/nip56.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP56: Reporting
//!
//! <https://github.com/nostr-protocol/nips/blob/master/56.md>

use core::fmt;
use core::str::FromStr;

/// NIP56 error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Unknown [`Report`]
    UnknownReportType,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::UnknownReportType => write!(f, "Unknown report type"),
        }
    }
}

/// Report
///
/// <https://github.com/nostr-protocol/nips/blob/master/56.md>
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Report {
    /// Depictions of nudity, porn, etc
    Nudity,
    /// Virus, trojan horse, worm, robot, spyware, adware, back door, ransomware, rootkit, kidnapper, etc.
    Malware,
    /// Profanity, hateful speech, etc.
    Profanity,
    /// Something which may be illegal in some jurisdiction
    Illegal,
    /// Spam
    Spam,
    /// Someone pretending to be someone else
    Impersonation,
    ///  Reports that don't fit in the above categories
    Other,
}

impl fmt::Display for Report {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Nudity => write!(f, "nudity"),
            Self::Malware => write!(f, "malware"),
            Self::Profanity => write!(f, "profanity"),
            Self::Illegal => write!(f, "illegal"),
            Self::Spam => write!(f, "spam"),
            Self::Impersonation => write!(f, "impersonation"),
            Self::Other => write!(f, "other"),
        }
    }
}

impl FromStr for Report {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "nudity" => Ok(Self::Nudity),
            "malware" => Ok(Self::Malware),
            "profanity" => Ok(Self::Profanity),
            "illegal" => Ok(Self::Illegal),
            "spam" => Ok(Self::Spam),
            "impersonation" => Ok(Self::Impersonation),
            "other" => Ok(Self::Other),
            _ => Err(Error::UnknownReportType),
        }
    }
}

================
File: src/nips/nip57.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP57: Lightning Zaps
//!
//! <https://github.com/nostr-protocol/nips/blob/master/57.md>

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;

use aes::cipher::block_padding::Pkcs7;
use aes::cipher::{BlockDecryptMut, BlockEncryptMut, KeyIvInit};
use aes::Aes256;
use bech32::{Bech32, Hrp};
use bitcoin::hashes::sha256::Hash as Sha256Hash;
use bitcoin::hashes::Hash;
#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::{CryptoRng, RngCore};
use bitcoin::secp256k1::{self, Secp256k1, Signing, Verification};
use cbc::{Decryptor, Encryptor};

use super::nip01::Coordinate;
use crate::event::builder::Error as BuilderError;
use crate::key::Error as KeyError;
#[cfg(feature = "std")]
use crate::types::time::Instant;
use crate::types::time::TimeSupplier;
#[cfg(feature = "std")]
use crate::SECP256K1;
use crate::{
    event, util, Event, EventBuilder, EventId, JsonUtil, Keys, Kind, PublicKey, SecretKey, Tag,
    TagStandard, Timestamp, Url,
};

type Aes256CbcEnc = Encryptor<Aes256>;
type Aes256CbcDec = Decryptor<Aes256>;

const PRIVATE_ZAP_MSG_BECH32_PREFIX: Hrp = Hrp::parse_unchecked("pzap");
const PRIVATE_ZAP_IV_BECH32_PREFIX: Hrp = Hrp::parse_unchecked("iv");

#[allow(missing_docs)]
#[derive(Debug)]
pub enum Error {
    Fmt(fmt::Error),
    Key(KeyError),
    Builder(BuilderError),
    Event(event::Error),
    Bech32Decode(bech32::DecodeError),
    Bech32Encode(bech32::EncodeError),
    Secp256k1(secp256k1::Error),
    InvalidPrivateZapMessage,
    PrivateZapMessageNotFound,
    /// Wrong prefix or variant
    WrongBech32PrefixOrVariant,
    /// Wrong encryption block mode
    WrongBlockMode,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Fmt(e) => write!(f, "{e}"),
            Self::Key(e) => write!(f, "{e}"),
            Self::Builder(e) => write!(f, "{e}"),
            Self::Event(e) => write!(f, "{e}"),
            Self::Bech32Decode(e) => write!(f, "{e}"),
            Self::Bech32Encode(e) => write!(f, "{e}"),
            Self::Secp256k1(e) => write!(f, "{e}"),
            Self::InvalidPrivateZapMessage => write!(f, "Invalid private zap message"),
            Self::PrivateZapMessageNotFound => write!(f, "Private zap message not found"),
            Self::WrongBech32PrefixOrVariant => write!(f, "Wrong bech32 prefix or variant"),
            Self::WrongBlockMode => write!(
                f,
                "Wrong encryption block mode. The content must be encrypted using CBC mode!"
            ),
        }
    }
}

impl From<fmt::Error> for Error {
    fn from(e: fmt::Error) -> Self {
        Self::Fmt(e)
    }
}

impl From<KeyError> for Error {
    fn from(e: KeyError) -> Self {
        Self::Key(e)
    }
}

impl From<BuilderError> for Error {
    fn from(e: BuilderError) -> Self {
        Self::Builder(e)
    }
}

impl From<event::Error> for Error {
    fn from(e: event::Error) -> Self {
        Self::Event(e)
    }
}

impl From<bech32::DecodeError> for Error {
    fn from(e: bech32::DecodeError) -> Self {
        Self::Bech32Decode(e)
    }
}

impl From<bech32::EncodeError> for Error {
    fn from(e: bech32::EncodeError) -> Self {
        Self::Bech32Encode(e)
    }
}

impl From<secp256k1::Error> for Error {
    fn from(e: secp256k1::Error) -> Self {
        Self::Secp256k1(e)
    }
}

/// Zap Type
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum ZapType {
    /// Public
    Public,
    /// Private
    Private,
    /// Anonymous
    Anonymous,
}

/// Zap Request Data
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ZapRequestData {
    /// Public key of the recipient
    pub public_key: PublicKey,
    /// List of relays the recipient's wallet should publish its zap receipt to
    pub relays: Vec<Url>,
    /// Message
    pub message: String,
    /// Amount in `millisats` the sender intends to pay
    pub amount: Option<u64>,
    /// Lnurl pay url of the recipient, encoded using bech32 with the prefix lnurl.
    pub lnurl: Option<String>,
    /// Event ID
    pub event_id: Option<EventId>,
    /// NIP33 event coordinate that allows tipping parameterized replaceable events such as NIP23 long-form notes.
    pub event_coordinate: Option<Coordinate>,
}

impl ZapRequestData {
    /// New Zap Request Data
    pub fn new<I>(public_key: PublicKey, relays: I) -> Self
    where
        I: IntoIterator<Item = Url>,
    {
        Self {
            public_key,
            relays: relays.into_iter().collect(),
            message: String::new(),
            amount: None,
            lnurl: None,
            event_id: None,
            event_coordinate: None,
        }
    }

    /// Message
    pub fn message<S>(self, message: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            message: message.into(),
            ..self
        }
    }

    /// Amount in `millisats` the sender intends to pay
    pub fn amount(self, amount: u64) -> Self {
        Self {
            amount: Some(amount),
            ..self
        }
    }

    /// Lnurl pay url of the recipient, encoded using bech32 with the prefix lnurl.
    pub fn lnurl<S>(self, lnurl: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            lnurl: Some(lnurl.into()),
            ..self
        }
    }

    /// Event ID
    pub fn event_id(self, event_id: EventId) -> Self {
        Self {
            event_id: Some(event_id),
            ..self
        }
    }

    /// NIP33 event coordinate that allows tipping parameterized replaceable events such as NIP23 long-form notes.
    pub fn event_coordinate(self, event_coordinate: Coordinate) -> Self {
        Self {
            event_coordinate: Some(event_coordinate),
            ..self
        }
    }
}

impl From<ZapRequestData> for Vec<Tag> {
    fn from(data: ZapRequestData) -> Self {
        let ZapRequestData {
            public_key,
            relays,
            amount,
            lnurl,
            event_id,
            event_coordinate,
            ..
        } = data;

        let mut tags: Vec<Tag> = vec![Tag::public_key(public_key)];

        if !relays.is_empty() {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Relays(
                relays,
            )));
        }

        if let Some(event_id) = event_id {
            tags.push(Tag::event(event_id));
        }

        if let Some(event_coordinate) = event_coordinate {
            tags.push(event_coordinate.into());
        }

        if let Some(amount) = amount {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Amount {
                millisats: amount,
                bolt11: None,
            }));
        }

        if let Some(lnurl) = lnurl {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Lnurl(
                lnurl,
            )));
        }

        tags
    }
}

/// Create **anonymous** zap request
#[cfg(feature = "std")]
pub fn anonymous_zap_request(data: ZapRequestData) -> Result<Event, Error> {
    let keys = Keys::generate();
    let message: String = data.message.clone();
    let mut tags: Vec<Tag> = data.into();
    tags.push(Tag::from_standardized_without_cell(TagStandard::Anon {
        msg: None,
    }));
    Ok(EventBuilder::new(Kind::ZapRequest, message)
        .tags(tags)
        .sign_with_keys(&keys)?)
}

/// Create **private** zap request
#[inline]
#[cfg(feature = "std")]
pub fn private_zap_request(data: ZapRequestData, keys: &Keys) -> Result<Event, Error> {
    private_zap_request_with_ctx(&SECP256K1, &mut OsRng, &Instant::now(), data, keys)
}

/// Create **private** zap request
pub fn private_zap_request_with_ctx<C, R, T>(
    secp: &Secp256k1<C>,
    rng: &mut R,
    supplier: &T,
    data: ZapRequestData,
    keys: &Keys,
) -> Result<Event, Error>
where
    C: Signing + Verification,
    R: RngCore + CryptoRng,
    T: TimeSupplier,
{
    let created_at: Timestamp = Timestamp::now_with_supplier(supplier);

    // Create encryption key
    let secret_key: SecretKey =
        create_encryption_key(keys.secret_key(), &data.public_key, created_at)?;

    // Compose encrypted message
    let mut tags: Vec<Tag> = vec![Tag::public_key(data.public_key)];
    if let Some(event_id) = data.event_id {
        tags.push(Tag::event(event_id));
    }
    let msg: String = EventBuilder::new(Kind::ZapPrivateMessage, &data.message)
        .tags(tags)
        .sign_with_ctx(secp, rng, supplier, keys)?
        .as_json();
    let msg: String = encrypt_private_zap_message(rng, &secret_key, &data.public_key, msg)?;

    // Compose event
    let mut tags: Vec<Tag> = data.into();
    tags.push(Tag::from_standardized_without_cell(TagStandard::Anon {
        msg: Some(msg),
    }));
    let private_zap_keys: Keys = Keys::new_with_ctx(secp, secret_key);
    Ok(EventBuilder::new(Kind::ZapRequest, "")
        .tags(tags)
        .custom_created_at(created_at)
        .sign_with_ctx(secp, rng, supplier, &private_zap_keys)?)
}

/// Create NIP57 encryption key for **private** zap
pub fn create_encryption_key(
    secret_key: &SecretKey,
    public_key: &PublicKey,
    created_at: Timestamp,
) -> Result<SecretKey, Error> {
    let mut unhashed: String = secret_key.to_secret_hex();
    unhashed.push_str(&public_key.to_string());
    unhashed.push_str(&created_at.to_string());
    let hash = Sha256Hash::hash(unhashed.as_bytes());
    Ok(SecretKey::from_slice(hash.as_byte_array())?)
}

/// Encrypt a private zap message using the given keys
pub fn encrypt_private_zap_message<R, T>(
    rng: &mut R,
    secret_key: &SecretKey,
    public_key: &PublicKey,
    msg: T,
) -> Result<String, Error>
where
    R: RngCore,
    T: AsRef<[u8]>,
{
    let key: [u8; 32] = util::generate_shared_key(secret_key, public_key);
    let mut iv: [u8; 16] = [0u8; 16];
    rng.fill_bytes(&mut iv);

    let cipher = Aes256CbcEnc::new(&key.into(), &iv.into());
    let msg: Vec<u8> = cipher.encrypt_padded_vec_mut::<Pkcs7>(msg.as_ref());

    // Bech32 msg
    let encrypted_bech32_msg: String =
        bech32::encode::<Bech32>(PRIVATE_ZAP_MSG_BECH32_PREFIX, &msg)?;

    // Bech32 IV
    let iv_bech32: String = bech32::encode::<Bech32>(PRIVATE_ZAP_IV_BECH32_PREFIX, &iv)?;

    Ok(format!("{encrypted_bech32_msg}_{iv_bech32}"))
}

fn extract_anon_tag_message(event: &Event) -> Result<&String, Error> {
    for tag in event.tags.iter() {
        if let Some(TagStandard::Anon { msg }) = tag.as_standardized() {
            return msg.as_ref().ok_or(Error::InvalidPrivateZapMessage);
        }
    }
    Err(Error::PrivateZapMessageNotFound)
}

/// Decrypt **private** zap message that was sent by the owner of the secret key
pub fn decrypt_sent_private_zap_message(
    secret_key: &SecretKey,
    public_key: &PublicKey,
    private_zap_event: &Event,
) -> Result<Event, Error> {
    // Re-create our ephemeral encryption key
    let secret_key: SecretKey =
        create_encryption_key(secret_key, public_key, private_zap_event.created_at)?;
    let key: [u8; 32] = util::generate_shared_key(&secret_key, public_key);

    // decrypt like normal
    decrypt_private_zap_message(key, private_zap_event)
}

/// Decrypt **private** zap message that was received by the owner of the secret key
#[inline]
pub fn decrypt_received_private_zap_message(
    secret_key: &SecretKey,
    private_zap_event: &Event,
) -> Result<Event, Error> {
    let key: [u8; 32] = util::generate_shared_key(secret_key, &private_zap_event.pubkey);
    decrypt_private_zap_message(key, private_zap_event)
}

fn decrypt_private_zap_message(key: [u8; 32], private_zap_event: &Event) -> Result<Event, Error> {
    let msg: &String = extract_anon_tag_message(private_zap_event)?;
    let mut splitted = msg.split('_');

    let msg: &str = splitted.next().ok_or(Error::InvalidPrivateZapMessage)?;
    let iv: &str = splitted.next().ok_or(Error::InvalidPrivateZapMessage)?;

    // IV
    let (hrp, iv) = bech32::decode(iv)?;
    if hrp != PRIVATE_ZAP_IV_BECH32_PREFIX {
        return Err(Error::WrongBech32PrefixOrVariant);
    }

    // Msg
    let (hrp, msg) = bech32::decode(msg)?;
    if hrp != PRIVATE_ZAP_MSG_BECH32_PREFIX {
        return Err(Error::WrongBech32PrefixOrVariant);
    }

    // Decrypt
    let cipher = Aes256CbcDec::new(&key.into(), iv.as_slice().into());
    let result: Vec<u8> = cipher
        .decrypt_padded_vec_mut::<Pkcs7>(&msg)
        .map_err(|_| Error::WrongBlockMode)?;

    // TODO: check if event kind is equal to 9733
    Ok(Event::from_json(result)?)
}

#[cfg(feature = "std")]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encrypt_decrypt_private_zap_message() {
        let alice_keys = Keys::generate();
        let bob_keys = Keys::generate();

        let relays = [Url::parse("wss://relay.damus.io").unwrap()];
        let msg = "Private Zap message!";
        let data = ZapRequestData::new(bob_keys.public_key(), relays).message(msg);
        let private_zap = private_zap_request(data, &alice_keys).unwrap();

        let private_zap_msg = decrypt_sent_private_zap_message(
            alice_keys.secret_key(),
            &bob_keys.public_key(),
            &private_zap,
        )
        .unwrap();

        assert_eq!(msg, &private_zap_msg.content);

        let private_zap_msg =
            decrypt_received_private_zap_message(bob_keys.secret_key(), &private_zap).unwrap();

        assert_eq!(msg, &private_zap_msg.content)
    }
}

================
File: src/nips/nip58.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP58: Badges
//!
//! <https://github.com/nostr-protocol/nips/blob/master/58.md>

use alloc::vec::Vec;
use core::fmt;

use crate::types::RelayUrl;
use crate::{Event, Kind, PublicKey, Tag, TagStandard};

#[derive(Debug)]
/// Badge Award error
pub enum Error {
    /// Invalid length
    InvalidLength,
    /// Invalid kind
    InvalidKind,
    /// Identifier tag not found
    IdentifierTagNotFound,
    /// Mismatched badge definition or award
    MismatchedBadgeDefinitionOrAward,
    /// Badge awards lack the awarded public key
    BadgeAwardsLackAwardedPublicKey,
    /// Badge awards lack the awarded public key
    BadgeAwardMissingATag,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidLength => write!(f, "invalid length"),
            Self::InvalidKind => write!(f, "invalid kind"),
            Self::IdentifierTagNotFound => write!(f, "identifier tag not found"),
            Self::MismatchedBadgeDefinitionOrAward => write!(f, "mismatched badge definition/award"),
            Self::BadgeAwardsLackAwardedPublicKey => write!(f, "badge award events lack the awarded public keybadge award events lack the awarded public key"),
            Self::BadgeAwardMissingATag => write!(f, "badge award event lacks `a` tag"),
        }
    }
}

/// Helper function to filter events for a specific [`Kind`]
#[inline]
pub(crate) fn filter_for_kind(events: Vec<Event>, kind_needed: &Kind) -> Vec<Event> {
    events
        .into_iter()
        .filter(|e| &e.kind == kind_needed)
        .collect()
}

/// Helper function to extract the awarded public key from an array of PubKey tags
pub(crate) fn extract_awarded_public_key<'a>(
    tags: &'a [Tag],
    awarded_public_key: &PublicKey,
) -> Option<(&'a PublicKey, &'a Option<RelayUrl>)> {
    tags.iter().find_map(|t| match t.as_standardized() {
        Some(TagStandard::PublicKey {
            public_key,
            relay_url,
            ..
        }) if public_key == awarded_public_key => Some((public_key, relay_url)),
        _ => None,
    })
}

================
File: src/nips/nip59.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Distributed under the MIT software license

//! NIP59: Gift Wrap
//!
//! <https://github.com/nostr-protocol/nips/blob/master/59.md>

use alloc::string::String;
use core::fmt;
use core::ops::Range;

use bitcoin::secp256k1::{Secp256k1, Verification};

use crate::event::unsigned::{self, UnsignedEvent};
use crate::event::{self, Event};
use crate::signer::SignerError;
#[cfg(feature = "std")]
use crate::{EventBuilder, Timestamp, SECP256K1};
use crate::{JsonUtil, Kind, NostrSigner, PublicKey};

/// Range for random timestamp tweak (up to 2 days)
pub const RANGE_RANDOM_TIMESTAMP_TWEAK: Range<u64> = 0..172800; // From 0 secs to 2 days

/// NIP59 error
#[derive(Debug)]
pub enum Error {
    /// Signer error
    Signer(SignerError),
    /// Event error
    Event(event::Error),
    /// Unsigned event error
    Unsigned(unsigned::Error),
    /// Not Gift Wrap event
    NotGiftWrap,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Signer(e) => write!(f, "{e}"),
            Self::Event(e) => write!(f, "Event: {e}"),
            Self::Unsigned(e) => write!(f, "Unsigned event: {e}"),
            Self::NotGiftWrap => write!(f, "Not Gift Wrap event"),
        }
    }
}

impl From<SignerError> for Error {
    fn from(e: SignerError) -> Self {
        Self::Signer(e)
    }
}

impl From<event::Error> for Error {
    fn from(e: event::Error) -> Self {
        Self::Event(e)
    }
}

impl From<unsigned::Error> for Error {
    fn from(e: unsigned::Error) -> Self {
        Self::Unsigned(e)
    }
}

/// Unwrapped Gift Wrap (NIP59)
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UnwrappedGift {
    /// The public key of the sender included in the `seal`
    pub sender: PublicKey,
    /// The rumor
    pub rumor: UnsignedEvent,
}

impl UnwrappedGift {
    /// Unwrap Gift Wrap event
    ///
    /// Internally verify the `seal` event
    #[inline]
    #[cfg(feature = "std")]
    pub async fn from_gift_wrap<T>(signer: &T, gift_wrap: &Event) -> Result<Self, Error>
    where
        T: NostrSigner,
    {
        Self::from_gift_wrap_with_ctx(&SECP256K1, signer, gift_wrap).await
    }

    /// Unwrap Gift Wrap event
    ///
    /// Internally verify the `seal` event
    pub async fn from_gift_wrap_with_ctx<C, T>(
        secp: &Secp256k1<C>,
        signer: &T,
        gift_wrap: &Event,
    ) -> Result<Self, Error>
    where
        C: Verification,
        T: NostrSigner,
    {
        // Check event kind
        if gift_wrap.kind != Kind::GiftWrap {
            return Err(Error::NotGiftWrap);
        }

        // Decrypt and verify seal
        let seal: String = signer
            .nip44_decrypt(&gift_wrap.pubkey, &gift_wrap.content)
            .await?;
        let seal: Event = Event::from_json(seal)?;
        seal.verify_with_ctx(secp)?;

        // Decrypt rumor
        let rumor: String = signer.nip44_decrypt(&seal.pubkey, &seal.content).await?;

        Ok(UnwrappedGift {
            sender: seal.pubkey,
            rumor: UnsignedEvent::from_json(rumor)?,
        })
    }
}

/// Extract `rumor` from Gift Wrap event
#[inline]
#[cfg(feature = "std")]
pub async fn extract_rumor<T>(signer: &T, gift_wrap: &Event) -> Result<UnwrappedGift, Error>
where
    T: NostrSigner,
{
    UnwrappedGift::from_gift_wrap(signer, gift_wrap).await
}

/// Create seal
#[cfg(feature = "std")]
pub async fn make_seal<T>(
    signer: &T,
    receiver_pubkey: &PublicKey,
    rumor: EventBuilder,
) -> Result<EventBuilder, Error>
where
    T: NostrSigner,
{
    // Get public key
    let public_key = signer.get_public_key().await?;

    // Build unsigned event
    let mut rumor: UnsignedEvent = rumor.build(public_key);

    // Make sure that rumor has event ID
    rumor.ensure_id();

    // Encrypt content
    let content: String = signer
        .nip44_encrypt(receiver_pubkey, &rumor.as_json())
        .await?;

    // Compose builder
    Ok(EventBuilder::new(Kind::Seal, content)
        .custom_created_at(Timestamp::tweaked(RANGE_RANDOM_TIMESTAMP_TWEAK)))
}

#[cfg(feature = "std")]
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{EventBuilder, Keys};

    #[tokio::test]
    async fn test_extract_rumor() {
        let sender_keys =
            Keys::parse("6b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e")
                .unwrap();
        let receiver_keys =
            Keys::parse("7b911fd37cdf5c81d4c0adb1ab7fa822ed253ab0ad9aa18d77257c88b29b718e")
                .unwrap();

        // Compose Gift Wrap event
        let rumor: EventBuilder = EventBuilder::text_note("Test");
        let event: Event =
            EventBuilder::gift_wrap(&sender_keys, &receiver_keys.public_key(), rumor.clone(), [])
                .await
                .unwrap();
        let unwrapped = extract_rumor(&receiver_keys, &event).await.unwrap();
        assert_eq!(unwrapped.sender, sender_keys.public_key());
        assert_eq!(unwrapped.rumor.kind, Kind::TextNote);
        assert_eq!(unwrapped.rumor.content, "Test");
        assert!(unwrapped.rumor.tags.is_empty());
        assert!(extract_rumor(&sender_keys, &event).await.is_err());

        let event: Event = EventBuilder::text_note("")
            .sign(&sender_keys)
            .await
            .unwrap();
        assert!(matches!(
            extract_rumor(&receiver_keys, &event).await.unwrap_err(),
            Error::NotGiftWrap
        ));
    }
}

================
File: src/nips/nip65.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP65: Relay List Metadata
//!
//! <https://github.com/nostr-protocol/nips/blob/master/65.md>

use alloc::string::{String, ToString};
use core::fmt;
use core::str::FromStr;

use crate::{Event, RelayUrl, TagStandard};

/// NIP56 error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Invalid Relay Metadata
    InvalidRelayMetadata(String),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidRelayMetadata(s) => write!(f, "Invalid relay metadata: {s}"),
        }
    }
}

/// Relay Metadata
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum RelayMetadata {
    /// Read
    Read,
    /// Write
    Write,
}

impl fmt::Display for RelayMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Read => write!(f, "read"),
            Self::Write => write!(f, "write"),
        }
    }
}

impl FromStr for RelayMetadata {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "read" => Ok(Self::Read),
            "write" => Ok(Self::Write),
            s => Err(Error::InvalidRelayMetadata(s.to_string())),
        }
    }
}

/// Extracts the relay info (url, optional read/write flag) from the event
#[inline]
pub fn extract_relay_list(
    event: &Event,
) -> impl Iterator<Item = (&RelayUrl, &Option<RelayMetadata>)> {
    event.tags.iter().filter_map(|tag| {
        if let Some(TagStandard::RelayMetadata {
            relay_url,
            metadata,
        }) = tag.as_standardized()
        {
            Some((relay_url, metadata))
        } else {
            None
        }
    })
}

/// Extracts the relay info (url, optional read/write flag) from the event
#[inline]
pub fn extract_owned_relay_list(
    event: Event,
) -> impl Iterator<Item = (RelayUrl, Option<RelayMetadata>)> {
    event.tags.into_iter().filter_map(|tag| {
        if let Some(TagStandard::RelayMetadata {
            relay_url,
            metadata,
        }) = tag.to_standardized()
        {
            Some((relay_url, metadata))
        } else {
            None
        }
    })
}

================
File: src/nips/nip73.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP73: External Content IDs
//!
//! <https://github.com/nostr-protocol/nips/blob/master/73.md>

use alloc::string::{String, ToString};
use core::fmt;
use core::str::FromStr;

use crate::types::Url;

const HASHTAG: &str = "#";
const GEOHASH: &str = "geo:";
const BOOK: &str = "isbn:";
const PODCAST_FEED: &str = "podcast:guid:";
const PODCAST_EPISODE: &str = "podcast:item:guid:";
const PODCAST_PUBLISHER: &str = "podcast:publisher:guid:";
const MOVIE: &str = "isan:";
const PAPER: &str = "doi:";

/// NIP73 error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Invalid external content
    InvalidExternalContent,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidExternalContent => write!(f, "invalid external content ID"),
        }
    }
}

/// External Content ID
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum ExternalContentId {
    /// URL
    Url(Url),
    /// Hashtag
    Hashtag(String),
    /// Geohash
    Geohash(String),
    /// Book
    Book(String),
    /// Podcast Feed
    PodcastFeed(String),
    /// Podcast Episode
    PodcastEpisode(String),
    /// Podcast Publisher
    PodcastPublisher(String),
    /// Movie
    Movie(String),
    /// Paper
    Paper(String),
}

impl fmt::Display for ExternalContentId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Url(url) => write!(f, "{url}"),
            Self::Hashtag(hashtag) => write!(f, "{HASHTAG}{hashtag}"),
            Self::Geohash(hash) => write!(f, "{GEOHASH}{hash}"),
            Self::Book(id) => write!(f, "{BOOK}{id}"),
            Self::PodcastFeed(guid) => write!(f, "{PODCAST_FEED}{guid}"),
            Self::PodcastEpisode(guid) => write!(f, "{PODCAST_EPISODE}{guid}"),
            Self::PodcastPublisher(guid) => write!(f, "{PODCAST_PUBLISHER}{guid}"),
            Self::Movie(movie) => write!(f, "{MOVIE}{movie}"),
            Self::Paper(paper) => write!(f, "{PAPER}{paper}"),
        }
    }
}

impl FromStr for ExternalContentId {
    type Err = Error;

    fn from_str(content: &str) -> Result<Self, Self::Err> {
        if let Some(stripped) = content.strip_prefix(HASHTAG) {
            return Ok(Self::Hashtag(stripped.to_string()));
        }

        if let Some(stripped) = content.strip_prefix(GEOHASH) {
            return Ok(Self::Geohash(stripped.to_string()));
        }

        if let Some(stripped) = content.strip_prefix(BOOK) {
            return Ok(Self::Book(stripped.to_string()));
        }

        if let Some(stripped) = content.strip_prefix(PODCAST_FEED) {
            return Ok(Self::PodcastFeed(stripped.to_string()));
        }

        if let Some(stripped) = content.strip_prefix(PODCAST_EPISODE) {
            return Ok(Self::PodcastEpisode(stripped.to_string()));
        }

        if let Some(stripped) = content.strip_prefix(PODCAST_PUBLISHER) {
            return Ok(Self::PodcastPublisher(stripped.to_string()));
        }

        if let Some(stripped) = content.strip_prefix(MOVIE) {
            return Ok(Self::Movie(stripped.to_string()));
        }

        if let Some(stripped) = content.strip_prefix(PAPER) {
            return Ok(Self::Paper(stripped.to_string()));
        }

        if let Ok(url) = Url::parse(content) {
            return Ok(Self::Url(url));
        }

        Err(Error::InvalidExternalContent)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialization() {
        assert_eq!(
            ExternalContentId::Url("https://example.com".parse().unwrap()).to_string(),
            "https://example.com/"
        );
        assert_eq!(
            ExternalContentId::Hashtag("rust".to_string()).to_string(),
            "#rust"
        );
        assert_eq!(
            ExternalContentId::Geohash("u4pruydqqvj".to_string()).to_string(),
            "geo:u4pruydqqvj"
        );
        assert_eq!(
            ExternalContentId::Book("978-3-16-148410-0".to_string()).to_string(),
            "isbn:978-3-16-148410-0"
        );
        assert_eq!(
            ExternalContentId::PodcastFeed("feed-guid".to_string()).to_string(),
            "podcast:guid:feed-guid"
        );
        assert_eq!(
            ExternalContentId::PodcastEpisode("episode-guid".to_string()).to_string(),
            "podcast:item:guid:episode-guid"
        );
        assert_eq!(
            ExternalContentId::PodcastPublisher("publisher-guid".to_string()).to_string(),
            "podcast:publisher:guid:publisher-guid"
        );
        assert_eq!(
            ExternalContentId::Movie("movie-id".to_string()).to_string(),
            "isan:movie-id"
        );
        assert_eq!(
            ExternalContentId::Paper("10.1000/182".to_string()).to_string(),
            "doi:10.1000/182"
        );
    }

    #[test]
    fn test_parsing() {
        assert_eq!(
            ExternalContentId::from_str("https://example.com").unwrap(),
            ExternalContentId::Url(Url::parse("https://example.com").unwrap())
        );
        assert_eq!(
            ExternalContentId::from_str("#rust").unwrap(),
            ExternalContentId::Hashtag("rust".to_string())
        );
        assert_eq!(
            ExternalContentId::from_str("geo:u4pruydqqvj").unwrap(),
            ExternalContentId::Geohash("u4pruydqqvj".to_string())
        );
        assert_eq!(
            ExternalContentId::from_str("isbn:978-3-16-148410-0").unwrap(),
            ExternalContentId::Book("978-3-16-148410-0".to_string())
        );
        assert_eq!(
            ExternalContentId::from_str("podcast:guid:feed-guid").unwrap(),
            ExternalContentId::PodcastFeed("feed-guid".to_string())
        );
        assert_eq!(
            ExternalContentId::from_str("podcast:item:guid:episode-guid").unwrap(),
            ExternalContentId::PodcastEpisode("episode-guid".to_string())
        );
        assert_eq!(
            ExternalContentId::from_str("podcast:publisher:guid:publisher-guid").unwrap(),
            ExternalContentId::PodcastPublisher("publisher-guid".to_string())
        );
        assert_eq!(
            ExternalContentId::from_str("isan:movie-id").unwrap(),
            ExternalContentId::Movie("movie-id".to_string())
        );
        assert_eq!(
            ExternalContentId::from_str("doi:10.1000/182").unwrap(),
            ExternalContentId::Paper("10.1000/182".to_string())
        );
    }

    #[test]
    fn test_invalid_content() {
        assert_eq!(
            ExternalContentId::from_str("hello"),
            Err(Error::InvalidExternalContent)
        );
    }
}

================
File: src/nips/nip90.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP90: Data Vending Machines
//!
//! <https://github.com/nostr-protocol/nips/blob/master/90.md>

use alloc::string::String;
use core::fmt;
use core::str::FromStr;

use crate::{Event, EventId, PublicKey};

/// DVM Error
#[derive(Debug)]
pub enum Error {
    /// Unknown status
    UnknownStatus,
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::UnknownStatus => write!(f, "Unknown status"),
        }
    }
}

/// Data Vending Machine Status
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum DataVendingMachineStatus {
    /// Service Provider requires payment before continuing
    PaymentRequired,
    /// Service Provider is processing the job
    Processing,
    /// Service Provider was unable to process the job
    Error,
    /// Service Provider successfully processed the job
    Success,
    /// Service Provider partially processed the job
    Partial,
}

impl fmt::Display for DataVendingMachineStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::PaymentRequired => write!(f, "payment-required"),
            Self::Processing => write!(f, "processing"),
            Self::Error => write!(f, "error"),
            Self::Success => write!(f, "success"),
            Self::Partial => write!(f, "partial"),
        }
    }
}

impl FromStr for DataVendingMachineStatus {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "payment-required" => Ok(Self::PaymentRequired),
            "processing" => Ok(Self::Processing),
            "error" => Ok(Self::Error),
            "success" => Ok(Self::Success),
            "partial" => Ok(Self::Partial),
            _ => Err(Error::UnknownStatus),
        }
    }
}

/// Data Vending Machine (DVM) - Job Feedback data
///
/// <https://github.com/nostr-protocol/nips/blob/master/90.md>
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct JobFeedbackData {
    pub(crate) job_request_id: EventId,
    pub(crate) customer_public_key: PublicKey,
    pub(crate) status: DataVendingMachineStatus,
    pub(crate) extra_info: Option<String>,
    pub(crate) amount_msat: Option<u64>,
    pub(crate) bolt11: Option<String>,
    pub(crate) payload: Option<String>,
}

impl JobFeedbackData {
    /// Construct new Job Feedback
    pub fn new(job_request: &Event, status: DataVendingMachineStatus) -> Self {
        Self {
            job_request_id: job_request.id,
            customer_public_key: job_request.pubkey,
            status,
            extra_info: None,
            amount_msat: None,
            bolt11: None,
            payload: None,
        }
    }

    /// Add extra info
    #[inline]
    pub fn extra_info<S>(mut self, info: S) -> Self
    where
        S: Into<String>,
    {
        self.extra_info = Some(info.into());
        self
    }

    /// Add payment amount
    #[inline]
    pub fn amount(mut self, millisats: u64, bolt11: Option<String>) -> Self {
        self.amount_msat = Some(millisats);
        self.bolt11 = bolt11;
        self
    }

    /// Add payload
    #[inline]
    pub fn payload<S>(mut self, payload: S) -> Self
    where
        S: Into<String>,
    {
        self.payload = Some(payload.into());
        self
    }
}

================
File: src/nips/nip94.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP94: File Metadata
//!
//! <https://github.com/nostr-protocol/nips/blob/master/94.md>

use alloc::string::String;
use alloc::vec::Vec;

use bitcoin::hashes::sha256::Hash as Sha256Hash;

use crate::{ImageDimensions, Tag, TagKind, TagStandard, Url};

/// Potential errors returned when parsing tags into a [FileMetadata] struct
#[derive(Debug, PartialEq, Eq)]
pub enum FileMetadataError {
    /// The URL of the file is missing (no `url` tag)
    MissingUrl,
    /// The mime type of the file is missing (no `m` tag)
    MissingMimeType,
    /// The SHA256 hash of the file is missing (no `x` tag)
    MissingSha,
}

impl core::fmt::Display for FileMetadataError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MissingUrl => write!(f, "missing url"),
            Self::MissingMimeType => write!(f, "missing mime type"),
            Self::MissingSha => write!(f, "missing file sha256"),
        }
    }
}

#[cfg(feature = "std")]
impl std::error::Error for FileMetadataError {}

/// File Metadata
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FileMetadata {
    /// Url
    pub url: Url,
    /// MIME type
    pub mime_type: String,
    /// SHA256 of file
    pub hash: Sha256Hash,
    /// AES 256 GCM
    pub aes_256_gcm: Option<(String, String)>,
    /// Size in bytes
    pub size: Option<usize>,
    /// Size in pixels
    pub dim: Option<ImageDimensions>,
    /// Magnet
    pub magnet: Option<String>,
    /// Blurhash
    pub blurhash: Option<String>,
}

impl FileMetadata {
    /// New [`FileMetadata`]
    pub fn new<S>(url: Url, mime_type: S, hash: Sha256Hash) -> Self
    where
        S: Into<String>,
    {
        Self {
            url,
            mime_type: mime_type.into(),
            hash,
            aes_256_gcm: None,
            size: None,
            dim: None,
            magnet: None,
            blurhash: None,
        }
    }

    /// Add AES 256 GCM
    pub fn aes_256_gcm<S>(self, key: S, iv: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            aes_256_gcm: Some((key.into(), iv.into())),
            ..self
        }
    }

    /// Add file size (bytes)
    pub fn size(self, size: usize) -> Self {
        Self {
            size: Some(size),
            ..self
        }
    }

    /// Add file size (pixels)
    pub fn dimensions(self, dim: ImageDimensions) -> Self {
        Self {
            dim: Some(dim),
            ..self
        }
    }

    /// Add magnet
    pub fn magnet<S>(self, magnet: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            magnet: Some(magnet.into()),
            ..self
        }
    }

    /// Add blurhash
    pub fn blurhash<S>(self, blurhash: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            blurhash: Some(blurhash.into()),
            ..self
        }
    }
}

impl From<FileMetadata> for Vec<Tag> {
    fn from(metadata: FileMetadata) -> Self {
        let FileMetadata {
            url,
            mime_type,
            hash,
            aes_256_gcm,
            size,
            dim,
            magnet,
            blurhash,
        } = metadata;

        let mut tags: Vec<Tag> = Vec::with_capacity(3);

        tags.push(Tag::from_standardized_without_cell(TagStandard::Url(url)));
        tags.push(Tag::from_standardized_without_cell(TagStandard::MimeType(
            mime_type,
        )));
        tags.push(Tag::from_standardized_without_cell(TagStandard::Sha256(
            hash,
        )));

        if let Some((key, iv)) = aes_256_gcm {
            tags.push(Tag::from_standardized_without_cell(
                TagStandard::Aes256Gcm { key, iv },
            ));
        }

        if let Some(size) = size {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Size(size)));
        }

        if let Some(dim) = dim {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Dim(dim)));
        }

        if let Some(magnet) = magnet {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Magnet(
                magnet,
            )));
        }

        if let Some(blurhash) = blurhash {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Blurhash(
                blurhash,
            )));
        }

        tags
    }
}

impl TryFrom<Vec<Tag>> for FileMetadata {
    type Error = FileMetadataError;

    fn try_from(value: Vec<Tag>) -> Result<Self, Self::Error> {
        let url = match value
            .iter()
            .find(|t| t.kind() == TagKind::Url)
            .map(|t| t.as_standardized())
        {
            Some(Some(TagStandard::Url(url))) => Ok(url),
            _ => Err(Self::Error::MissingUrl),
        }?;

        let mime = match value
            .iter()
            .find(|t| {
                let t = t.as_standardized();
                matches!(t, Some(TagStandard::MimeType(..)))
            })
            .map(|t| t.as_standardized())
        {
            Some(Some(TagStandard::MimeType(mime))) => Ok(mime),
            _ => Err(Self::Error::MissingMimeType),
        }?;

        let sha256 = match value
            .iter()
            .find(|t| {
                let t = t.as_standardized();
                matches!(t, Some(TagStandard::Sha256(..)))
            })
            .map(|t| t.as_standardized())
        {
            Some(Some(TagStandard::Sha256(sha256))) => Ok(sha256),
            _ => Err(Self::Error::MissingSha),
        }?;

        let mut metadata = FileMetadata::new(url.clone(), mime, *sha256);

        if let Some(TagStandard::Aes256Gcm { key, iv }) = value.iter().find_map(|t| {
            let t = t.as_standardized();
            if matches!(t, Some(TagStandard::Aes256Gcm { .. })) {
                t
            } else {
                None
            }
        }) {
            metadata = metadata.aes_256_gcm(key, iv);
        }

        if let Some(TagStandard::Size(size)) = value.iter().find_map(|t| {
            let t = t.as_standardized();
            if matches!(t, Some(TagStandard::Size { .. })) {
                t
            } else {
                None
            }
        }) {
            metadata = metadata.size(*size);
        }

        if let Some(TagStandard::Dim(dim)) = value.iter().find_map(|t| {
            let t = t.as_standardized();
            if matches!(t, Some(TagStandard::Dim { .. })) {
                t
            } else {
                None
            }
        }) {
            metadata = metadata.dimensions(*dim);
        }

        if let Some(TagStandard::Magnet(magnet)) = value.iter().find_map(|t| {
            let t = t.as_standardized();
            if matches!(t, Some(TagStandard::Magnet { .. })) {
                t
            } else {
                None
            }
        }) {
            metadata = metadata.magnet(magnet);
        }

        if let Some(TagStandard::Blurhash(bh)) = value.iter().find_map(|t| {
            let t = t.as_standardized();
            if matches!(t, Some(TagStandard::Blurhash { .. })) {
                t
            } else {
                None
            }
        }) {
            metadata = metadata.blurhash(bh);
        }

        Ok(metadata)
    }
}

#[cfg(test)]
mod tests {
    use core::str::FromStr;

    use super::*;
    use crate::{ImageDimensions, Tag};

    const IMAGE_URL: &str = "https://image.nostr.build/99a95fcb4b7a2591ad32467032c52a62d90a204d3b176bc2459ad7427a3f2b89.jpg";
    const IMAGE_HASH: &str = "1aea8e98e0e5d969b7124f553b88dfae47d1f00472ea8c0dbf4ac4577d39ef02";

    #[test]
    fn parses_valid_tag_vector() {
        let url = Url::parse(IMAGE_URL).unwrap();
        let hash = Sha256Hash::from_str(IMAGE_HASH).unwrap();
        let dim = ImageDimensions {
            width: 640,
            height: 640,
        };
        let tags = vec![
            Tag::from_standardized_without_cell(TagStandard::Dim(dim)),
            Tag::from_standardized_without_cell(TagStandard::Sha256(hash)),
            Tag::from_standardized_without_cell(TagStandard::Url(url.clone())),
            Tag::from_standardized_without_cell(TagStandard::MimeType(String::from("image/jpeg"))),
        ];
        let got = FileMetadata::try_from(tags).unwrap();
        let expected = FileMetadata::new(url, "image/jpeg", hash).dimensions(dim);

        assert_eq!(expected, got);
    }

    #[test]
    fn returns_error_with_url_missing() {
        let hash = Sha256Hash::from_str(IMAGE_HASH).unwrap();
        let dim = ImageDimensions {
            width: 640,
            height: 640,
        };
        let tags = vec![
            Tag::from_standardized_without_cell(TagStandard::Dim(dim)),
            Tag::from_standardized_without_cell(TagStandard::Sha256(hash)),
            Tag::from_standardized_without_cell(TagStandard::MimeType(String::from("image/jpeg"))),
        ];
        let got = FileMetadata::try_from(tags).unwrap_err();

        assert_eq!(FileMetadataError::MissingUrl, got);
    }

    #[test]
    fn returns_error_with_mime_type_missing() {
        let url = Url::parse(IMAGE_URL).unwrap();
        let hash = Sha256Hash::from_str(IMAGE_HASH).unwrap();
        let dim = ImageDimensions {
            width: 640,
            height: 640,
        };
        let tags = vec![
            Tag::from_standardized_without_cell(TagStandard::Dim(dim)),
            Tag::from_standardized_without_cell(TagStandard::Sha256(hash)),
            Tag::from_standardized_without_cell(TagStandard::Url(url.clone())),
        ];
        let got = FileMetadata::try_from(tags).unwrap_err();

        assert_eq!(FileMetadataError::MissingMimeType, got);
    }

    #[test]
    fn returns_error_with_sha_missing() {
        let url = Url::parse(IMAGE_URL).unwrap();
        let dim = ImageDimensions {
            width: 640,
            height: 640,
        };
        let tags = vec![
            Tag::from_standardized_without_cell(TagStandard::Dim(dim)),
            Tag::from_standardized_without_cell(TagStandard::Url(url.clone())),
            Tag::from_standardized_without_cell(TagStandard::MimeType(String::from("image/jpeg"))),
        ];
        let got = FileMetadata::try_from(tags).unwrap_err();

        assert_eq!(FileMetadataError::MissingSha, got);
    }
}

================
File: src/nips/nip98.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! NIP98: HTTP Auth
//!
//! This NIP defines an ephemeral event used to authorize requests to HTTP servers using nostr events.
//! This is useful for HTTP services which are build for Nostr and deal with Nostr user accounts.
//!
//! <https://github.com/nostr-protocol/nips/blob/master/98.md>

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;
use core::str::FromStr;

use bitcoin::hashes::sha256::Hash as Sha256Hash;

use crate::{Tag, TagStandard, Url};

/// [`HttpData`] required tags
#[derive(Debug, PartialEq, Eq)]
pub enum RequiredTags {
    /// [`TagStandard::AbsoluteURL`]
    AbsoluteURL,
    /// [`TagStandard::Method`]
    Method,
}

impl fmt::Display for RequiredTags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::AbsoluteURL => write!(f, "url"),
            Self::Method => write!(f, "method"),
        }
    }
}

/// NIP98 error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Tag missing when parsing
    MissingTag(RequiredTags),
    /// Invalid HTTP Method
    InvalidHttpMethod(String),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::MissingTag(tag) => write!(f, "missing tag '{tag}'"),
            Self::InvalidHttpMethod(m) => write!(f, "Invalid HTTP method: {m}"),
        }
    }
}

/// HTTP Method
///
/// <https://github.com/nostr-protocol/nips/blob/master/98.md>
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum HttpMethod {
    /// GET
    GET,
    /// POST
    POST,
    /// PUT
    PUT,
    /// PATCH
    PATCH,
}

impl fmt::Display for HttpMethod {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::GET => write!(f, "GET"),
            Self::POST => write!(f, "POST"),
            Self::PUT => write!(f, "PUT"),
            Self::PATCH => write!(f, "PATCH"),
        }
    }
}

impl FromStr for HttpMethod {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "GET" => Ok(Self::GET),
            "POST" => Ok(Self::POST),
            "PUT" => Ok(Self::PUT),
            "PATCH" => Ok(Self::PATCH),
            m => Err(Error::InvalidHttpMethod(m.to_string())),
        }
    }
}

/// HTTP Data
///
/// <https://github.com/nostr-protocol/nips/blob/master/98.md>
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct HttpData {
    /// Absolute request URL
    pub url: Url,
    /// HTTP method
    pub method: HttpMethod,
    /// SHA256 hash of the request body
    pub payload: Option<Sha256Hash>,
}

impl HttpData {
    /// New [`HttpData`]
    #[inline]
    pub fn new(url: Url, method: HttpMethod) -> Self {
        Self {
            url,
            method,
            payload: None,
        }
    }

    /// Add hex-encoded SHA256 hash of the request body
    #[inline]
    pub fn payload(mut self, payload: Sha256Hash) -> Self {
        self.payload = Some(payload);
        self
    }
}

impl From<HttpData> for Vec<Tag> {
    fn from(data: HttpData) -> Self {
        let HttpData {
            url,
            method,
            payload,
        } = data;

        let mut tags: Vec<Tag> = vec![
            Tag::from_standardized_without_cell(TagStandard::AbsoluteURL(url)),
            Tag::from_standardized_without_cell(TagStandard::Method(method)),
        ];
        if let Some(payload) = payload {
            tags.push(Tag::from_standardized_without_cell(TagStandard::Payload(
                payload,
            )));
        }

        tags
    }
}

impl TryFrom<Vec<Tag>> for HttpData {
    type Error = Error;

    fn try_from(value: Vec<Tag>) -> Result<Self, Self::Error> {
        let url = value
            .iter()
            .find_map(|t| match t.as_standardized() {
                Some(TagStandard::AbsoluteURL(u)) => Some(u),
                _ => None,
            })
            .cloned()
            .ok_or(Error::MissingTag(RequiredTags::AbsoluteURL))?;
        let method = value
            .iter()
            .find_map(|t| match t.as_standardized() {
                Some(TagStandard::Method(m)) => Some(m),
                _ => None,
            })
            .cloned()
            .ok_or(Error::MissingTag(RequiredTags::Method))?;
        let payload = value
            .iter()
            .find_map(|t| match t.as_standardized() {
                Some(TagStandard::Payload(p)) => Some(p),
                _ => None,
            })
            .cloned();

        Ok(Self {
            url,
            method,
            payload,
        })
    }
}

================
File: src/types/time/mod.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Time

use alloc::string::{String, ToString};
use core::fmt;
use core::ops::{Add, Range, Sub};
use core::str::{self, FromStr};
use core::time::Duration;

#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::rand::Rng;

mod supplier;

pub use self::supplier::TimeSupplier;
#[cfg(feature = "std")]
pub use self::supplier::{Instant, SystemTime, UNIX_EPOCH};

// 2000-03-01 (mod 400 year, immediately after feb29)
const LEAPOCH: i64 = 11017;
const DAYS_PER_400Y: i64 = 365 * 400 + 97;
const DAYS_PER_100Y: i64 = 365 * 100 + 24;
const DAYS_PER_4Y: i64 = 365 * 4 + 1;

const TO_HUMAN_DATE_BUF: [u8; 20] = [
    b'0', b'0', b'0', b'0', b'-', b'0', b'0', b'-', b'0', b'0', b'T', b'0', b'0', b':', b'0', b'0',
    b':', b'0', b'0', b'Z',
];

/// Unix timestamp in seconds
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Timestamp(u64);

impl Timestamp {
    /// Construct from seconds
    #[inline]
    pub const fn from_secs(secs: u64) -> Self {
        Self(secs)
    }

    /// Compose `0` timestamp
    #[inline]
    pub const fn zero() -> Self {
        Self::from_secs(0)
    }

    /// The minimum representable timestamp
    #[inline]
    pub const fn min() -> Self {
        Self::from_secs(u64::MIN)
    }

    /// The maximum representable timestamp
    #[inline]
    pub const fn max() -> Self {
        Self::from_secs(u64::MAX)
    }

    /// Get UNIX timestamp
    #[cfg(feature = "std")]
    pub fn now() -> Self {
        let ts: u64 = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        Self::from_secs(ts)
    }

    /// Get UNIX timestamp from a specified [`TimeSupplier`]
    pub fn now_with_supplier<T>(supplier: &T) -> Self
    where
        T: TimeSupplier,
    {
        let now = supplier.now();
        let starting_point = supplier.starting_point();
        let duration = supplier.elapsed_since(now, starting_point);
        supplier.to_timestamp(duration)
    }

    /// Get tweaked UNIX timestamp
    ///
    /// Remove a random number of seconds from now
    #[cfg(feature = "std")]
    pub fn tweaked(range: Range<u64>) -> Self {
        let mut now: Timestamp = Self::now();
        now.tweak(range);
        now
    }

    /// Get tweaked UNIX timestamp
    ///
    /// Remove a random number of seconds from now
    pub fn tweaked_with_supplier_and_rng<T, R>(supplier: &T, rng: &mut R, range: Range<u64>) -> Self
    where
        T: TimeSupplier,
        R: Rng,
    {
        let mut now: Timestamp = Self::now_with_supplier(supplier);
        now.tweak_with_rng(rng, range);
        now
    }

    /// Remove a random number of seconds from [`Timestamp`]
    #[inline]
    #[cfg(feature = "std")]
    pub fn tweak(&mut self, range: Range<u64>) {
        self.tweak_with_rng(&mut OsRng, range);
    }

    /// Remove a random number of seconds from [`Timestamp`]
    pub fn tweak_with_rng<R>(&mut self, rng: &mut R, range: Range<u64>)
    where
        R: Rng,
    {
        let secs: u64 = rng.gen_range(range);
        self.0 = self.0.saturating_sub(secs);
    }

    /// Get timestamp as [`u64`]
    #[inline]
    pub fn as_u64(&self) -> u64 {
        self.0
    }

    /// Check if timestamp is `0`
    #[inline]
    pub fn is_zero(&self) -> bool {
        self.0 == 0
    }

    /// Convert [`Timestamp`] to human datetime
    pub fn to_human_datetime(&self) -> String {
        let timestamp: u64 = self.as_u64();

        if timestamp >= 253_402_300_800 {
            // Year 9999
            return String::from("Unavailable");
        }

        let days = (timestamp / 86400) as i64 - LEAPOCH;
        let secs_of_day = timestamp % 86400;

        let mut qc_cycles = days / DAYS_PER_400Y;
        let mut remdays = days % DAYS_PER_400Y;

        if remdays < 0 {
            remdays += DAYS_PER_400Y;
            qc_cycles -= 1;
        }

        let mut c_cycles = remdays / DAYS_PER_100Y;
        if c_cycles == 4 {
            c_cycles -= 1;
        }
        remdays -= c_cycles * DAYS_PER_100Y;

        let mut q_cycles = remdays / DAYS_PER_4Y;
        if q_cycles == 25 {
            q_cycles -= 1;
        }
        remdays -= q_cycles * DAYS_PER_4Y;

        let mut remyears = remdays / 365;
        if remyears == 4 {
            remyears -= 1;
        }
        remdays -= remyears * 365;

        let mut year = 2000 + remyears + 4 * q_cycles + 100 * c_cycles + 400 * qc_cycles;

        let months = [31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29];
        let mut mon = 0;
        for mon_len in months.iter() {
            mon += 1;
            if remdays < *mon_len {
                break;
            }
            remdays -= *mon_len;
        }
        let mday = remdays + 1;
        let mon = if mon + 2 > 12 {
            year += 1;
            mon - 10
        } else {
            mon + 2
        };

        let mut buf: [u8; 20] = TO_HUMAN_DATE_BUF;

        buf[0] = b'0' + (year / 1000) as u8;
        buf[1] = b'0' + (year / 100 % 10) as u8;
        buf[2] = b'0' + (year / 10 % 10) as u8;
        buf[3] = b'0' + (year % 10) as u8;
        buf[5] = b'0' + (mon / 10) as u8;
        buf[6] = b'0' + (mon % 10) as u8;
        buf[8] = b'0' + (mday / 10) as u8;
        buf[9] = b'0' + (mday % 10) as u8;
        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;
        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;
        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;
        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;
        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;
        buf[18] = b'0' + (secs_of_day % 10) as u8;

        str::from_utf8(&buf).unwrap_or_default().to_string()
    }
}

impl Default for Timestamp {
    #[inline]
    fn default() -> Self {
        Self::zero()
    }
}

impl From<u64> for Timestamp {
    fn from(secs: u64) -> Self {
        Self::from_secs(secs)
    }
}

impl FromStr for Timestamp {
    type Err = core::num::ParseIntError;

    #[inline]
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self::from_secs(s.parse::<u64>()?))
    }
}

impl fmt::Display for Timestamp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Add<Timestamp> for Timestamp {
    type Output = Self;
    fn add(self, rhs: Timestamp) -> Self::Output {
        Self::from_secs(self.0.saturating_add(rhs.as_u64()))
    }
}

impl Sub<Timestamp> for Timestamp {
    type Output = Self;
    fn sub(self, rhs: Timestamp) -> Self::Output {
        Self::from_secs(self.0.saturating_sub(rhs.as_u64()))
    }
}

impl Add<Duration> for Timestamp {
    type Output = Self;

    fn add(self, rhs: Duration) -> Self::Output {
        Self::from_secs(self.0.saturating_add(rhs.as_secs()))
    }
}

impl Sub<Duration> for Timestamp {
    type Output = Self;

    fn sub(self, rhs: Duration) -> Self::Output {
        Self::from_secs(self.0.saturating_sub(rhs.as_secs()))
    }
}

impl Add<u64> for Timestamp {
    type Output = Self;

    fn add(self, rhs: u64) -> Self::Output {
        Self::from_secs(self.0.saturating_add(rhs))
    }
}

impl Sub<u64> for Timestamp {
    type Output = Self;

    fn sub(self, rhs: u64) -> Self::Output {
        Self::from_secs(self.0.saturating_sub(rhs))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_timestamp_to_human_datetime() {
        let timestamp = Timestamp::from(1682060685);
        assert_eq!(
            timestamp.to_human_datetime(),
            String::from("2023-04-21T07:04:45Z")
        );
    }
}

#[cfg(bench)]
mod benches {
    use test::{black_box, Bencher};

    use super::*;

    #[bench]
    pub fn timestamp_to_human_datetime(bh: &mut Bencher) {
        let timestamp = Timestamp::from(1682060685);
        bh.iter(|| {
            black_box(timestamp.to_human_datetime());
        });
    }
}

================
File: src/types/time/supplier.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Time supplier

use core::ops::Sub;
use core::time::Duration;
#[cfg(all(feature = "std", not(target_arch = "wasm32")))]
pub use std::time::{Instant, SystemTime, UNIX_EPOCH};

#[cfg(target_arch = "wasm32")]
pub use instant::{Instant, SystemTime};

/// Unix epoch
#[cfg(target_arch = "wasm32")]
pub const UNIX_EPOCH: SystemTime = SystemTime::UNIX_EPOCH;

use super::Timestamp;

/// Helper trait for acquiring time in `no_std` environments.
pub trait TimeSupplier {
    /// The current time from the specified `TimeSupplier`
    type Now: Clone + Sub;
    /// The starting point for the specified `TimeSupplier`
    type StartingPoint: Clone;

    /// Get the current time as the associated `StartingPoint` type
    fn now(&self) -> Self::StartingPoint;

    /// Get the current time as the associated `Now` type
    fn instant_now(&self) -> Self::Now;

    /// Get the starting point from the specified `TimeSupplier`
    fn starting_point(&self) -> Self::StartingPoint;

    /// Get a duration since the StartingPoint.
    fn duration_since_starting_point(&self, now: Self::StartingPoint) -> Duration;

    /// Get the elapsed time as `Duration` starting from `since` to `now`
    fn elapsed_instant_since(&self, now: Self::Now, since: Self::Now) -> Duration;

    /// Get the elapsed time as `Duration` starting from `since` to `now`
    fn elapsed_since(&self, now: Self::StartingPoint, since: Self::StartingPoint) -> Duration;

    /// Convert the specified `Duration` to `Timestamp`
    fn to_timestamp(&self, duration: Duration) -> Timestamp {
        Timestamp::from(duration.as_secs())
    }
}

#[cfg(feature = "std")]
impl TimeSupplier for Instant {
    type Now = Self;
    type StartingPoint = SystemTime;

    fn now(&self) -> Self::StartingPoint {
        SystemTime::now()
    }

    fn instant_now(&self) -> Self::Now {
        Instant::now()
    }

    fn starting_point(&self) -> Self::StartingPoint {
        UNIX_EPOCH
    }

    fn duration_since_starting_point(&self, now: Self::StartingPoint) -> Duration {
        now.duration_since(self.starting_point())
            .unwrap_or_default()
    }

    fn elapsed_instant_since(&self, now: Self::Now, since: Self::Now) -> Duration {
        now - since
    }

    fn elapsed_since(&self, now: Self::StartingPoint, since: Self::StartingPoint) -> Duration {
        now.duration_since(since).unwrap_or_default()
    }
}

================
File: src/types/contact.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Contact

use alloc::string::String;

use crate::key::PublicKey;
use crate::types::RelayUrl;

/// Contact
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Deserialize, Serialize)]
pub struct Contact {
    /// Public key
    pub public_key: PublicKey,
    /// Relay url
    pub relay_url: Option<RelayUrl>,
    /// Alias
    pub alias: Option<String>,
}

impl Contact {
    /// Create new [`Contact`]
    #[inline]
    pub fn new<S>(public_key: PublicKey, relay_url: Option<RelayUrl>, alias: Option<S>) -> Self
    where
        S: Into<String>,
    {
        Self {
            public_key,
            relay_url,
            alias: alias.map(|a| a.into()),
        }
    }
}

================
File: src/types/filter.rs
================
// Copyright (c) 2021 Paul Miller
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Filters

use alloc::collections::{BTreeMap, BTreeSet};
use alloc::string::{String, ToString};
use core::fmt;
use core::hash::Hash;
use core::str::FromStr;

use serde::de::{Deserializer, MapAccess, Visitor};
use serde::ser::{SerializeMap, Serializer};
use serde::{Deserialize, Serialize};

use crate::event::tag::list::TagsIndexes;
use crate::nips::nip01::Coordinate;
use crate::{Event, EventId, JsonUtil, Kind, PublicKey, Timestamp};

type GenericTags = BTreeMap<SingleLetterTag, BTreeSet<String>>;

const P_TAG: SingleLetterTag = SingleLetterTag::lowercase(Alphabet::P);

/// Alphabet Error
#[derive(Debug)]
pub enum SingleLetterTagError {
    /// Invalid char
    InvalidChar,
    /// Expected char
    ExpectedChar,
}

#[cfg(feature = "std")]
impl std::error::Error for SingleLetterTagError {}

impl fmt::Display for SingleLetterTagError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidChar => write!(f, "invalid alphabet char"),
            Self::ExpectedChar => write!(f, "Expected char "),
        }
    }
}

/// Alphabet
#[allow(missing_docs)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Alphabet {
    A,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
    J,
    K,
    L,
    M,
    N,
    O,
    P,
    Q,
    R,
    S,
    T,
    U,
    V,
    W,
    X,
    Y,
    Z,
}

/// Single-Letter Tag (a-zA-Z)
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SingleLetterTag {
    /// Single-letter char
    pub character: Alphabet,
    /// Is the `character` uppercase?
    pub uppercase: bool,
}

impl SingleLetterTag {
    /// Compose new `lowercase` single-letter tag
    #[inline]
    pub const fn lowercase(character: Alphabet) -> Self {
        Self {
            character,
            uppercase: false,
        }
    }

    /// Compose new `uppercase` single-letter tag
    #[inline]
    pub const fn uppercase(character: Alphabet) -> Self {
        Self {
            character,
            uppercase: true,
        }
    }

    /// Parse single-letter tag from [char]
    pub fn from_char(c: char) -> Result<Self, SingleLetterTagError> {
        let character = match c {
            'a' | 'A' => Alphabet::A,
            'b' | 'B' => Alphabet::B,
            'c' | 'C' => Alphabet::C,
            'd' | 'D' => Alphabet::D,
            'e' | 'E' => Alphabet::E,
            'f' | 'F' => Alphabet::F,
            'g' | 'G' => Alphabet::G,
            'h' | 'H' => Alphabet::H,
            'i' | 'I' => Alphabet::I,
            'j' | 'J' => Alphabet::J,
            'k' | 'K' => Alphabet::K,
            'l' | 'L' => Alphabet::L,
            'm' | 'M' => Alphabet::M,
            'n' | 'N' => Alphabet::N,
            'o' | 'O' => Alphabet::O,
            'p' | 'P' => Alphabet::P,
            'q' | 'Q' => Alphabet::Q,
            'r' | 'R' => Alphabet::R,
            's' | 'S' => Alphabet::S,
            't' | 'T' => Alphabet::T,
            'u' | 'U' => Alphabet::U,
            'v' | 'V' => Alphabet::V,
            'w' | 'W' => Alphabet::W,
            'x' | 'X' => Alphabet::X,
            'y' | 'Y' => Alphabet::Y,
            'z' | 'Z' => Alphabet::Z,
            _ => return Err(SingleLetterTagError::InvalidChar),
        };

        Ok(Self {
            character,
            uppercase: c.is_uppercase(),
        })
    }

    /// Convert to `char`
    pub fn as_char(&self) -> char {
        if self.uppercase {
            match self.character {
                Alphabet::A => 'A',
                Alphabet::B => 'B',
                Alphabet::C => 'C',
                Alphabet::D => 'D',
                Alphabet::E => 'E',
                Alphabet::F => 'F',
                Alphabet::G => 'G',
                Alphabet::H => 'H',
                Alphabet::I => 'I',
                Alphabet::J => 'J',
                Alphabet::K => 'K',
                Alphabet::L => 'L',
                Alphabet::M => 'M',
                Alphabet::N => 'N',
                Alphabet::O => 'O',
                Alphabet::P => 'P',
                Alphabet::Q => 'Q',
                Alphabet::R => 'R',
                Alphabet::S => 'S',
                Alphabet::T => 'T',
                Alphabet::U => 'U',
                Alphabet::V => 'V',
                Alphabet::W => 'W',
                Alphabet::X => 'X',
                Alphabet::Y => 'Y',
                Alphabet::Z => 'Z',
            }
        } else {
            match self.character {
                Alphabet::A => 'a',
                Alphabet::B => 'b',
                Alphabet::C => 'c',
                Alphabet::D => 'd',
                Alphabet::E => 'e',
                Alphabet::F => 'f',
                Alphabet::G => 'g',
                Alphabet::H => 'h',
                Alphabet::I => 'i',
                Alphabet::J => 'j',
                Alphabet::K => 'k',
                Alphabet::L => 'l',
                Alphabet::M => 'm',
                Alphabet::N => 'n',
                Alphabet::O => 'o',
                Alphabet::P => 'p',
                Alphabet::Q => 'q',
                Alphabet::R => 'r',
                Alphabet::S => 's',
                Alphabet::T => 't',
                Alphabet::U => 'u',
                Alphabet::V => 'v',
                Alphabet::W => 'w',
                Alphabet::X => 'x',
                Alphabet::Y => 'y',
                Alphabet::Z => 'z',
            }
        }
    }

    /// Convert to `&str`
    pub fn as_str(&self) -> &str {
        if self.uppercase {
            match self.character {
                Alphabet::A => "A",
                Alphabet::B => "B",
                Alphabet::C => "C",
                Alphabet::D => "D",
                Alphabet::E => "E",
                Alphabet::F => "F",
                Alphabet::G => "G",
                Alphabet::H => "H",
                Alphabet::I => "I",
                Alphabet::J => "J",
                Alphabet::K => "K",
                Alphabet::L => "L",
                Alphabet::M => "M",
                Alphabet::N => "N",
                Alphabet::O => "O",
                Alphabet::P => "P",
                Alphabet::Q => "Q",
                Alphabet::R => "R",
                Alphabet::S => "S",
                Alphabet::T => "T",
                Alphabet::U => "U",
                Alphabet::V => "V",
                Alphabet::W => "W",
                Alphabet::X => "X",
                Alphabet::Y => "Y",
                Alphabet::Z => "Z",
            }
        } else {
            match self.character {
                Alphabet::A => "a",
                Alphabet::B => "b",
                Alphabet::C => "c",
                Alphabet::D => "d",
                Alphabet::E => "e",
                Alphabet::F => "f",
                Alphabet::G => "g",
                Alphabet::H => "h",
                Alphabet::I => "i",
                Alphabet::J => "j",
                Alphabet::K => "k",
                Alphabet::L => "l",
                Alphabet::M => "m",
                Alphabet::N => "n",
                Alphabet::O => "o",
                Alphabet::P => "p",
                Alphabet::Q => "q",
                Alphabet::R => "r",
                Alphabet::S => "s",
                Alphabet::T => "t",
                Alphabet::U => "u",
                Alphabet::V => "v",
                Alphabet::W => "w",
                Alphabet::X => "x",
                Alphabet::Y => "y",
                Alphabet::Z => "z",
            }
        }
    }

    /// Check if single-letter tag is `lowercase`
    #[inline]
    pub fn is_lowercase(&self) -> bool {
        !self.uppercase
    }

    /// Check if single-letter tag is `uppercase`
    #[inline]
    pub fn is_uppercase(&self) -> bool {
        self.uppercase
    }
}

impl fmt::Display for SingleLetterTag {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl FromStr for SingleLetterTag {
    type Err = SingleLetterTagError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.len() == 1 {
            let c: char = s.chars().next().ok_or(SingleLetterTagError::ExpectedChar)?;
            Self::from_char(c)
        } else {
            Err(SingleLetterTagError::ExpectedChar)
        }
    }
}

impl Serialize for SingleLetterTag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_char(self.as_char())
    }
}

impl<'de> Deserialize<'de> for SingleLetterTag {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let character: char = char::deserialize(deserializer)?;
        Self::from_char(character).map_err(serde::de::Error::custom)
    }
}

/// Subscription filters
///
/// <https://github.com/nostr-protocol/nips/blob/master/01.md>
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Filter {
    /// List of [`EventId`]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub ids: Option<BTreeSet<EventId>>,
    /// List of [`PublicKey`]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub authors: Option<BTreeSet<PublicKey>>,
    /// List of a kind numbers
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub kinds: Option<BTreeSet<Kind>>,
    /// It's a string describing a query in a human-readable form, i.e. "best nostr apps"
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/50.md>
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub search: Option<String>,
    /// An integer unix timestamp, events must be newer than this to pass
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub since: Option<Timestamp>,
    /// An integer unix timestamp, events must be older than this to pass
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub until: Option<Timestamp>,
    /// Maximum number of events to be returned in the initial query
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub limit: Option<usize>,
    /// Generic tag queries
    #[serde(
        flatten,
        serialize_with = "serialize_generic_tags",
        deserialize_with = "deserialize_generic_tags"
    )]
    #[serde(default)]
    pub generic_tags: GenericTags,
}

impl Filter {
    /// Create new empty [`Filter`]
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Add [`EventId`]
    #[inline]
    pub fn id(self, id: EventId) -> Self {
        self.ids([id])
    }

    /// Add event ids or prefixes
    #[inline]
    pub fn ids<I>(mut self, ids: I) -> Self
    where
        I: IntoIterator<Item = EventId>,
    {
        self.ids = extend_or_collect(self.ids, ids);
        self
    }

    /// Remove event ids
    #[inline]
    pub fn remove_ids<I>(mut self, ids: I) -> Self
    where
        I: IntoIterator<Item = EventId>,
    {
        self.ids = remove_or_none(self.ids, ids);
        self
    }

    /// Add author
    #[inline]
    pub fn author(self, author: PublicKey) -> Self {
        self.authors([author])
    }

    /// Add authors
    #[inline]
    pub fn authors<I>(mut self, authors: I) -> Self
    where
        I: IntoIterator<Item = PublicKey>,
    {
        self.authors = extend_or_collect(self.authors, authors);
        self
    }

    /// Remove authors
    #[inline]
    pub fn remove_authors<I>(mut self, authors: I) -> Self
    where
        I: IntoIterator<Item = PublicKey>,
    {
        self.authors = remove_or_none(self.authors, authors);
        self
    }

    /// Add kind
    #[inline]
    pub fn kind(self, kind: Kind) -> Self {
        self.kinds([kind])
    }

    /// Add kinds
    #[inline]
    pub fn kinds<I>(mut self, kinds: I) -> Self
    where
        I: IntoIterator<Item = Kind>,
    {
        self.kinds = extend_or_collect(self.kinds, kinds);
        self
    }

    /// Remove kinds
    #[inline]
    pub fn remove_kinds<I>(mut self, kinds: I) -> Self
    where
        I: IntoIterator<Item = Kind>,
    {
        self.kinds = remove_or_none(self.kinds, kinds);
        self
    }

    /// Add event
    #[inline]
    pub fn event(self, id: EventId) -> Self {
        self.custom_tag(SingleLetterTag::lowercase(Alphabet::E), [id])
    }

    /// Add events
    #[inline]
    pub fn events<I>(self, events: I) -> Self
    where
        I: IntoIterator<Item = EventId>,
    {
        self.custom_tag(SingleLetterTag::lowercase(Alphabet::E), events)
    }

    /// Remove events
    #[inline]
    pub fn remove_events<I>(self, events: I) -> Self
    where
        I: IntoIterator<Item = EventId>,
    {
        self.remove_custom_tag(SingleLetterTag::lowercase(Alphabet::E), events)
    }

    /// Add pubkey
    #[inline]
    pub fn pubkey(self, pubkey: PublicKey) -> Self {
        self.custom_tag(SingleLetterTag::lowercase(Alphabet::P), [pubkey])
    }

    /// Add pubkeys
    #[inline]
    pub fn pubkeys<I>(self, pubkeys: I) -> Self
    where
        I: IntoIterator<Item = PublicKey>,
    {
        self.custom_tag(SingleLetterTag::lowercase(Alphabet::P), pubkeys)
    }

    /// Remove pubkeys
    #[inline]
    pub fn remove_pubkeys<I>(self, pubkeys: I) -> Self
    where
        I: IntoIterator<Item = PublicKey>,
    {
        self.remove_custom_tag(SingleLetterTag::lowercase(Alphabet::P), pubkeys)
    }

    /// Add hashtag
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/12.md>
    #[inline]
    pub fn hashtag<S>(self, hashtag: S) -> Self
    where
        S: Into<String>,
    {
        self.custom_tag(SingleLetterTag::lowercase(Alphabet::T), [hashtag.into()])
    }

    /// Add hashtags
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/12.md>
    #[inline]
    pub fn hashtags<I, S>(self, hashtags: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        self.custom_tag(
            SingleLetterTag::lowercase(Alphabet::T),
            hashtags.into_iter().map(|s| s.into()),
        )
    }

    /// Remove hashtags
    #[inline]
    pub fn remove_hashtags<I, S>(self, hashtags: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        self.remove_custom_tag(
            SingleLetterTag::lowercase(Alphabet::T),
            hashtags.into_iter().map(|s| s.into()),
        )
    }

    /// Add reference
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/12.md>
    #[inline]
    pub fn reference<S>(self, reference: S) -> Self
    where
        S: Into<String>,
    {
        self.custom_tag(SingleLetterTag::lowercase(Alphabet::R), [reference.into()])
    }

    /// Add references
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/12.md>
    #[inline]
    pub fn references<I, S>(self, references: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        self.custom_tag(
            SingleLetterTag::lowercase(Alphabet::R),
            references.into_iter().map(|s| s.into()),
        )
    }

    /// Remove references
    #[inline]
    pub fn remove_references<I, S>(self, references: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        self.remove_custom_tag(
            SingleLetterTag::lowercase(Alphabet::R),
            references.into_iter().map(|s| s.into()),
        )
    }

    /// Add identifier
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn identifier<S>(self, identifier: S) -> Self
    where
        S: Into<String>,
    {
        self.custom_tag(SingleLetterTag::lowercase(Alphabet::D), [identifier.into()])
    }

    /// Add identifiers
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn identifiers<I, S>(self, identifiers: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        self.custom_tag(
            SingleLetterTag::lowercase(Alphabet::D),
            identifiers.into_iter().map(|s| s.into()),
        )
    }

    /// Remove identifiers
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn remove_identifiers<I, S>(self, identifiers: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        self.remove_custom_tag(
            SingleLetterTag::lowercase(Alphabet::D),
            identifiers.into_iter().map(|s| s.into()),
        )
    }

    /// Add coordinate
    ///
    /// Query for `a` tag.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn coordinate(self, coordinate: &Coordinate) -> Self {
        self.custom_tag(
            SingleLetterTag::lowercase(Alphabet::A),
            [coordinate.to_string()],
        )
    }

    /// Add coordinates
    ///
    /// Query for `a` tags.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn coordinates<'a, I>(self, coordinates: I) -> Self
    where
        I: IntoIterator<Item = &'a Coordinate>,
    {
        self.custom_tag(
            SingleLetterTag::lowercase(Alphabet::A),
            coordinates.into_iter().map(|c| c.to_string()),
        )
    }

    /// Remove coordinates
    ///
    /// Remove `a` tags.
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/01.md>
    #[inline]
    pub fn remove_coordinates<'a, I>(self, coordinates: I) -> Self
    where
        I: IntoIterator<Item = &'a Coordinate>,
    {
        self.remove_custom_tag(
            SingleLetterTag::lowercase(Alphabet::A),
            coordinates.into_iter().map(|c| c.to_string()),
        )
    }

    /// Add search field
    #[inline]
    pub fn search<S>(mut self, value: S) -> Self
    where
        S: Into<String>,
    {
        self.search = Some(value.into());
        self
    }

    /// Remove search
    #[inline]
    pub fn remove_search(mut self) -> Self {
        self.search = None;
        self
    }

    /// Add since unix timestamp
    #[inline]
    pub fn since(mut self, since: Timestamp) -> Self {
        self.since = Some(since);
        self
    }

    /// Remove since
    #[inline]
    pub fn remove_since(mut self) -> Self {
        self.since = None;
        self
    }

    /// Add until unix timestamp
    #[inline]
    pub fn until(mut self, until: Timestamp) -> Self {
        self.until = Some(until);
        self
    }

    /// Remove until
    #[inline]
    pub fn remove_until(mut self) -> Self {
        self.until = None;
        self
    }

    /// Add limit
    ///
    /// Maximum number of events to be returned in the initial query
    #[inline]
    pub fn limit(mut self, limit: usize) -> Self {
        self.limit = Some(limit);
        self
    }

    /// Remove limit
    #[inline]
    pub fn remove_limit(mut self) -> Self {
        self.limit = None;
        self
    }

    /// Add custom tag
    pub fn custom_tag<I, S>(mut self, tag: SingleLetterTag, values: I) -> Self
    where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        let values: BTreeSet<String> = values.into_iter().map(|v| v.into()).collect();
        self.generic_tags.entry(tag).or_default().extend(values);
        self
    }

    /// Remove custom tag
    pub fn remove_custom_tag<I, T>(mut self, tag: SingleLetterTag, values: I) -> Self
    where
        I: IntoIterator<Item = T>,
        T: Into<String>,
    {
        let values = values.into_iter().map(|v| v.into());
        self.generic_tags.entry(tag).and_modify(|set| {
            for item in values {
                set.remove(&item);
            }
        });

        // Remove tag if empty
        if let Some(set) = self.generic_tags.get(&tag) {
            if set.is_empty() {
                self.generic_tags.remove(&tag);
            }
        }

        self
    }

    /// Check if [`Filter`] is empty
    #[inline]
    pub fn is_empty(&self) -> bool {
        self == &Filter::default()
    }

    /// Extract **all** public keys (both from `authors` and `#p`)
    pub fn extract_public_keys(&self) -> BTreeSet<PublicKey> {
        let mut public_keys: BTreeSet<PublicKey> = BTreeSet::new();

        if let Some(authors) = &self.authors {
            public_keys.extend(authors);
        }

        if let Some(p_tag) = self.generic_tags.get(&P_TAG) {
            public_keys.extend(p_tag.iter().filter_map(|p| PublicKey::from_hex(p).ok()));
        }

        public_keys
    }

    #[inline]
    fn ids_match(&self, event: &Event) -> bool {
        self.ids
            .as_ref()
            .map_or(true, |ids| ids.is_empty() || ids.contains(&event.id))
    }

    #[inline]
    fn authors_match(&self, event: &Event) -> bool {
        self.authors.as_ref().map_or(true, |authors| {
            authors.is_empty() || authors.contains(&event.pubkey)
        })
    }

    fn tag_match(&self, event: &Event) -> bool {
        if self.generic_tags.is_empty() {
            return true;
        }

        if event.tags.is_empty() {
            return false;
        }

        #[cfg(feature = "std")]
        let indexes: &TagsIndexes = event.tags.indexes();
        #[cfg(not(feature = "std"))]
        let indexes: TagsIndexes = event.tags.build_indexes();

        // Match
        self.generic_tags.iter().all(|(tag_name, set)| {
            if let Some(val_set) = indexes.get(tag_name) {
                set.iter().any(|t| val_set.contains(t))
            } else {
                false
            }
        })
    }

    #[inline]
    fn kind_match(&self, event: &Event) -> bool {
        self.kinds.as_ref().map_or(true, |kinds| {
            kinds.is_empty() || kinds.contains(&event.kind)
        })
    }

    #[inline]
    fn search_match(&self, event: &Event) -> bool {
        match &self.search {
            // TODO: best ways?
            Some(query) => event.content.to_lowercase().contains(&query.to_lowercase()),
            None => true,
        }
    }

    /// Determine if [Filter] match given [Event].
    #[inline]
    pub fn match_event(&self, event: &Event) -> bool {
        self.ids_match(event)
            && self.authors_match(event)
            && self.kind_match(event)
            && self.since.map_or(true, |t| event.created_at >= t)
            && self.until.map_or(true, |t| event.created_at <= t)
            && self.tag_match(event)
            && self.search_match(event)
    }
}

impl JsonUtil for Filter {
    type Err = serde_json::Error;
}

fn serialize_generic_tags<S>(generic_tags: &GenericTags, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    let mut map = serializer.serialize_map(Some(generic_tags.len()))?;
    for (tag, values) in generic_tags.iter() {
        map.serialize_entry(&format!("#{tag}"), values)?;
    }
    map.end()
}

fn deserialize_generic_tags<'de, D>(deserializer: D) -> Result<GenericTags, D::Error>
where
    D: Deserializer<'de>,
{
    struct GenericTagsVisitor;

    impl<'de> Visitor<'de> for GenericTagsVisitor {
        type Value = GenericTags;

        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("map in which the keys are \"#X\" for some character X")
        }

        fn visit_map<M>(self, mut map: M) -> Result<Self::Value, M::Error>
        where
            M: MapAccess<'de>,
        {
            let mut generic_tags = BTreeMap::new();
            while let Some(key) = map.next_key::<String>()? {
                let mut chars = key.chars();
                if let (Some('#'), Some(ch), None) = (chars.next(), chars.next(), chars.next()) {
                    let tag: SingleLetterTag =
                        SingleLetterTag::from_char(ch).map_err(serde::de::Error::custom)?;
                    let values: BTreeSet<String> = map.next_value()?;
                    generic_tags.insert(tag, values);
                } else {
                    map.next_value::<serde::de::IgnoredAny>()?;
                }
            }
            Ok(generic_tags)
        }
    }

    deserializer.deserialize_map(GenericTagsVisitor)
}

fn extend_or_collect<T, I>(mut set: Option<BTreeSet<T>>, iter: I) -> Option<BTreeSet<T>>
where
    I: IntoIterator<Item = T>,
    T: Eq + Ord + Hash,
{
    match set.as_mut() {
        Some(s) => {
            s.extend(iter);
        }
        None => set = Some(iter.into_iter().collect()),
    };
    set
}

/// Remove values from set
/// If after remove the set is empty, will be returned `None`
fn remove_or_none<T, I>(mut set: Option<BTreeSet<T>>, iter: I) -> Option<BTreeSet<T>>
where
    I: IntoIterator<Item = T>,
    T: Eq + Ord + Hash,
{
    if let Some(s) = set.as_mut() {
        for item in iter.into_iter() {
            s.remove(&item);
        }

        if s.is_empty() {
            set = None;
        }
    }
    set
}

#[cfg(test)]
mod tests {
    use bitcoin::secp256k1::schnorr::Signature;

    use super::*;
    use crate::Tag;

    #[test]
    fn test_kind_concatenation() {
        let filter = Filter::new()
            .kind(Kind::Metadata)
            .kind(Kind::TextNote)
            .kind(Kind::ContactList)
            .kinds([
                Kind::EncryptedDirectMessage,
                Kind::Metadata,
                Kind::LongFormTextNote,
            ]);
        assert_eq!(
            filter,
            Filter::new().kinds([
                Kind::Metadata,
                Kind::TextNote,
                Kind::ContactList,
                Kind::EncryptedDirectMessage,
                Kind::LongFormTextNote
            ])
        );
    }

    #[test]
    fn test_empty_filter_serialization() {
        let filter = Filter::new().authors([]);
        assert_eq!(filter.as_json(), r#"{"authors":[]}"#);

        let filter = Filter::new().pubkeys([]);
        assert_eq!(filter.as_json(), r##"{"#p":[]}"##);
    }

    #[test]
    fn test_remove() {
        let event_id =
            EventId::from_hex("70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5")
                .unwrap();

        // Test remove ids
        let filter = Filter::new().id(EventId::all_zeros()).id(event_id);
        let filter = filter.remove_ids([EventId::all_zeros()]);
        assert_eq!(filter, Filter::new().id(event_id));

        // Test remove #e tag
        let filter = Filter::new().events([EventId::all_zeros(), event_id]);
        let filter = filter.remove_events([EventId::all_zeros()]);
        assert_eq!(filter, Filter::new().event(event_id));
        let filter = filter.remove_events([event_id]);
        assert!(filter.is_empty());

        // Test remove #d tag
        let mut filter = Filter::new().identifier("myidentifier");
        filter = filter.custom_tag(SingleLetterTag::lowercase(Alphabet::D), ["mysecondid"]);
        filter = filter.identifiers(["test", "test2"]);
        filter = filter.remove_custom_tag(SingleLetterTag::lowercase(Alphabet::D), ["test2"]);
        filter = filter.remove_identifiers(["mysecondid"]);
        assert_eq!(filter, Filter::new().identifiers(["myidentifier", "test"]));

        // Test remove custom tag
        let filter =
            Filter::new().custom_tag(SingleLetterTag::lowercase(Alphabet::C), ["test", "test2"]);
        let filter = filter.remove_custom_tag(SingleLetterTag::lowercase(Alphabet::C), ["test2"]);
        assert_eq!(
            filter,
            Filter::new().custom_tag(SingleLetterTag::lowercase(Alphabet::C), ["test"])
        );
    }

    #[test]
    #[cfg(not(feature = "std"))]
    fn test_filter_serialization() {
        let filter = Filter::new()
            .identifier("identifier")
            .search("test")
            .custom_tag(SingleLetterTag::lowercase(Alphabet::J), ["test1"])
            .custom_tag(
                SingleLetterTag::lowercase(Alphabet::P),
                ["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"],
            )
            .custom_tag(SingleLetterTag::lowercase(Alphabet::Z), ["rating"]);
        let json = r##"{"search":"test","#d":["identifier"],"#j":["test1"],"#p":["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"],"#z":["rating"]}"##;
        assert_eq!(filter.as_json(), json);
    }

    #[test]
    fn test_filter_serialization_with_uppercase_tag() {
        let filter = Filter::new().custom_tag(
            SingleLetterTag::uppercase(Alphabet::P),
            ["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"],
        );
        let json =
            r##"{"#P":["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"]}"##;
        assert_eq!(filter.as_json(), json);
    }

    #[test]
    fn test_filter_deserialization() {
        let json = r##"{"#a":["...", "test"],"#e":["70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5"],"#p":["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"],"search":"test","ids":["70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5"]}"##;
        let filter = Filter::from_json(json).unwrap();
        let event_id =
            EventId::from_hex("70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5")
                .unwrap();
        let pubkey =
            PublicKey::from_hex("379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe")
                .unwrap();

        // Check IDs
        assert!(filter.ids.unwrap().contains(&event_id));
        assert_eq!(filter.search, Some(String::from("test")));

        // Check #e tag
        let set = filter
            .generic_tags
            .get(&SingleLetterTag {
                character: Alphabet::E,
                uppercase: false,
            })
            .unwrap();
        assert!(set.contains(&event_id.to_hex()));

        // Check #p tag
        let set = filter
            .generic_tags
            .get(&SingleLetterTag {
                character: Alphabet::P,
                uppercase: false,
            })
            .unwrap();
        assert!(set.contains(&pubkey.to_hex()));

        // Check #a tag
        let set = filter
            .generic_tags
            .get(&SingleLetterTag {
                character: Alphabet::A,
                uppercase: false,
            })
            .unwrap();
        assert!(set.contains("..."));
        assert!(set.contains("test"));

        let json = r##"{"#":["..."],"search":"test"}"##;
        let filter = Filter::from_json(json).unwrap();
        assert_eq!(filter, Filter::new().search("test"));

        let json = r##"{"aa":["..."],"search":"test"}"##;
        let filter = Filter::from_json(json).unwrap();
        assert_eq!(filter, Filter::new().search("test"));
    }

    #[test]
    fn test_filter_is_empty() {
        let filter = Filter::new().identifier("test");
        assert!(!filter.is_empty());

        let filter = Filter::new();
        assert!(filter.is_empty());
    }

    #[test]
    fn test_match_event() {
        let event_id =
            EventId::from_hex("70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5")
                .unwrap();
        let pubkey =
            PublicKey::from_str("379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe")
                .unwrap();
        let event =
            Event::new(
                event_id,
                pubkey,
                Timestamp::from(1612809991),
                Kind::TextNote,
                [
                    Tag::public_key(PublicKey::from_str("b2d670de53b27691c0c3400225b65c35a26d06093bcc41f48ffc71e0907f9d4a").unwrap()),
                    Tag::event(EventId::from_hex("7469af3be8c8e06e1b50ef1caceba30392ddc0b6614507398b7d7daa4c218e96").unwrap()),
                ],
                "test",
                Signature::from_str("273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502").unwrap(),
            );
        let event_with_empty_tags: Event = Event::new(
            event_id,
            pubkey,
            Timestamp::from(1612809992),
            Kind::TextNote,
            [],
            "test",
            Signature::from_str("273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502").unwrap(),
          );

        // ID match
        let filter: Filter = Filter::new().id(event_id);
        assert!(filter.match_event(&event));

        // Not match (kind)
        let filter: Filter = Filter::new().id(event_id).kind(Kind::Metadata);
        assert!(!filter.match_event(&event));

        // Match (author, kind and since)
        let filter: Filter = Filter::new()
            .author(pubkey)
            .kind(Kind::TextNote)
            .since(Timestamp::from(1612808000));
        assert!(filter.match_event(&event));

        // Not match (since)
        let filter: Filter = Filter::new()
            .author(pubkey)
            .kind(Kind::TextNote)
            .since(Timestamp::from(1700000000));
        assert!(!filter.match_event(&event));

        // Match (#p tag and kind)
        let filter: Filter = Filter::new()
            .pubkey(
                PublicKey::from_str(
                    "b2d670de53b27691c0c3400225b65c35a26d06093bcc41f48ffc71e0907f9d4a",
                )
                .unwrap(),
            )
            .kind(Kind::TextNote);
        assert!(filter.match_event(&event));

        // Match (tags)
        let filter: Filter = Filter::new()
            .pubkey(
                PublicKey::from_str(
                    "b2d670de53b27691c0c3400225b65c35a26d06093bcc41f48ffc71e0907f9d4a",
                )
                .unwrap(),
            )
            .event(
                EventId::from_hex(
                    "7469af3be8c8e06e1b50ef1caceba30392ddc0b6614507398b7d7daa4c218e96",
                )
                .unwrap(),
            );
        assert!(filter.match_event(&event));

        // Match (tags)
        let filter: Filter = Filter::new().events(vec![
            EventId::from_hex("7469af3be8c8e06e1b50ef1caceba30392ddc0b6614507398b7d7daa4c218e96")
                .unwrap(),
            EventId::from_hex("70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5")
                .unwrap(),
        ]);
        assert!(filter.match_event(&event));

        // Not match (tags)
        let filter: Filter = Filter::new().events(vec![EventId::from_hex(
            "70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5",
        )
        .unwrap()]);
        assert!(!filter.match_event(&event));

        // Not match (tags filter for events with empty tags)
        let filter: Filter = Filter::new().hashtag("this-should-not-match");
        assert!(!filter.match_event(&event));
        assert!(!filter.match_event(&event_with_empty_tags));

        // Test match search
        let filter: Filter = Filter::new().search("test");
        assert!(filter.match_event(&event));
    }

    #[test]
    fn test_filter_search_match_event() {
        let json: &str = r#"{
              "id": "3d1e30c357eba92568ba67138f9a508d29b306e5254952ee4d7c8039bd4a48fa",
              "pubkey": "68d81165918100b7da43fc28f7d1fc12554466e1115886b9e7bb326f65ec4272",
              "created_at": 1711027680,
              "kind": 0,
              "tags": [
                [
                  "alt",
                  "User profile for Yuki Kishimoto"
                ],
                [
                  "i",
                  "github:yukibtc",
                  "69d9980b6e6b5d77a3e1e369ccaca9ba"
                ]
              ],
              "content": "{\"banner\":\"https://i.imgur.com/f1h1GgJ.jpg\",\"website\":\"https://yukikishimoto.com\",\"nip05\":\"_@yukikishimoto.com\",\"picture\":\"https://yukikishimoto.com/images/avatar.jpg\",\"lud16\":\"pay@yukikishimoto.com\",\"display_name\":\"Yuki Kishimoto\",\"about\":\"GitHub: https://github.com/yukibtc\\nPGP: 86F3 105A DFA8 AB58 7268  DCD7 8D3D CD04 2496 19D1\",\"name\":\"Yuki Kishimoto\",\"displayName\":\"Yuki Kishimoto\"}",
              "sig": "27dddf90036cb7ea893eb13827342c49cbb72c442b3ac7b1f09081868b752d4c6e85882a881599e02a1374d4825e492e81703d44bce9728adccf66bb49f14220"
            }
        "#;
        let event = Event::from_json(json).unwrap();

        let filter = Filter::new().search("Yuki kishi");
        assert!(filter.match_event(&event));
    }
}

#[cfg(bench)]
mod benches {
    use core::str::FromStr;

    use bitcoin::secp256k1::schnorr::Signature;
    use test::{black_box, Bencher};

    use super::*;
    use crate::{Tag, TagStandard};

    #[bench]
    pub fn filter_match_event(bh: &mut Bencher) {
        // Event
        let event =
            Event::new(
                EventId::from_hex("70b10f70c1318967eddf12527799411b1a9780ad9c43858f5e5fcd45486a13a5")
                .unwrap(),
                PublicKey::from_hex("379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe")
                .unwrap(),
                Timestamp::from(1612809991),
                Kind::TextNote,
                [
                    Tag::public_key(PublicKey::from_hex("b2d670de53b27691c0c3400225b65c35a26d06093bcc41f48ffc71e0907f9d4a").unwrap()),
                    Tag::public_key(PublicKey::from_hex("379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe").unwrap()),
                    Tag::event(EventId::from_hex("7469af3be8c8e06e1b50ef1caceba30392ddc0b6614507398b7d7daa4c218e96").unwrap()),
                    Tag::from_standardized(TagStandard::Kind(Kind::TextNote)),
                ],
                "test",
                Signature::from_str("273a9cd5d11455590f4359500bccb7a89428262b96b3ea87a756b770964472f8c3e87f5d5e64d8d2e859a71462a3f477b554565c4f2f326cb01dd7620db71502").unwrap(),
            );

        // Filter
        let pk =
            PublicKey::from_hex("b2d670de53b27691c0c3400225b65c35a26d06093bcc41f48ffc71e0907f9d4a")
                .unwrap();
        let filter = Filter::new().pubkey(pk).kind(Kind::TextNote);

        bh.iter(|| {
            black_box(filter.match_event(&event));
        });
    }
}

================
File: src/types/image.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Image

use core::fmt;
use core::num::ParseIntError;
use core::str::{FromStr, Split};

#[derive(Debug, PartialEq, Eq)]
/// Image error
pub enum Error {
    /// Impossible to parse integer
    ParseIntError(ParseIntError),
    /// Invalid Image Dimensions
    InvalidImageDimensions,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::ParseIntError(e) => write!(f, "Parse integer: {e}"),
            Self::InvalidImageDimensions => write!(f, "Invalid image dimensions"),
        }
    }
}

impl From<ParseIntError> for Error {
    fn from(e: ParseIntError) -> Self {
        Self::ParseIntError(e)
    }
}

/// Simple struct to hold `width` x `height`.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ImageDimensions {
    /// Width
    pub width: u64,
    /// Height
    pub height: u64,
}

impl ImageDimensions {
    /// Net image dimensions
    #[inline]
    pub fn new(width: u64, height: u64) -> Self {
        Self { width, height }
    }
}

impl FromStr for ImageDimensions {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let mut spitted: Split<char> = s.split('x');
        if let (Some(width), Some(height)) = (spitted.next(), spitted.next()) {
            Ok(Self::new(width.parse()?, height.parse()?))
        } else {
            Err(Error::InvalidImageDimensions)
        }
    }
}

impl fmt::Display for ImageDimensions {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}x{}", self.width, self.height)
    }
}

================
File: src/types/metadata.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Metadata

#[cfg(not(feature = "std"))]
use alloc::collections::BTreeMap as AllocMap;
use alloc::string::String;
use core::fmt;
#[cfg(feature = "std")]
use std::collections::HashMap as AllocMap;

use serde::de::{Deserializer, MapAccess, Visitor};
use serde::ser::{SerializeMap, Serializer};
use serde::{Deserialize, Serialize};
use serde_json::Value;

use crate::{JsonUtil, Url};

/// [`Metadata`] error
#[derive(Debug)]
pub enum Error {
    /// Error serializing or deserializing JSON data
    Json(serde_json::Error),
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Json(e) => write!(f, "Json: {e}"),
        }
    }
}

impl From<serde_json::Error> for Error {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e)
    }
}

/// Metadata
#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct Metadata {
    /// Name
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub name: Option<String>,
    /// Display name
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub display_name: Option<String>,
    /// Description
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub about: Option<String>,
    /// Website url
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub website: Option<String>,
    /// Picture url
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub picture: Option<String>,
    /// Banner url
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub banner: Option<String>,
    /// NIP05 (ex. name@example.com)
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub nip05: Option<String>,
    /// LNURL
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub lud06: Option<String>,
    /// Lightning Address
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub lud16: Option<String>,
    /// Custom fields
    #[serde(
        flatten,
        serialize_with = "serialize_custom_fields",
        deserialize_with = "deserialize_custom_fields"
    )]
    #[serde(default)]
    pub custom: AllocMap<String, Value>,
}

impl Metadata {
    /// New empty [`Metadata`]
    #[inline]
    pub fn new() -> Self {
        Self::default()
    }

    /// Set name
    pub fn name<S>(self, name: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            name: Some(name.into()),
            ..self
        }
    }

    /// Set display name
    pub fn display_name<S>(self, display_name: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            display_name: Some(display_name.into()),
            ..self
        }
    }

    /// Set about
    pub fn about<S>(self, about: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            about: Some(about.into()),
            ..self
        }
    }

    /// Set website
    pub fn website(self, url: Url) -> Self {
        Self {
            website: Some(url.into()),
            ..self
        }
    }

    /// Set picture
    pub fn picture(self, url: Url) -> Self {
        Self {
            picture: Some(url.into()),
            ..self
        }
    }

    /// Set banner
    pub fn banner(self, url: Url) -> Self {
        Self {
            banner: Some(url.into()),
            ..self
        }
    }

    /// Set nip05
    pub fn nip05<S>(self, nip05: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            nip05: Some(nip05.into()),
            ..self
        }
    }

    /// Set lud06 (LNURL)
    pub fn lud06<S>(self, lud06: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            lud06: Some(lud06.into()),
            ..self
        }
    }

    /// Set lud16 (Lightning Address)
    pub fn lud16<S>(self, lud16: S) -> Self
    where
        S: Into<String>,
    {
        Self {
            lud16: Some(lud16.into()),
            ..self
        }
    }

    /// Set custom metadata field
    pub fn custom_field<K, S>(mut self, field_name: K, value: S) -> Self
    where
        K: Into<String>,
        S: Into<Value>,
    {
        self.custom.insert(field_name.into(), value.into());
        self
    }
}

impl JsonUtil for Metadata {
    type Err = Error;
}

fn serialize_custom_fields<S>(
    custom_fields: &AllocMap<String, Value>,
    serializer: S,
) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    let mut map = serializer.serialize_map(Some(custom_fields.len()))?;
    for (field_name, value) in custom_fields {
        map.serialize_entry(field_name, value)?;
    }
    map.end()
}

fn deserialize_custom_fields<'de, D>(deserializer: D) -> Result<AllocMap<String, Value>, D::Error>
where
    D: Deserializer<'de>,
{
    struct GenericTagsVisitor;

    impl<'de> Visitor<'de> for GenericTagsVisitor {
        type Value = AllocMap<String, Value>;

        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("map where keys are strings and values are valid json")
        }

        fn visit_map<M>(self, mut map: M) -> Result<Self::Value, M::Error>
        where
            M: MapAccess<'de>,
        {
            #[cfg(not(feature = "std"))]
            let mut custom_fields: AllocMap<String, Value> = AllocMap::new();
            #[cfg(feature = "std")]
            let mut custom_fields: AllocMap<String, Value> =
                AllocMap::with_capacity(map.size_hint().unwrap_or_default());
            while let Some(field_name) = map.next_key::<String>()? {
                if let Ok(value) = map.next_value::<Value>() {
                    custom_fields.insert(field_name, value);
                }
            }
            Ok(custom_fields)
        }
    }

    deserializer.deserialize_map(GenericTagsVisitor)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deserialize_metadata() {
        let content = r#"{"name":"myname","about":"Description","display_name":""}"#;
        let metadata = Metadata::from_json(content).unwrap();
        assert_eq!(
            metadata,
            Metadata::new()
                .name("myname")
                .about("Description")
                .display_name("")
        );

        let content = r#"{"name":"myname","about":"Description","displayName":"Jack"}"#;
        let metadata = Metadata::from_json(content).unwrap();
        assert_eq!(
            metadata,
            Metadata::new()
                .name("myname")
                .about("Description")
                .custom_field("displayName", "Jack")
        );

        let content = r#"{"lud16":"thesimplekid@cln.thesimplekid.com","nip05":"_@thesimplekid.com","display_name":"thesimplekid","about":"Wannabe open source dev","name":"thesimplekid","username":"thesimplekid","displayName":"thesimplekid","lud06":"","reactions":false,"damus_donation_v2":0}"#;
        let metadata = Metadata::from_json(content).unwrap();
        assert_eq!(
            metadata,
            Metadata::new()
                .name("thesimplekid")
                .display_name("thesimplekid")
                .about("Wannabe open source dev")
                .nip05("_@thesimplekid.com")
                .lud06("")
                .lud16("thesimplekid@cln.thesimplekid.com")
                .custom_field("username", "thesimplekid")
                .custom_field("displayName", "thesimplekid")
                .custom_field("reactions", false)
                .custom_field("damus_donation_v2", 0)
        );
        assert_eq!(metadata, Metadata::from_json(metadata.as_json()).unwrap());
    }
}

================
File: src/types/mod.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Types

#![allow(unknown_lints)]
#![allow(ambiguous_glob_reexports)]

pub mod contact;
pub mod filter;
pub mod image;
pub mod metadata;
pub mod time;
pub mod url;

pub use self::contact::*;
pub use self::filter::*;
pub use self::image::*;
pub use self::metadata::*;
pub use self::time::*;
pub use self::url::*;

================
File: src/types/url.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Urls

use alloc::string::{String, ToString};
use core::convert::Infallible;
use core::fmt;
use core::str::FromStr;

use serde::{Deserialize, Deserializer, Serialize, Serializer};
#[cfg(feature = "std")]
pub use url::*;
#[cfg(not(feature = "std"))]
pub use url_fork::*;

/// Relay URL error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Url parse error
    Url(ParseError),
    /// Unsupported URL scheme
    UnsupportedScheme(String),
    /// Multiple scheme separators
    MultipleSchemeSeparators,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Url(e) => write!(f, "{e}"),
            Self::UnsupportedScheme(scheme) => write!(f, "Unsupported scheme: {scheme}"),
            Self::MultipleSchemeSeparators => write!(f, "Multiple scheme separators"),
        }
    }
}

impl From<ParseError> for Error {
    fn from(e: ParseError) -> Self {
        Self::Url(e)
    }
}

/// Relay URL
#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RelayUrl {
    url: Url,
    has_trailing_slash: bool,
}

impl fmt::Debug for RelayUrl {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let url: &str = self.as_str();
        f.debug_tuple("RelayUrl").field(&url).finish()
    }
}

impl RelayUrl {
    /// Parse relay URL
    #[inline]
    pub fn parse<S>(url: S) -> Result<Self, Error>
    where
        S: AsRef<str>,
    {
        let url: &str = url.as_ref();

        // Check that "://" appears only once in the URL
        if url.matches("://").count() > 1 {
            return Err(Error::MultipleSchemeSeparators);
        }

        // Check if has trailing slash
        let has_trailing_slash: bool = url.ends_with('/');

        // Parse URL
        let url: Url = Url::parse(url)?;

        // Check scheme
        match url.scheme() {
            "ws" | "wss" => Ok(Self {
                url,
                has_trailing_slash,
            }),
            scheme => Err(Error::UnsupportedScheme(scheme.to_string())),
        }
    }

    /// Check if the URL is a hidden onion service address
    #[inline]
    pub fn is_onion(&self) -> bool {
        self.url
            .domain()
            .map_or(false, |host| host.ends_with(".onion"))
    }

    /// Return the serialization of this relay URL without the trailing slash.
    ///
    /// This method will always remove the trailing slash.
    #[inline]
    pub fn as_str_without_trailing_slash(&self) -> &str {
        self.url.as_str().trim_end_matches('/')
    }

    /// Return the serialization of this relay URL.
    ///
    /// The trailing slash will be removed only if the parsed URL hadn't it.
    #[inline]
    pub fn as_str(&self) -> &str {
        if !self.has_trailing_slash {
            return self.as_str_without_trailing_slash();
        }

        self.url.as_str()
    }
}

impl fmt::Display for RelayUrl {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl FromStr for RelayUrl {
    type Err = Error;

    fn from_str(relay_url: &str) -> Result<Self, Self::Err> {
        Self::parse(relay_url)
    }
}

impl Serialize for RelayUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.as_str())
    }
}

impl<'de> Deserialize<'de> for RelayUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let url: String = String::deserialize(deserializer)?;
        Self::parse(url).map_err(serde::de::Error::custom)
    }
}

impl From<RelayUrl> for Url {
    fn from(relay_url: RelayUrl) -> Self {
        relay_url.url
    }
}

impl<'a> From<&'a RelayUrl> for &'a Url {
    fn from(relay_url: &'a RelayUrl) -> Self {
        &relay_url.url
    }
}

/// Try into relay URL
pub trait TryIntoUrl {
    /// Error
    type Err: fmt::Debug;

    /// Try into relay URL
    fn try_into_url(self) -> Result<RelayUrl, Self::Err>;
}

impl TryIntoUrl for RelayUrl {
    type Err = Infallible;

    #[inline]
    fn try_into_url(self) -> Result<RelayUrl, Self::Err> {
        Ok(self)
    }
}

impl TryIntoUrl for &RelayUrl {
    type Err = Infallible;

    #[inline]
    fn try_into_url(self) -> Result<RelayUrl, Self::Err> {
        Ok(self.clone())
    }
}

impl TryIntoUrl for Url {
    type Err = Error;

    #[inline]
    fn try_into_url(self) -> Result<RelayUrl, Self::Err> {
        RelayUrl::parse(self.as_str())
    }
}

impl TryIntoUrl for &Url {
    type Err = Error;

    #[inline]
    fn try_into_url(self) -> Result<RelayUrl, Self::Err> {
        RelayUrl::parse(self.as_str())
    }
}

impl TryIntoUrl for String {
    type Err = Error;

    #[inline]
    fn try_into_url(self) -> Result<RelayUrl, Self::Err> {
        RelayUrl::parse(self)
    }
}

impl TryIntoUrl for &String {
    type Err = Error;

    #[inline]
    fn try_into_url(self) -> Result<RelayUrl, Self::Err> {
        RelayUrl::parse(self)
    }
}

impl TryIntoUrl for &str {
    type Err = Error;

    #[inline]
    fn try_into_url(self) -> Result<RelayUrl, Self::Err> {
        RelayUrl::parse(self)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_relay_url_valid() {
        assert!(RelayUrl::parse("ws://127.0.0.1:7777").is_ok());
        assert!(RelayUrl::parse("wss://relay.damus.io").is_ok());
        assert!(RelayUrl::parse("ws://example.com").is_ok());
        assert!(RelayUrl::parse("wss://example.com/path/to/resource").is_ok());
    }

    #[test]
    fn test_relay_url_invalid() {
        assert_eq!(
            RelayUrl::parse("https://relay.damus.io").unwrap_err(),
            Error::UnsupportedScheme(String::from("https"))
        );
        assert_eq!(
            RelayUrl::parse("ftp://relay.damus.io").unwrap_err(),
            Error::UnsupportedScheme(String::from("ftp"))
        );
        assert_eq!(
            RelayUrl::parse("wss://relay.damus.io,ws://127.0.0.1:7777").unwrap_err(),
            Error::MultipleSchemeSeparators
        );
        assert_eq!(
            RelayUrl::parse("wss://relay.damus.iowss://127.0.0.1:8888").unwrap_err(),
            Error::MultipleSchemeSeparators
        );
        assert_eq!(
            RelayUrl::parse("wss://").unwrap_err(),
            Error::Url(ParseError::EmptyHost)
        );
    }

    #[test]
    fn test_relay_url_as_str() {
        let relay_url = RelayUrl::parse("ws://example.com").unwrap();
        assert_eq!(relay_url.as_str(), "ws://example.com");

        let relay_url = RelayUrl::parse("ws://example.com/").unwrap();
        assert_eq!(relay_url.as_str(), "ws://example.com/");

        let relay_url = RelayUrl::parse("ws://example.com/").unwrap();
        assert_eq!(
            relay_url.as_str_without_trailing_slash(),
            "ws://example.com"
        );
    }

    #[test]
    fn test_relay_url_from_str() {
        let relay_url: Result<RelayUrl, _> = "ws://example.com".parse();
        assert!(relay_url.is_ok());
    }

    #[test]
    fn test_serde_relay_url() {
        let relay_url = RelayUrl::parse("ws://example.com").unwrap();
        let serialized = serde_json::to_string(&relay_url).unwrap();
        let deserialized: RelayUrl = serde_json::from_str(&serialized).unwrap();
        assert_eq!(relay_url, deserialized);
    }

    #[test]
    fn test_is_onion() {
        // Onion
        let onion_url =
            RelayUrl::parse("ws://oxtrdevav64z64yb7x6rjg4ntzqjhedm5b5zjqulugknhzr46ny2qbad.onion")
                .unwrap();
        assert!(onion_url.is_onion());

        // Non onion
        let non_onion_url = RelayUrl::parse("wss://relay.damus.io").unwrap();
        assert!(!non_onion_url.is_onion());
        let non_onion_url = RelayUrl::parse("ws://example.com:81").unwrap();
        assert!(!non_onion_url.is_onion());
        let non_onion_url = RelayUrl::parse("ws://127.0.0.1:7777").unwrap();
        assert!(!non_onion_url.is_onion());
    }
}

================
File: src/util/hex.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Hex

use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;

/// Hex error
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// An invalid character was found
    InvalidHexCharacter {
        /// Char
        c: char,
        /// Char index
        index: usize,
    },
    /// A hex string's length needs to be even, as two digits correspond to one byte.
    OddLength,
    /// Invalid len
    InvalidLength,
}

#[cfg(feature = "std")]
impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidHexCharacter { c, index } => {
                write!(f, "Invalid character {} at position {}", c, index)
            }
            Self::OddLength => write!(f, "Odd number of digits"),
            Self::InvalidLength => write!(f, "Invalid length"),
        }
    }
}

#[inline]
const fn from_digit(num: u8) -> u8 {
    if num < 10 {
        b'0' + num
    } else {
        b'a' + num - 10
    }
}

/// Hex encode
#[inline]
pub fn encode<T>(data: T) -> String
where
    T: AsRef<[u8]>,
{
    let bytes: &[u8] = data.as_ref();
    let mut hex: String = String::with_capacity(2 * bytes.len());
    for byte in bytes.iter() {
        hex.push(from_digit(byte >> 4) as char);
        hex.push(from_digit(byte & 0xF) as char);
    }
    hex
}

/// Hex decode
#[inline]
pub fn decode<T>(hex: T) -> Result<Vec<u8>, Error>
where
    T: AsRef<[u8]>,
{
    let hex: &[u8] = hex.as_ref();
    let len: usize = hex.len();

    let mut bytes: Vec<u8> = vec![0u8; len / 2];
    decode_to_slice(hex, &mut bytes)?;
    Ok(bytes)
}

/// Hex decode to slice
#[inline]
pub fn decode_to_slice<T>(hex: T, out: &mut [u8]) -> Result<(), Error>
where
    T: AsRef<[u8]>,
{
    let hex: &[u8] = hex.as_ref();
    let hex_len: usize = hex.len();

    if hex_len % 2 != 0 {
        return Err(Error::OddLength);
    }

    if hex_len / 2 != out.len() {
        return Err(Error::InvalidLength);
    }

    for (i, byte) in out.iter_mut().enumerate() {
        let high_idx: usize = i * 2;
        let high: u8 = val(hex[high_idx], high_idx)?;

        let low_idx: usize = high_idx + 1;
        let low: u8 = val(hex[low_idx], low_idx)?;

        *byte = high << 4 | low;
    }

    Ok(())
}

#[inline]
const fn val(c: u8, idx: usize) -> Result<u8, Error> {
    match c {
        b'A'..=b'F' => Ok(c - b'A' + 10),
        b'a'..=b'f' => Ok(c - b'a' + 10),
        b'0'..=b'9' => Ok(c - b'0'),
        _ => Err(Error::InvalidHexCharacter {
            c: c as char,
            index: idx,
        }),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode() {
        assert_eq!(encode("foobar"), "666f6f626172");
    }

    #[test]
    fn test_decode() {
        assert_eq!(
            decode("666f6f626172"),
            Ok(String::from("foobar").into_bytes())
        );
    }

    #[test]
    pub fn test_invalid_length() {
        assert_eq!(decode("1").unwrap_err(), Error::OddLength);
        assert_eq!(decode("666f6f6261721").unwrap_err(), Error::OddLength);
    }

    #[test]
    pub fn test_invalid_char() {
        assert_eq!(
            decode("66ag").unwrap_err(),
            Error::InvalidHexCharacter { c: 'g', index: 3 }
        );
    }
}

#[cfg(bench)]
mod benches {
    use super::*;
    use crate::test::{black_box, Bencher};

    const EVENT_JSON: &str = r#"{"content":"uRuvYr585B80L6rSJiHocw==?iv=oh6LVqdsYYol3JfFnXTbPA==","created_at":1640839235,"id":"2be17aa3031bdcb006f0fce80c146dea9c1c0268b0af2398bb673365c6444d45","kind":4,"pubkey":"f86c44a2de95d9149b51c6a29afeabba264c18e2fa7c49de93424a0c56947785","sig":"a5d9290ef9659083c490b303eb7ee41356d8778ff19f2f91776c8dc4443388a64ffcf336e61af4c25c05ac3ae952d1ced889ed655b67790891222aaa15b99fdd","tags":[["p","13adc511de7e1cfcf1c6b7f6365fb5a03442d7bcacf565ea57fa7770912c023d"]]}"#;

    #[bench]
    pub fn hex_encode(bh: &mut Bencher) {
        bh.iter(|| {
            black_box(encode(EVENT_JSON));
        });
    }

    #[bench]
    pub fn hex_decode(bh: &mut Bencher) {
        let h = "7b22636f6e74656e74223a227552757659723538354238304c3672534a69486f63773d3d3f69763d6f68364c5671647359596f6c334a66466e58546250413d3d222c22637265617465645f6174223a313634303833393233352c226964223a2232626531376161333033316264636230303666306663653830633134366465613963316330323638623061663233393862623637333336356336343434643435222c226b696e64223a342c227075626b6579223a2266383663343461326465393564393134396235316336613239616665616262613236346331386532666137633439646539333432346130633536393437373835222c22736967223a226135643932393065663936353930383363343930623330336562376565343133353664383737386666313966326639313737366338646334343433333838613634666663663333366536316166346332356330356163336165393532643163656438383965643635356236373739303839313232326161613135623939666464222c2274616773223a5b5b2270222c2231336164633531316465376531636663663163366237663633363566623561303334343264376263616366353635656135376661373737303931326330323364225d5d7d";
        bh.iter(|| {
            black_box(decode(h)).unwrap();
        });
    }
}

================
File: src/util/hkdf.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! HKDF Util

use alloc::vec::Vec;

use bitcoin::hashes::hmac::{Hmac, HmacEngine};
use bitcoin::hashes::sha256::Hash as Sha256Hash;
use bitcoin::hashes::{Hash, HashEngine};

/// HKDF extract
#[inline]
pub fn extract(salt: &[u8], input_key_material: &[u8]) -> Hmac<Sha256Hash> {
    let mut engine: HmacEngine<Sha256Hash> = HmacEngine::new(salt);
    engine.input(input_key_material);
    Hmac::from_engine(engine)
}

/// HKDF expand
pub fn expand(prk: &[u8], info: &[u8], output_len: usize) -> Vec<u8> {
    let mut output: Vec<u8> = Vec::with_capacity(output_len);
    let mut t: Vec<u8> = Vec::with_capacity(32);

    let mut i: u8 = 1u8;
    while output.len() < output_len {
        let mut engine: HmacEngine<Sha256Hash> = HmacEngine::new(prk);

        if !t.is_empty() {
            engine.input(&t);
        }

        engine.input(info);
        engine.input(&[i]);

        t = Hmac::from_engine(engine).to_byte_array().to_vec();
        output.extend_from_slice(&t);

        i += 1;
    }

    output.truncate(output_len);
    output
}

================
File: src/util/mod.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Util

use alloc::string::String;

#[cfg(feature = "std")]
use bitcoin::secp256k1::rand::rngs::OsRng;
use bitcoin::secp256k1::{ecdh, Parity, PublicKey as NormalizedPublicKey};
#[cfg(feature = "std")]
use bitcoin::secp256k1::{All, Secp256k1};
#[cfg(feature = "std")]
use once_cell::sync::Lazy; // TODO: use `std::sync::LazyLock` when MSRV >= 1.80.0
use serde::de::DeserializeOwned;
use serde::Serialize;

pub mod hex;
#[cfg(feature = "nip44")]
pub mod hkdf;

use crate::nips::nip01::Coordinate;
use crate::{EventId, PublicKey, SecretKey, Tag};

/// Generate shared key
///
/// **Important: use of a strong cryptographic hash function may be critical to security! Do NOT use
/// unless you understand cryptographical implications.**
pub fn generate_shared_key(secret_key: &SecretKey, public_key: &PublicKey) -> [u8; 32] {
    let public_key_normalized: NormalizedPublicKey =
        NormalizedPublicKey::from_x_only_public_key(**public_key, Parity::Even);
    let ssp: [u8; 64] = ecdh::shared_secret_point(&public_key_normalized, secret_key);
    let mut shared_key: [u8; 32] = [0u8; 32];
    shared_key.copy_from_slice(&ssp[..32]);
    shared_key
}

/// Secp256k1 global context
#[cfg(feature = "std")]
pub static SECP256K1: Lazy<Secp256k1<All>> = Lazy::new(|| {
    let mut ctx = Secp256k1::new();
    ctx.randomize(&mut OsRng);
    ctx
});

/// JSON util
pub trait JsonUtil: Sized + Serialize + DeserializeOwned
where
    <Self as JsonUtil>::Err: From<serde_json::Error>,
{
    /// Error
    type Err;

    /// Deserialize JSON
    #[inline]
    fn from_json<T>(json: T) -> Result<Self, Self::Err>
    where
        T: AsRef<[u8]>,
    {
        Ok(serde_json::from_slice(json.as_ref())?)
    }

    /// Serialize as JSON string
    ///
    /// This method could panic! Use `try_as_json` for error propagation.
    #[inline]
    fn as_json(&self) -> String {
        serde_json::to_string(self).unwrap()
    }

    /// Serialize as JSON string
    #[inline]
    fn try_as_json(&self) -> Result<String, Self::Err> {
        Ok(serde_json::to_string(self)?)
    }

    /// Serialize as pretty JSON string
    ///
    /// This method could panic! Use `try_as_pretty_json` for error propagation.
    #[inline]
    fn as_pretty_json(&self) -> String {
        serde_json::to_string_pretty(self).unwrap()
    }

    /// Serialize as pretty JSON string
    #[inline]
    fn try_as_pretty_json(&self) -> Result<String, Self::Err> {
        Ok(serde_json::to_string_pretty(self)?)
    }
}

/// Event ID or Coordinate
pub enum EventIdOrCoordinate {
    /// Event ID
    Id(EventId),
    /// Event Coordinate (`a` tag)
    Coordinate(Coordinate),
}

impl From<EventIdOrCoordinate> for Tag {
    fn from(value: EventIdOrCoordinate) -> Self {
        match value {
            EventIdOrCoordinate::Id(id) => id.into(),
            EventIdOrCoordinate::Coordinate(a) => a.into(),
        }
    }
}

impl From<EventId> for EventIdOrCoordinate {
    fn from(id: EventId) -> Self {
        Self::Id(id)
    }
}

impl From<Coordinate> for EventIdOrCoordinate {
    fn from(coordinate: Coordinate) -> Self {
        Self::Coordinate(coordinate)
    }
}

================
File: src/lib.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Rust implementation of the Nostr protocol.

#![forbid(unsafe_code)]
#![warn(missing_docs)]
#![warn(rustdoc::bare_urls)]
#![allow(unknown_lints)] // TODO: remove when MSRV >= 1.72.0, required for `clippy::arc_with_non_send_sync`
#![allow(clippy::arc_with_non_send_sync)]
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(bench, feature(test))]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![cfg_attr(all(feature = "std", feature = "all-nips"), doc = include_str!("../README.md"))]

#[cfg(not(any(feature = "std", feature = "alloc")))]
compile_error!("at least one of the `std` or `alloc` features must be enabled");

#[cfg(bench)]
extern crate test;

#[cfg(feature = "std")]
#[macro_use]
extern crate std;

#[macro_use]
extern crate alloc;

#[macro_use]
extern crate serde;

#[doc(hidden)]
#[cfg(any(feature = "nip04", feature = "nip44"))]
pub use base64;
#[doc(hidden)]
#[cfg(feature = "nip06")]
pub use bip39;
#[doc(hidden)]
pub use bitcoin::{self, hashes, secp256k1};
#[doc(hidden)]
pub use serde_json;

pub mod event;
pub mod key;
pub mod message;
pub mod nips;
pub mod prelude;
pub mod signer;
pub mod types;
pub mod util;

#[doc(hidden)]
pub use self::event::tag::{Tag, TagKind, TagStandard, Tags};
#[doc(hidden)]
pub use self::event::{
    Event, EventBuilder, EventId, Kind, MissingPartialEvent, PartialEvent, UnsignedEvent,
};
#[doc(hidden)]
pub use self::key::{Keys, PublicKey, SecretKey};
#[doc(hidden)]
pub use self::message::{ClientMessage, RawRelayMessage, RelayMessage, SubscriptionId};
#[doc(hidden)]
pub use self::nips::nip19::{FromBech32, ToBech32};
#[doc(hidden)]
pub use self::signer::{NostrSigner, SignerError};
#[doc(hidden)]
pub use self::types::{
    Alphabet, Contact, Filter, ImageDimensions, Metadata, RelayUrl, SingleLetterTag, Timestamp,
    TryIntoUrl, Url,
};
#[doc(hidden)]
pub use self::util::JsonUtil;
#[doc(hidden)]
#[cfg(feature = "std")]
pub use self::util::SECP256K1;

/// Result
#[doc(hidden)]
#[cfg(feature = "std")]
pub type Result<T, E = alloc::boxed::Box<dyn std::error::Error>> = std::result::Result<T, E>;

================
File: src/prelude.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Prelude

#![allow(unused_imports)]
#![allow(unknown_lints)]
#![allow(ambiguous_glob_reexports)]
#![doc(hidden)]

// External crates
#[cfg(feature = "nip06")]
pub use bip39::Mnemonic;
pub use bitcoin::secp256k1::rand;
pub use bitcoin::secp256k1::schnorr::Signature;
pub use negentropy::Negentropy;
pub use serde_json::Value;

// Internal modules
pub use crate::event::builder::{self, *};
pub use crate::event::id::{self, *};
pub use crate::event::kind::{self, *};
pub use crate::event::tag::{self, *};
pub use crate::event::unsigned::{self, *};
pub use crate::event::{self, *};
pub use crate::key::{self, *};
pub use crate::message::{self, *};
// NIPs
pub use crate::nips::nip01::{self, *};
#[cfg(feature = "nip04")]
pub use crate::nips::nip04;
#[cfg(all(feature = "std", feature = "nip05"))]
pub use crate::nips::nip05::{self, *};
#[cfg(feature = "nip06")]
pub use crate::nips::nip06::{self, *};
#[cfg(all(feature = "nip07", target_arch = "wasm32"))]
pub use crate::nips::nip07::{self, *};
pub use crate::nips::nip10::{self, *};
#[cfg(all(feature = "std", feature = "nip11"))]
pub use crate::nips::nip11::{self, *};
pub use crate::nips::nip13::{self, *};
pub use crate::nips::nip15::{self, *};
pub use crate::nips::nip17::{self, *};
pub use crate::nips::nip19::{self, *};
pub use crate::nips::nip21::{self, *};
pub use crate::nips::nip26::{self, *};
pub use crate::nips::nip34::{self, *};
pub use crate::nips::nip39::{self, *};
#[cfg(feature = "nip44")]
pub use crate::nips::nip44::{self, *};
#[cfg(all(feature = "std", feature = "nip46"))]
pub use crate::nips::nip46::{self, *};
#[cfg(feature = "nip47")]
pub use crate::nips::nip47::{self, *};
pub use crate::nips::nip48::{self, *};
#[cfg(feature = "nip49")]
pub use crate::nips::nip49::{self, *};
pub use crate::nips::nip51::{self, *};
pub use crate::nips::nip53::{self, *};
pub use crate::nips::nip56::{self, *};
#[cfg(feature = "nip57")]
pub use crate::nips::nip57::{self, *};
pub use crate::nips::nip58;
#[cfg(feature = "nip59")]
pub use crate::nips::nip59::{self, *};
pub use crate::nips::nip65::{self, *};
pub use crate::nips::nip90::{self, *};
pub use crate::nips::nip94::{self, *};
pub use crate::nips::nip98::{self, *};
pub use crate::signer::{self, *};
pub use crate::types::*;
pub use crate::util::{self, *};
#[cfg(feature = "std")]
pub use crate::{Result, SECP256K1};

================
File: src/signer.rs
================
// Copyright (c) 2022-2023 Yuki Kishimoto
// Copyright (c) 2023-2024 Rust Nostr Developers
// Distributed under the MIT software license

//! Nostr Signer

use alloc::borrow::Cow;
use alloc::boxed::Box;
#[cfg(any(not(feature = "std"), feature = "nip04", feature = "nip44"))]
use alloc::string::String;
use alloc::sync::Arc;
use core::fmt;

use async_trait::async_trait;

use crate::{Event, PublicKey, UnsignedEvent};

#[cfg(feature = "std")]
type InnerError = Box<dyn std::error::Error + Send + Sync>;
#[cfg(not(feature = "std"))]
type InnerError = String; // TODO: remove core::error::Error will be stable for MSRV

/// Nostr Signer error
#[derive(Debug)]
pub struct SignerError(InnerError);

impl fmt::Display for SignerError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[cfg(feature = "std")]
impl std::error::Error for SignerError {}

impl SignerError {
    /// New signer error
    #[inline]
    #[cfg(feature = "std")]
    pub fn backend<E>(error: E) -> Self
    where
        E: std::error::Error + Send + Sync + 'static,
    {
        Self(Box::new(error))
    }

    /// New signer error
    #[inline]
    #[cfg(not(feature = "std"))]
    pub fn backend<E>(error: E) -> Self
    where
        E: Into<String>,
    {
        Self(error.into())
    }
}

#[doc(hidden)]
pub trait IntoNostrSigner {
    fn into_nostr_signer(self) -> Arc<dyn NostrSigner>;
}

impl<T> IntoNostrSigner for T
where
    T: NostrSigner + 'static,
{
    fn into_nostr_signer(self) -> Arc<dyn NostrSigner> {
        Arc::new(self)
    }
}

/// Signer backend
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum SignerBackend<'a> {
    /// Secret key
    Keys,
    /// Browser extension (NIP07)
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/07.md>
    BrowserExtension,
    /// Nostr Connect (NIP46)
    ///
    /// <https://github.com/nostr-protocol/nips/blob/master/46.md>
    NostrConnect,
    /// Custom
    Custom(Cow<'a, str>),
}

/// Nostr signer abstraction
#[cfg_attr(target_arch = "wasm32", async_trait(?Send))]
#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
pub trait NostrSigner: AsyncTraitDeps {
    /// Signer backend
    fn backend(&self) -> SignerBackend;

    /// Get signer public key
    async fn get_public_key(&self) -> Result<PublicKey, SignerError>;

    /// Sign an unsigned event
    async fn sign_event(&self, unsigned: UnsignedEvent) -> Result<Event, SignerError>;

    /// NIP04 encrypt (deprecate and unsecure)
    #[cfg(feature = "nip04")]
    async fn nip04_encrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError>;

    /// NIP04 decrypt
    #[cfg(feature = "nip04")]
    async fn nip04_decrypt(
        &self,
        public_key: &PublicKey,
        encrypted_content: &str,
    ) -> Result<String, SignerError>;

    /// NIP44 encrypt
    #[cfg(feature = "nip44")]
    async fn nip44_encrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError>;

    /// NIP44 decrypt
    #[cfg(feature = "nip44")]
    async fn nip44_decrypt(
        &self,
        public_key: &PublicKey,
        payload: &str,
    ) -> Result<String, SignerError>;
}

#[cfg_attr(target_arch = "wasm32", async_trait(?Send))]
#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
impl NostrSigner for Arc<dyn NostrSigner> {
    #[inline]
    fn backend(&self) -> SignerBackend {
        self.as_ref().backend()
    }

    #[inline]
    async fn get_public_key(&self) -> Result<PublicKey, SignerError> {
        self.as_ref().get_public_key().await
    }

    #[inline]
    async fn sign_event(&self, unsigned: UnsignedEvent) -> Result<Event, SignerError> {
        self.as_ref().sign_event(unsigned).await
    }

    #[inline]
    #[cfg(feature = "nip04")]
    async fn nip04_encrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError> {
        self.as_ref().nip04_encrypt(public_key, content).await
    }

    #[inline]
    #[cfg(feature = "nip04")]
    async fn nip04_decrypt(
        &self,
        public_key: &PublicKey,
        encrypted_content: &str,
    ) -> Result<String, SignerError> {
        self.as_ref()
            .nip04_decrypt(public_key, encrypted_content)
            .await
    }

    #[inline]
    #[cfg(feature = "nip44")]
    async fn nip44_encrypt(
        &self,
        public_key: &PublicKey,
        content: &str,
    ) -> Result<String, SignerError> {
        self.as_ref().nip44_encrypt(public_key, content).await
    }

    #[inline]
    #[cfg(feature = "nip44")]
    async fn nip44_decrypt(
        &self,
        public_key: &PublicKey,
        payload: &str,
    ) -> Result<String, SignerError> {
        self.as_ref().nip44_decrypt(public_key, payload).await
    }
}

/// Alias for `Send` on non-wasm, empty trait (implemented by everything) on
/// wasm.
#[cfg(not(target_arch = "wasm32"))]
pub trait SendOutsideWasm: Send {}
#[cfg(not(target_arch = "wasm32"))]
impl<T: Send> SendOutsideWasm for T {}

/// Alias for `Send` on non-wasm, empty trait (implemented by everything) on
/// wasm.
#[cfg(target_arch = "wasm32")]
pub trait SendOutsideWasm {}
#[cfg(target_arch = "wasm32")]
impl<T> SendOutsideWasm for T {}

/// Alias for `Sync` on non-wasm, empty trait (implemented by everything) on
/// wasm.
#[cfg(not(target_arch = "wasm32"))]
pub trait SyncOutsideWasm: Sync {}
#[cfg(not(target_arch = "wasm32"))]
impl<T: Sync> SyncOutsideWasm for T {}

/// Alias for `Sync` on non-wasm, empty trait (implemented by everything) on
/// wasm.
#[cfg(target_arch = "wasm32")]
pub trait SyncOutsideWasm {}
#[cfg(target_arch = "wasm32")]
impl<T> SyncOutsideWasm for T {}

/// Super trait that is used for our store traits, this trait will differ if
/// it's used on WASM. WASM targets will not require `Send` and `Sync` to have
/// implemented, while other targets will.
pub trait AsyncTraitDeps: fmt::Debug + SendOutsideWasm + SyncOutsideWasm {}
impl<T: fmt::Debug + SendOutsideWasm + SyncOutsideWasm> AsyncTraitDeps for T {}

================
File: Cargo.toml
================
[package]
name = "nostr"
version = "0.37.0"
edition = "2021"
description = "Rust implementation of the Nostr protocol."
authors.workspace = true
homepage.workspace = true
repository.workspace = true
license.workspace = true
readme = "README.md"
rust-version.workspace = true
keywords = ["nostr", "protocol", "no_std"]

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]

[features]
default = ["std"]
std = [
    "dep:url",
    "base64?/std",
    "bech32/std",
    "bitcoin/std",
    "bitcoin/rand-std",
    "bip39?/std",
    "cbc?/std",
    "chacha20?/std",
    "chacha20poly1305?/std",
    "negentropy/std",
    "negentropy-deprecated/std",
    "once_cell/std",
    "scrypt?/std",
    "serde/std",
    "serde_json/std",
    "serde_json/preserve_order",
    "unicode-normalization?/std",
]
alloc = [
    "dep:url-fork",
    "base64?/alloc",
    "bech32/alloc",
    "cbc?/alloc",
    "chacha20poly1305?/alloc",
    "once_cell/alloc",
    "serde/alloc",
    "serde_json/alloc",
]
all-nips = ["nip04", "nip05", "nip06", "nip07", "nip11", "nip44", "nip46", "nip47", "nip49", "nip57", "nip59"]
nip03 = ["dep:nostr-ots"]
nip04 = ["dep:aes", "dep:base64", "dep:cbc"]
nip05 = ["dep:reqwest"]
nip06 = ["dep:bip39"]
nip07 = ["dep:js-sys", "dep:wasm-bindgen", "dep:wasm-bindgen-futures", "dep:web-sys"]
nip11 = ["dep:reqwest"]
nip44 = ["dep:base64", "dep:chacha20"]
nip46 = ["nip04", "nip44"]
nip47 = ["nip04"]
nip49 = ["dep:chacha20poly1305", "dep:scrypt", "dep:unicode-normalization"]
nip57 = ["dep:aes", "dep:cbc"]
nip59 = ["nip44"]

[dependencies]
aes = { version = "0.8", optional = true }
async-trait.workspace = true
base64 = { version = "0.22", default-features = false, optional = true }
bech32 = { version = "0.11", default-features = false } # bitcoin uses v0.11
bip39 = { version = "2.0", default-features = false, optional = true }
bitcoin = { version = "0.32", default-features = false, features = ["rand", "serde"] }
cbc = { version = "0.1", optional = true }
chacha20 = { version = "0.9", optional = true }
chacha20poly1305 = { version = "0.10", default-features = false, features = ["getrandom"], optional = true }
negentropy.workspace = true
negentropy-deprecated.workspace = true
nostr-ots = { version = "0.2", optional = true }
once_cell.workspace = true
reqwest = { version = "0.12", default-features = false, features = ["json", "rustls-tls", "socks"], optional = true }
scrypt = { version = "0.11", default-features = false, optional = true }
serde = { version = "1.0", default-features = false, features = ["derive"] }
serde_json.workspace = true
unicode-normalization = { version = "0.1", default-features = false, optional = true }
url = { version = "2.5", default-features = false, features = ["serde"], optional = true } # Used in std
url-fork = { version = "3.0", default-features = false, features = ["serde"], optional = true } # Used for no_std

[target.'cfg(target_arch = "wasm32")'.dependencies]
getrandom = { version = "0.2", features = ["js"] }
instant = { version = "0.1", features = ["wasm-bindgen", "inaccurate"] }
js-sys = { workspace = true, optional = true }
wasm-bindgen = { workspace = true, optional = true }
wasm-bindgen-futures = { workspace = true, optional = true }
web-sys = { workspace = true, features = ["Window"], optional = true }

[dev-dependencies]
num_cpus = "1.15"
tokio = { workspace = true, features = ["full"] }

[[example]]
name = "keys"
required-features = ["std"]

[[example]]
name = "metadata"
required-features = ["std"]

[[example]]
name = "nip05"
required-features = ["std", "nip05"]

[[example]]
name = "nip06"
required-features = ["std", "nip06"]

[[example]]
name = "nip09"
required-features = ["std"]

[[example]]
name = "nip11"
required-features = ["std", "nip11"]

[[example]]
name = "nip13"
required-features = ["std"]

[[example]]
name = "nip19"
required-features = ["std"]

[[example]]
name = "nip57"
required-features = ["std", "nip57"]

[[example]]
name = "vanity"
required-features = ["std"]

[[example]]
name = "nip15"
required-features = ["std"]

[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(bench)'] }

================
File: README.md
================
# Nostr

[![crates.io](https://img.shields.io/crates/v/nostr.svg)](https://crates.io/crates/nostr)
[![crates.io - Downloads](https://img.shields.io/crates/d/nostr)](https://crates.io/crates/nostr)
[![Documentation](https://docs.rs/nostr/badge.svg)](https://docs.rs/nostr)
[![CI](https://github.com/rust-nostr/nostr/actions/workflows/ci.yml/badge.svg)](https://github.com/rust-nostr/nostr/actions/workflows/ci.yml)
[![MIT](https://img.shields.io/crates/l/nostr.svg)](../../LICENSE)

## Description

Rust implementation of Nostr protocol.

You may be interested in:
* [`nostr-sdk`](https://crates.io/crates/nostr-sdk) if you want to write a typical Nostr client or bot
* [`nostr-relay-pool`](https://crates.io/crates/nostr-relay-pool): Nostr Relay Pool
* [`nostr-connect`](https://crates.io/crates/nostr-connect): Nostr Connect (NIP46)
* [`nwc`](https://crates.io/crates/nwc): Nostr Wallet Connect (NWC) client

## Getting started

```rust,no_run
use nostr::prelude::*;

fn main() -> Result<()> {
    // Generate new random keys
    let keys = Keys::generate();

    // Or use your already existing (from hex or bech32)
    let keys = Keys::parse("hex-or-bech32-secret-key")?;

    // Convert public key to bech32
    println!("Public key: {}", keys.public_key().to_bech32()?);

    let metadata = Metadata::new()
        .name("username")
        .display_name("My Username")
        .about("Description")
        .picture(Url::parse("https://example.com/avatar.png")?)
        .banner(Url::parse("https://example.com/banner.png")?)
        .nip05("username@example.com")
        .lud16("pay@yukikishimoto.com")
        .custom_field("custom_field", "my value");

    let event: Event = EventBuilder::metadata(&metadata).sign_with_keys(&keys)?;

    // New text note
    let event: Event = EventBuilder::text_note("Hello from rust-nostr").sign_with_keys(&keys)?;

    // New POW text note
    let event: Event = EventBuilder::text_note("POW text note from rust-nostr").pow(20).sign_with_keys(&keys)?;

    // Convert client nessage to JSON
    let json = ClientMessage::event(event).as_json();
    println!("{json}");

    Ok(())
}
```

More examples can be found in the [examples/](https://github.com/rust-nostr/nostr/tree/master/crates/nostr/examples) directory.

## WASM

This crate supports the `wasm32` targets.

On macOS you need to install `llvm`:

```shell
brew install llvm
LLVM_PATH=$(brew --prefix llvm)
AR="${LLVM_PATH}/bin/llvm-ar" CC="${LLVM_PATH}/bin/clang" cargo build --target wasm32-unknown-unknown
```

NOTE: Currently `nip03` feature not support WASM.

## Embedded

This crate support [`no_std`](https://docs.rust-embedded.org/book/intro/no-std.html) environments.

Check the example in the [embedded/](https://github.com/rust-nostr/nostr/tree/master/crates/nostr/examples/embedded) directory.

## Crate Feature Flags

The following crate feature flags are available:

| Feature    | Default | Description                                                                                  |
|------------|:-------:|----------------------------------------------------------------------------------------------|
| `std`      |   Yes   | Enable `std` library                                                                         |
| `alloc`    |   No    | Needed to use this library in `no_std` context                                               |
| `all-nips` |   No    | Enable all NIPs                                                                              |
| `nip03`    |   No    | Enable NIP-03: OpenTimestamps Attestations for Events                                        |
| `nip04`    |   No    | Enable NIP-04: Encrypted Direct Message                                                      |
| `nip05`    |   No    | Enable NIP-05: Mapping Nostr keys to DNS-based internet identifiers                          |
| `nip06`    |   No    | Enable NIP-06: Basic key derivation from mnemonic seed phrase                                |
| `nip07`    |   No    | Enable NIP-07: `window.nostr` capability for web browsers (**available only for `wasm32`!**) |
| `nip11`    |   No    | Enable NIP-11: Relay Information Document                                                    |
| `nip44`    |   No    | Enable NIP-44: Encrypted Payloads (Versioned)                                                |
| `nip46`    |   No    | Enable NIP-46: Nostr Connect                                                                 |
| `nip47`    |   No    | Enable NIP-47: Nostr Wallet Connect                                                          |
| `nip49`    |   No    | Enable NIP-49: Private Key Encryption                                                        |
| `nip57`    |   No    | Enable NIP-57: Zaps                                                                          |
| `nip59`    |   No    | Enable NIP-59: Gift Wrap                                                                     |

## Supported NIPs

| Supported | NIP                                                                                                             |
|:---------:|-----------------------------------------------------------------------------------------------------------------|
|          | [01 - Basic protocol flow description](https://github.com/nostr-protocol/nips/blob/master/01.md)                |
|          | [02 - Follow List](https://github.com/nostr-protocol/nips/blob/master/02.md)                                    |
|          | [03 - OpenTimestamps Attestations for Events](https://github.com/nostr-protocol/nips/blob/master/03.md)         |
|          | [04 - Encrypted Direct Message](https://github.com/nostr-protocol/nips/blob/master/04.md)                       |
|          | [05 - Mapping Nostr keys to DNS-based internet ids](https://github.com/nostr-protocol/nips/blob/master/05.md)   |
|          | [06 - Basic key derivation from mnemonic seed phrase](https://github.com/nostr-protocol/nips/blob/master/06.md) |
|          | [07 - `window.nostr` capability for web browsers](https://github.com/nostr-protocol/nips/blob/master/07.md)     |
|          | [09 - Event Deletion](https://github.com/nostr-protocol/nips/blob/master/09.md)                                 |
|          | [10 - Use of `e` and `p` tags in text events](https://github.com/nostr-protocol/nips/blob/master/10.md)         |
|          | [11 - Relay Information Document](https://github.com/nostr-protocol/nips/blob/master/11.md)                     |
|          | [13 - Proof of Work](https://github.com/nostr-protocol/nips/blob/master/13.md)                                  |
|          | [14 - Subject tag in text events](https://github.com/nostr-protocol/nips/blob/master/14.md)                     |
|          | [15 - Nostr Marketplace](https://github.com/nostr-protocol/nips/blob/master/15.md)                              |
|          | [17 - Private Direct Messages](https://github.com/nostr-protocol/nips/blob/master/17.md)                        |
|          | [18 - Reposts](https://github.com/nostr-protocol/nips/blob/master/18.md)                                        |
|          | [19 - bech32-encoded entities](https://github.com/nostr-protocol/nips/blob/master/19.md)                        |
|          | [21 - URI scheme](https://github.com/nostr-protocol/nips/blob/master/21.md)                                     |
|          | [22 - Comment](https://github.com/nostr-protocol/nips/blob/master/22.md)                                        |
|          | [23 - Long-form Content](https://github.com/nostr-protocol/nips/blob/master/23.md)                              |
|          | [24 - Extra metadata fields and tags](https://github.com/nostr-protocol/nips/blob/master/24.md)                 |
|          | [25 - Reactions](https://github.com/nostr-protocol/nips/blob/master/25.md)                                      |
|          | [26 - Delegated Event Signing](https://github.com/nostr-protocol/nips/blob/master/26.md)                        |
|          | [27 - Text Note References](https://github.com/nostr-protocol/nips/blob/master/27.md)                           |
|          | [28 - Public Chat](https://github.com/nostr-protocol/nips/blob/master/28.md)                                    |
|          | [29 - Relay-based Groups](https://github.com/nostr-protocol/nips/blob/master/29.md)                             |
|          | [30 - Custom Emoji](https://github.com/nostr-protocol/nips/blob/master/30.md)                                   |
|          | [31 - Dealing with Unknown Events](https://github.com/nostr-protocol/nips/blob/master/31.md)                    |
|          | [32 - Labeling](https://github.com/nostr-protocol/nips/blob/master/32.md)                                       |
|          | [34 - `git` stuff](https://github.com/nostr-protocol/nips/blob/master/34.md)                                    |
|          | [35 - Torrents](https://github.com/nostr-protocol/nips/blob/master/35.md)                                       |
|          | [36 - Sensitive Content](https://github.com/nostr-protocol/nips/blob/master/36.md)                              |
|          | [38 - User Statuses](https://github.com/nostr-protocol/nips/blob/master/38.md)                                  |
|          | [39 - External Identities in Profiles](https://github.com/nostr-protocol/nips/blob/master/39.md)                |
|          | [40 - Expiration Timestamp](https://github.com/nostr-protocol/nips/blob/master/40.md)                           |
|          | [42 - Authentication of clients to relays](https://github.com/nostr-protocol/nips/blob/master/42.md)            |
|          | [44 - Encrypted Payloads (Versioned)](https://github.com/nostr-protocol/nips/blob/master/44.md)                 |
|          | [45 - Event Counts](https://github.com/nostr-protocol/nips/blob/master/45.md)                                   |
|          | [46 - Nostr Connect](https://github.com/nostr-protocol/nips/blob/master/46.md)                                  |
|          | [47 - Wallet Connect](https://github.com/nostr-protocol/nips/blob/master/47.md)                                 |
|          | [48 - Proxy Tags](https://github.com/nostr-protocol/nips/blob/master/48.md)                                     |
|          | [49 - Private Key Encryption](https://github.com/nostr-protocol/nips/blob/master/49.md)                         |
|          | [50 - Search Capability](https://github.com/nostr-protocol/nips/blob/master/50.md)                              |
|          | [51 - Lists](https://github.com/nostr-protocol/nips/blob/master/51.md)                                          |
|          | [52 - Calendar Events](https://github.com/nostr-protocol/nips/blob/master/52.md)                                |
|          | [53 - Live Activities](https://github.com/nostr-protocol/nips/blob/master/53.md)                                |
|          | [54 - Wiki](https://github.com/nostr-protocol/nips/blob/master/54.md)                                           |
|     -     | [55 - Android Signer Application](https://github.com/nostr-protocol/nips/blob/master/55.md)                     |
|          | [56 - Reporting](https://github.com/nostr-protocol/nips/blob/master/56.md)                                      |
|          | [57 - Lightning Zaps](https://github.com/nostr-protocol/nips/blob/master/57.md)                                 |
|          | [58 - Badges](https://github.com/nostr-protocol/nips/blob/master/58.md)                                         |
|          | [59 - Gift Wrap](https://github.com/nostr-protocol/nips/blob/master/59.md)                                      |
|          | [65 - Relay List Metadata](https://github.com/nostr-protocol/nips/blob/master/65.md)                            |
|          | [70 - Protected Events](https://github.com/nostr-protocol/nips/blob/master/70.md)                               |
|          | [71 - Video Events](https://github.com/nostr-protocol/nips/blob/master/71.md)                                   |
|          | [72 - Moderated Communities](https://github.com/nostr-protocol/nips/blob/master/72.md)                          |
|          | [73 - External Content IDs](https://github.com/nostr-protocol/nips/blob/master/73.md)                           |
|          | [75 - Zap Goals](https://github.com/nostr-protocol/nips/blob/master/75.md)                                      |
|          | [78 - Arbitrary custom app data](https://github.com/nostr-protocol/nips/blob/master/78.md)                      |
|          | [89 - Recommended Application Handlers](https://github.com/nostr-protocol/nips/blob/master/89.md)               |
|          | [90 - Data Vending Machine](https://github.com/nostr-protocol/nips/blob/master/90.md)                           |
|          | [92 - Media Attachments](https://github.com/nostr-protocol/nips/blob/master/92.md)                              |
|          | [94 - File Metadata](https://github.com/nostr-protocol/nips/blob/master/94.md)                                  |
|          | [96 - HTTP File Storage Integration](https://github.com/nostr-protocol/nips/blob/master/96.md)                  |
|          | [98 - HTTP Auth](https://github.com/nostr-protocol/nips/blob/master/98.md)                                      |
|          | [99 - Classified Listings](https://github.com/nostr-protocol/nips/blob/master/99.md)                            |

## State

**This library is in an ALPHA state**, things that are implemented generally work but the API will change in breaking ways.

## Donations

`rust-nostr` is free and open-source. This means we do not earn any revenue by selling it. Instead, we rely on your financial support. If you actively use any of the `rust-nostr` libs/software/services, then please [donate](https://rust-nostr.org/donate).

## License

This project is distributed under the MIT software license - see the [LICENSE](../../LICENSE) file for details



================================================================
End of Codebase
================================================================
